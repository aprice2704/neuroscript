{
  "schemaVersion": "1.7",
  "repoRoot": "github.com/aprice2704/neuroscript",
  "packages": {
    "cmd/block_printer": {
      "files": {
        "cmd/block_printer/main.go": {
          "methods": []
        }
      }
    },
    "cmd/cfiles": {
      "files": {
        "cmd/cfiles/main.go": {
          "functions": [
            "main",
            "min",
            "max"
          ],
          "methods": []
        }
      }
    },
    "cmd/gensync": {
      "files": {
        "cmd/gensync/helpers.go": {
          "functions": [
            "init",
            "LoadIndex",
            "SaveIndex",
            "CalculateFileHash",
            "UploadFile"
          ],
          "methods": []
        },
        "cmd/gensync/main.go": {
          "functions": [
            "main",
            "worker",
            "nukeAllFiles"
          ],
          "methods": []
        }
      }
    },
    "cmd/goindexer": {
      "files": {
        "cmd/goindexer/finder.go": {
          "functions": [
            "findRepoPaths",
            "parseModulePath"
          ],
          "methods": []
        },
        "cmd/goindexer/formatters.go": {
          "functions": [
            "formatNode",
            "formatFieldList",
            "formatSignature",
            "formatReceiver",
            "determineKind"
          ],
          "methods": []
        },
        "cmd/goindexer/main.go": {
          "functions": [
            "main"
          ],
          "methods": [
            {
              "Receiver": "*CommaSeparatedFlag",
              "Name": "String"
            },
            {
              "Receiver": "*CommaSeparatedFlag",
              "Name": "Set"
            }
          ]
        },
        "cmd/goindexer/parser.go": {
          "functions": [
            "processFile"
          ],
          "methods": []
        },
        "cmd/goindexer/resolvers.go": {
          "functions": [
            "getRelativePackagePath",
            "getRelativeFilePath",
            "constructShortName",
            "resolveCallTarget",
            "isBuiltin"
          ],
          "methods": []
        }
      }
    },
    "cmd/ng": {
      "files": {
        "cmd/ng/main.go": {
          "functions": [
            "initializeLogger",
            "main"
          ],
          "methods": []
        }
      }
    },
    "cmd/nsinput": {
      "files": {
        "cmd/nsinput/main.go": {
          "functions": [
            "initialModel",
            "main"
          ],
          "methods": [
            {
              "Receiver": "model",
              "Name": "Init"
            },
            {
              "Receiver": "model",
              "Name": "Update",
              "calls": [
                "m.textarea.Update(?)",
                "m.textarea.SetWidth(?)",
                "github.com/charmbracelet/bubbletea.Batch"
              ]
            },
            {
              "Receiver": "model",
              "Name": "View",
              "calls": [
                "m.textarea.View(?)"
              ]
            }
          ]
        }
      }
    },
    "cmd/nspatch": {
      "files": {
        "cmd/nspatch/nspatch.go": {
          "functions": [
            "stripPrefixComponents",
            "main",
            "readFileLines",
            "writeFileLines"
          ],
          "methods": []
        }
      }
    },
    "pkg/adapters": {
      "files": {
        "pkg/adapters/noop_llmclient.go": {
          "functions": [
            "NewNoOpLLMClient"
          ],
          "methods": [
            {
              "Receiver": "*NoOpLLMClient",
              "Name": "Ask"
            },
            {
              "Receiver": "*NoOpLLMClient",
              "Name": "AskWithTools"
            },
            {
              "Receiver": "*NoOpLLMClient",
              "Name": "Embed"
            },
            {
              "Receiver": "*NoOpLLMClient",
              "Name": "Client"
            }
          ]
        },
        "pkg/adapters/noop_logger.go": {
          "functions": [
            "NewNoOpLogger"
          ],
          "methods": [
            {
              "Receiver": "*NoOpLogger",
              "Name": "Debug"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Info"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Warn"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Error"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Debugf"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Infof"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Warnf"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Errorf"
            }
          ]
        },
        "pkg/adapters/slogadapter.go": {
          "functions": [
            "NewSlogAdapter",
            "SimpleTestLogger"
          ],
          "methods": [
            {
              "Receiver": "*SlogAdapter",
              "Name": "Debug",
              "calls": [
                "a.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Info",
              "calls": [
                "a.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Warn",
              "calls": [
                "a.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Error",
              "calls": [
                "a.logger.Error(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Debugf",
              "calls": [
                "a.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Infof",
              "calls": [
                "a.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Warnf",
              "calls": [
                "a.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*SlogAdapter",
              "Name": "Errorf",
              "calls": [
                "a.logger.Error(?)"
              ]
            }
          ]
        }
      }
    },
    "pkg/core": {
      "files": {
        "pkg/core/ast.go": {
          "functions": [
            "newStep"
          ],
          "methods": [
            {
              "Receiver": "*Position",
              "Name": "GetPos"
            },
            {
              "Receiver": "*Position",
              "Name": "String"
            },
            {
              "Receiver": "*Program",
              "Name": "GetPos"
            },
            {
              "Receiver": "*CallTarget",
              "Name": "GetPos"
            },
            {
              "Receiver": "*CallableExprNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*VariableNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*PlaceholderNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*LastNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*EvalNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*StringLiteralNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*NumberLiteralNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*BooleanLiteralNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*ListLiteralNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*MapEntryNode",
              "Name": "GetPos",
              "calls": [
                "n.Key.GetPos(?)"
              ]
            },
            {
              "Receiver": "*MapLiteralNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*ElementAccessNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*UnaryOpNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*BinaryOpNode",
              "Name": "GetPos"
            },
            {
              "Receiver": "*Procedure",
              "Name": "GetPos"
            },
            {
              "Receiver": "*Step",
              "Name": "GetPos"
            },
            {
              "Receiver": "StringLiteralNode",
              "Name": "String"
            },
            {
              "Receiver": "CallableExprNode",
              "Name": "String"
            }
          ]
        },
        "pkg/core/ast_builder_blocks.go": {
          "methods": [
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "enterBlockContext",
              "calls": [
                "l.logDebugAST(?)",
                "l.logger.Warn(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "exitBlockContext",
              "calls": [
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.logger.Warn(?)",
                "l.logger.Error(?)",
                "l.logger.Debug(?)",
                "l.logger.Debug(?)",
                "l.logger.Debug(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterStatement_list",
              "calls": [
                "ctx.GetParent(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.EnterStatement_list_within_if(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitStatement_list",
              "calls": [
                "ctx.GetParent(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterIf_statement",
              "calls": [
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterStatement_list_within_if",
              "calls": [
                "ctx.GetParent(?)",
                "ifCtx.KW_ELSE(?)",
                "ifCtx.Statement_list(?)",
                "l.logDebugAST(?)",
                "l.enterBlockContext(?)",
                "ifCtx.Statement_list(?)",
                "l.logDebugAST(?)",
                "l.enterBlockContext(?)",
                "l.logger.Error(?)",
                "l.enterBlockContext(?)",
                "l.logger.Error(?)",
                "l.enterBlockContext(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitIf_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.KW_ELSE(?)",
                "l.exitBlockContext(?)",
                "l.logDebugAST(?)",
                "l.exitBlockContext(?)",
                "l.logDebugAST(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "tokenToPosition",
                "ctx.KW_IF().GetSymbol(?)",
                "ctx.KW_IF(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterWhile_statement",
              "calls": [
                "l.logDebugAST(?)",
                "l.enterBlockContext(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitWhile_statement",
              "calls": [
                "func() { l.loopDepth--; l.logDebugAST(\"\u003c\u003c\u003c Exit WHILE Statement Final (Loop Depth: %d)\", l.loopDepth) }(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.exitBlockContext(?)",
                "l.logDebugAST(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "tokenToPosition",
                "ctx.KW_WHILE().GetSymbol(?)",
                "ctx.KW_WHILE(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterFor_each_statement",
              "calls": [
                "l.logDebugAST(?)",
                "l.enterBlockContext(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitFor_each_statement",
              "calls": [
                "func() {\n\tl.loopDepth--\n\tl.logDebugAST(\"\u003c\u003c\u003c Exit FOR EACH Statement Final (Loop Depth: %d)\", l.loopDepth)\n}(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.exitBlockContext(?)",
                "l.logDebugAST(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.logDebugAST(?)",
                "ctx.IDENTIFIER(?)",
                "id.GetText(?)",
                "l.addError(?)",
                "l.logger.Error(?)",
                "tokenToPosition",
                "ctx.KW_FOR().GetSymbol(?)",
                "ctx.KW_FOR(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterOnErrorStmt",
              "calls": [
                "l.logDebugAST(?)",
                "l.enterBlockContext(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitOnErrorStmt",
              "calls": [
                "l.logDebugAST(?)",
                "l.exitBlockContext(?)",
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "tokenToPosition",
                "ctx.KW_ON_ERROR().GetSymbol(?)",
                "ctx.KW_ON_ERROR(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)"
              ]
            }
          ]
        },
        "pkg/core/ast_builder_collections.go": {
          "methods": [
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitList_literal",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Expression_list_opt(?)",
                "exprListOpt.Expression_list(?)",
                "exprList.AllExpression(?)",
                "l.popNValues(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "ctx.Expression_list_opt(?)",
                "exprListOpt.Expression_list(?)",
                "exprList.AllExpression(?)",
                "exprList.Expression(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "ctx.LBRACK().GetSymbol(?)",
                "ctx.LBRACK(?)",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitMap_entry",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "ctx.STRING_LIT().GetSymbol(?)",
                "ctx.STRING_LIT(?)",
                "keyToken.GetText(?)",
                "unescapeString",
                "l.addErrorf(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitMap_literal",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Map_entry_list_opt(?)",
                "mapEntryListOpt.Map_entry_list(?)",
                "mapEntryList.AllMap_entry(?)",
                "l.popNValues(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "ctx.LBRACE().GetSymbol(?)",
                "ctx.LBRACE(?)",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            }
          ]
        },
        "pkg/core/ast_builder_helpers.go": {
          "functions": [
            "ParseMetadataLine",
            "ConvertInputSchemaToArgSpec",
            "parseNumber",
            "unescapeString"
          ],
          "methods": []
        },
        "pkg/core/ast_builder_main.go": {
          "functions": [
            "tokenToPosition",
            "NewASTBuilder",
            "newNeuroScriptListener",
            "MapKeysListener"
          ],
          "methods": [
            {
              "Receiver": "*ASTBuilder",
              "Name": "Build",
              "calls": [
                "b.logger.Error(?)",
                "b.logger.Debug(?)",
                "newNeuroScriptListener",
                "b.logger.Debug(?)",
                "antlr.NewParseTreeWalker(?)",
                "walker.Walk(?)",
                "b.logger.Debug(?)",
                "listener.GetFileMetadata(?)",
                "b.logger.Warn(?)",
                "err.Error(?)",
                "b.logger.Error(?)",
                "b.logger.Error(?)",
                "b.logger.Error(?)",
                "b.logger.Warn(?)",
                "b.logger.Debug(?)",
                "b.logger.Debug(?)",
                "proc.Pos.String(?)",
                "existingProc.Pos.String(?)",
                "b.logger.Error(?)",
                "proc.Pos.String(?)",
                "existingProc.Pos.String(?)",
                "b.logger.Warn(?)",
                "err.Error(?)",
                "b.logger.Error(?)",
                "b.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "addError",
              "calls": [
                "tokenToPosition",
                "ctx.GetStart(?)",
                "pos.String(?)",
                "existingErr.Error(?)",
                "err.Error(?)",
                "l.logger.Error(?)",
                "pos.String(?)",
                "l.logger.Debug(?)",
                "pos.String(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "addErrorf",
              "calls": [
                "tokenToPosition",
                "pos.String(?)",
                "existingErr.Error(?)",
                "err.Error(?)",
                "l.logger.Error(?)",
                "pos.String(?)",
                "l.logger.Debug(?)",
                "pos.String(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "GetFileMetadata",
              "calls": [
                "l.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "GetResult",
              "calls": [
                "l.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "pushValue",
              "calls": [
                "l.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "popValue",
              "calls": [
                "l.logger.Error(?)",
                "l.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "popNValues",
              "calls": [
                "l.logger.Error(?)",
                "l.logger.Error(?)",
                "l.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "logDebugAST",
              "calls": [
                "l.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "isInsideLoop"
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterProgram",
              "calls": [
                "l.logDebugAST(?)",
                "tokenToPosition",
                "ctx.GetStart(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitProgram",
              "calls": [
                "l.logger.Error(?)",
                "l.logger.Error(?)",
                "l.logger.Error(?)",
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "l.logger.Error(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterFile_header",
              "calls": [
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "ctx.AllMETADATA_LINE(?)",
                "metaLineNode.GetText(?)",
                "metaLineNode.GetSymbol(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.addErrorf(?)",
                "l.addErrorf(?)",
                "l.addErrorf(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitFile_header",
              "calls": [
                "l.logDebugAST(?)"
              ]
            }
          ]
        },
        "pkg/core/ast_builder_operators.go": {
          "functions": [
            "getOperatorToken"
          ],
          "methods": [
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "processBinaryOperators",
              "calls": [
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "opGetter",
                "l.addError(?)",
                "l.pushValue(?)",
                "opToken.GetSymbol(?)",
                "opSymbol.GetText(?)",
                "tokenToPosition",
                "l.logDebugAST(?)",
                "l.pushValue(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitLogical_or_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllLogical_and_expr(?)",
                "ctx.KW_OR(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitLogical_and_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllBitwise_or_expr(?)",
                "ctx.KW_AND(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitBitwise_or_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllBitwise_xor_expr(?)",
                "ctx.PIPE(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitBitwise_xor_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllBitwise_and_expr(?)",
                "ctx.CARET(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitBitwise_and_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllEquality_expr(?)",
                "ctx.AMPERSAND(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitEquality_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllRelational_expr(?)",
                "ctx.GetChildren(?)",
                "term.GetSymbol().GetTokenType(?)",
                "term.GetSymbol(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitRelational_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllAdditive_expr(?)",
                "ctx.GetChildren(?)",
                "term.GetSymbol().GetTokenType(?)",
                "term.GetSymbol(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitAdditive_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllMultiplicative_expr(?)",
                "ctx.GetChildren(?)",
                "term.GetSymbol().GetTokenType(?)",
                "term.GetSymbol(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitMultiplicative_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllUnary_expr(?)",
                "ctx.GetChildren(?)",
                "term.GetSymbol().GetTokenType(?)",
                "term.GetSymbol(?)",
                "l.processBinaryOperators(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitUnary_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.MINUS(?)",
                "ctx.MINUS(?)",
                "ctx.KW_NOT(?)",
                "ctx.KW_NOT(?)",
                "ctx.KW_NO(?)",
                "ctx.KW_NO(?)",
                "ctx.KW_SOME(?)",
                "ctx.KW_SOME(?)",
                "l.logDebugAST(?)",
                "opToken.GetSymbol(?)",
                "opSymbol.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitPower_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.STAR_STAR(?)",
                "l.logDebugAST(?)",
                "opToken.GetSymbol(?)",
                "opSymbol.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitAccessor_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.AllExpression(?)",
                "l.logDebugAST(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "ctx.Expression(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "ctx.Expression(?)",
                "l.pushValue(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "ctx.Primary(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "ctx.Primary(?)",
                "l.pushValue(?)",
                "ctx.LBRACK(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "lBracketToken.GetSymbol(?)",
                "l.logDebugAST(?)",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitCall_target",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.IDENTIFIER(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "idTokenNode.GetText(?)",
                "idTokenNode.GetSymbol(?)",
                "ctx.KW_TOOL(?)",
                "ctx.KW_TOOL().GetSymbol(?)",
                "ctx.KW_TOOL(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitCallable_expr",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Expression_list_opt(?)",
                "exprListOpt.Expression_list(?)",
                "exprList.AllExpression(?)",
                "l.popNValues(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)",
                "ctx.Call_target(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)",
                "targetNode.GetPos(?)",
                "l.logDebugAST(?)",
                "ctx.KW_LN(?)",
                "ctx.KW_LN(?)",
                "ctx.KW_LOG(?)",
                "ctx.KW_LOG(?)",
                "ctx.KW_SIN(?)",
                "ctx.KW_SIN(?)",
                "ctx.KW_COS(?)",
                "ctx.KW_COS(?)",
                "ctx.KW_TAN(?)",
                "ctx.KW_TAN(?)",
                "ctx.KW_ASIN(?)",
                "ctx.KW_ASIN(?)",
                "ctx.KW_ACOS(?)",
                "ctx.KW_ACOS(?)",
                "ctx.KW_ATAN(?)",
                "ctx.KW_ATAN(?)",
                "l.addError(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "keywordToken.GetSymbol(?)",
                "l.logDebugAST(?)",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            }
          ]
        },
        "pkg/core/ast_builder_procedures.go": {
          "functions": [
            "getRuleText"
          ],
          "methods": [
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "EnterProcedure_definition",
              "calls": [
                "ctx.IDENTIFIER(?)",
                "id.GetText(?)",
                "l.logger.Error(?)",
                "l.addError(?)",
                "l.logDebugAST(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "getRuleText",
                "ctx.KW_MEANS(?)",
                "ctx.GetStart(?)",
                "meansToken.GetSymbol(?)",
                "stopToken.GetStart(?)",
                "startToken.GetStart(?)",
                "startToken.GetInputStream().GetText(?)",
                "startToken.GetInputStream(?)",
                "startToken.GetStart(?)",
                "getRuleText",
                "ctx.Signature_part(?)",
                "getRuleText",
                "ctx.Signature_part(?)",
                "l.logDebugAST(?)",
                "ctx.Signature_part(?)",
                "l.logDebugAST(?)",
                "sigPartCtx.Needs_clause(?)",
                "needsCtx.Param_list(?)",
                "l.extractParamList(?)",
                "l.logDebugAST(?)",
                "sigPartCtx.Optional_clause(?)",
                "optionalCtx.Param_list(?)",
                "l.extractParamList(?)",
                "l.logDebugAST(?)",
                "sigPartCtx.Returns_clause(?)",
                "returnsCtx.Param_list(?)",
                "l.extractParamList(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "ctx.Metadata_block(?)",
                "l.logDebugAST(?)",
                "metaBlockCtx.AllMETADATA_LINE(?)",
                "termNode.GetText(?)",
                "termNode.GetSymbol(?)",
                "l.logDebugAST(?)",
                "l.addErrorf(?)",
                "l.addErrorf(?)",
                "l.addErrorf(?)",
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitProcedure_definition",
              "calls": [
                "l.logDebugAST(?)",
                "l.logger.Error(?)",
                "l.logger.Error(?)",
                "l.logger.Warn(?)",
                "l.logDebugAST(?)",
                "l.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "extractParamList",
              "calls": [
                "ctx.AllIDENTIFIER(?)",
                "identifier.GetText(?)"
              ]
            }
          ]
        },
        "pkg/core/ast_builder_statements.go": {
          "methods": [
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitSet_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "ctx.IDENTIFIER().GetText(?)",
                "ctx.IDENTIFIER(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitReturn_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Expression_list(?)",
                "exprListCtx.AllExpression(?)",
                "l.popNValues(?)",
                "l.addError(?)",
                "tokenToPosition",
                "exprListCtx.Expression(i).GetStart(?)",
                "exprListCtx.Expression(?)",
                "pos.String(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.logDebugAST(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitEmit_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Expression(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitMust_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "ctx.Callable_expr(?)",
                "l.addError(?)",
                "l.logDebugAST(?)",
                "ctx.Expression(?)",
                "l.addError(?)",
                "l.logDebugAST(?)",
                "l.addError(?)",
                "l.logger.Debug(?)",
                "l.logger.Debug(?)",
                "l.logger.Debug(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitFail_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Expression(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitClearErrorStmt",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitAsk_stmt",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.addError(?)",
                "ctx.IDENTIFIER(?)",
                "ctx.IDENTIFIER().GetText(?)",
                "ctx.IDENTIFIER(?)",
                "l.logDebugAST(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitCall_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.addError(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitBreak_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.isInsideLoop(?)",
                "l.addError(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitContinue_statement",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "l.isInsideLoop(?)",
                "l.addError(?)",
                "l.addError(?)",
                "tokenToPosition",
                "ctx.GetStart(?)",
                "l.logDebugAST(?)"
              ]
            }
          ]
        },
        "pkg/core/ast_builder_terminators.go": {
          "methods": [
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitExpression",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitPrimary",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.Literal(?)",
                "ctx.Placeholder(?)",
                "ctx.Callable_expr(?)",
                "ctx.LPAREN(?)",
                "l.logDebugAST(?)",
                "ctx.IDENTIFIER(?)",
                "ctx.IDENTIFIER().GetSymbol(?)",
                "ctx.IDENTIFIER(?)",
                "tokenToPosition",
                "token.GetText(?)",
                "l.logDebugAST(?)",
                "ctx.KW_LAST(?)",
                "ctx.KW_LAST().GetSymbol(?)",
                "ctx.KW_LAST(?)",
                "tokenToPosition",
                "l.logDebugAST(?)",
                "ctx.KW_EVAL(?)",
                "ctx.KW_EVAL().GetSymbol(?)",
                "ctx.KW_EVAL(?)",
                "l.popValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "l.addError(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.logDebugAST(?)",
                "l.addError(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)",
                "l.pushValue(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitPlaceholder",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.GetStart(?)",
                "ctx.IDENTIFIER(?)",
                "ctx.IDENTIFIER().GetText(?)",
                "ctx.IDENTIFIER(?)",
                "ctx.KW_LAST(?)",
                "l.addErrorf(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitLiteral",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.STRING_LIT(?)",
                "ctx.STRING_LIT().GetSymbol(?)",
                "ctx.STRING_LIT(?)",
                "token.GetText(?)",
                "unescapeString",
                "l.addErrorf(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)",
                "ctx.TRIPLE_BACKTICK_STRING(?)",
                "ctx.TRIPLE_BACKTICK_STRING().GetSymbol(?)",
                "ctx.TRIPLE_BACKTICK_STRING(?)",
                "token.GetText(?)",
                "l.addErrorf(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)",
                "ctx.NUMBER_LIT(?)",
                "ctx.NUMBER_LIT().GetSymbol(?)",
                "ctx.NUMBER_LIT(?)",
                "token.GetText(?)",
                "parseNumber",
                "l.addErrorf(?)",
                "l.pushValue(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)",
                "ctx.Boolean_literal(?)",
                "ctx.List_literal(?)",
                "ctx.Map_literal(?)",
                "l.logDebugAST(?)",
                "l.addError(?)",
                "ctx.GetText(?)",
                "l.pushValue(?)"
              ]
            },
            {
              "Receiver": "*neuroScriptListenerImpl",
              "Name": "ExitBoolean_literal",
              "calls": [
                "l.logDebugAST(?)",
                "ctx.GetText(?)",
                "ctx.KW_TRUE(?)",
                "ctx.KW_TRUE().GetSymbol(?)",
                "ctx.KW_TRUE(?)",
                "ctx.KW_FALSE().GetSymbol(?)",
                "ctx.KW_FALSE(?)",
                "tokenToPosition",
                "l.pushValue(?)",
                "l.logDebugAST(?)"
              ]
            }
          ]
        },
        "pkg/core/conversation.go": {
          "functions": [
            "NewConversationManager",
            "CreateErrorFunctionResultPart",
            "parseSafetySettings"
          ],
          "methods": [
            {
              "Receiver": "*ConversationManager",
              "Name": "AddUserMessage",
              "calls": [
                "github.com/google/generative-ai-go/genai.Text",
                "cm.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "AddModelMessage",
              "calls": [
                "github.com/google/generative-ai-go/genai.Text",
                "cm.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "AddModelResponse",
              "calls": [
                "cm.logger.Warn(?)",
                "cm.logger.Error(?)",
                "cm.logger.Info(?)",
                "string",
                "cm.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "AddFunctionCallMessage",
              "calls": [
                "cm.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "AddFunctionResponse",
              "calls": [
                "cm.logger.Warn(?)",
                "cm.AddFunctionResultMessage(?)"
              ]
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "AddFunctionResultMessage",
              "calls": [
                "cm.logger.Error(?)",
                "cm.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "GetHistory"
            },
            {
              "Receiver": "*ConversationManager",
              "Name": "ClearHistory",
              "calls": [
                "cm.logger.Info(?)"
              ]
            }
          ]
        },
        "pkg/core/embeddings.go": {
          "functions": [
            "cosineSimilarity"
          ],
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "GenerateEmbedding",
              "calls": [
                "int64",
                "math/rand.New",
                "math/rand.NewSource",
                "float32",
                "rng.Float32(?)",
                "float32",
                "math.Sqrt",
                "float64"
              ]
            }
          ]
        },
        "pkg/core/errors.go": {
          "functions": [
            "NewRuntimeError"
          ],
          "methods": [
            {
              "Receiver": "*RuntimeError",
              "Name": "Error"
            },
            {
              "Receiver": "*RuntimeError",
              "Name": "Unwrap"
            }
          ]
        },
        "pkg/core/evaluation_access.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "evaluateElementAccess",
              "calls": [
                "i.evaluateExpression(?)",
                "i.evaluateExpression(?)",
                "n.Pos.String(?)",
                "i.logger.Debug(?)",
                "NewRuntimeError",
                "NewRuntimeError",
                "i.evaluateListElementAccess(?)",
                "i.evaluateMapElementAccess(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "evaluateListElementAccess",
              "calls": [
                "int64",
                "float64",
                "int64",
                "int64",
                "NewRuntimeError",
                "int",
                "NewRuntimeError",
                "int",
                "i.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "evaluateMapElementAccess",
              "calls": [
                "i.logger.Info(?)",
                "NewRuntimeError",
                "i.logger.Debug(?)"
              ]
            }
          ]
        },
        "pkg/core/evaluation_access_test.go": {
          "functions": [
            "TestEvaluateElementAccess"
          ],
          "methods": []
        },
        "pkg/core/evaluation_arithmetic_test.go": {
          "functions": [
            "TestArithmeticOps"
          ],
          "methods": []
        },
        "pkg/core/evaluation_comparison.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "evaluateCondition",
              "calls": [
                "i.evaluateExpression(?)",
                "errEval.Error(?)",
                "i.logger.Debug(?)",
                "isTruthy",
                "i.logger.Debug(?)"
              ]
            }
          ]
        },
        "pkg/core/evaluation_comparison_test.go": {
          "functions": [
            "TestEvaluateCondition"
          ],
          "methods": []
        },
        "pkg/core/evaluation_functions_test.go": {
          "functions": [
            "TestMathFunctions"
          ],
          "methods": []
        },
        "pkg/core/evaluation_helpers.go": {
          "functions": [
            "toFloat64",
            "toInt64",
            "toString",
            "ToNumeric",
            "isTruthy"
          ],
          "methods": []
        },
        "pkg/core/evaluation_logic.go": {
          "functions": [
            "isZeroValue",
            "evaluateUnaryOp",
            "evaluateBinaryOp",
            "isBuiltInFunction",
            "evaluateBuiltInFunction"
          ],
          "methods": []
        },
        "pkg/core/evaluation_logical_bitwise_test.go": {
          "functions": [
            "TestLogicalBitwiseOps"
          ],
          "methods": []
        },
        "pkg/core/evaluation_main.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "evaluateExpression",
              "calls": [
                "i.resolvePlaceholdersWithError(?)",
                "i.evaluateExpression(?)",
                "i.evaluateExpression(?)",
                "i.evaluateExpression(?)",
                "i.resolvePlaceholdersWithError(?)",
                "i.evaluateExpression(?)",
                "evaluateUnaryOp",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NodeToString",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "isTruthy",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "isTruthy",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NodeToString",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "evaluateBinaryOp",
                "NewRuntimeError",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.ToolRegistry().GetTool(?)",
                "i.ToolRegistry(?)",
                "NewRuntimeError",
                "ValidateAndConvertArgs",
                "NewRuntimeError",
                "toolImpl.Func(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateUserOrBuiltInFunction(?)",
                "i.evaluateElementAccess(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "evaluateUserOrBuiltInFunction",
              "calls": [
                "isBuiltInFunction",
                "evaluateBuiltInFunction",
                "NewRuntimeError",
                "i.RunProcedure(?)",
                "procErr.Error(?)",
                "NewRuntimeError"
              ]
            }
          ]
        },
        "pkg/core/evaluation_operators.go": {
          "functions": [
            "isIntegerType",
            "performArithmetic",
            "performStringConcatOrNumericAdd",
            "performComparison",
            "performLogical",
            "performBitwise"
          ],
          "methods": []
        },
        "pkg/core/evaluation_resolve.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "resolveValue",
              "calls": [
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.GetVariable(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.GetVariable(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.resolvePlaceholdersWithError(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "resolvePlaceholdersWithError",
              "calls": [
                "placeholderRegex.ReplaceAllStringFunc(?)",
                "placeholderRegex.FindStringSubmatch(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.GetVariable(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            }
          ]
        },
        "pkg/core/evaluation_resolve_test.go": {
          "functions": [
            "runResolveValueTest",
            "TestResolveValuePlaceholders"
          ],
          "methods": []
        },
        "pkg/core/evaluation_test.go": {
          "functions": [
            "TestEvaluateExpressionASTGeneral"
          ],
          "methods": []
        },
        "pkg/core/file_api.go": {
          "functions": [
            "NewFileAPI"
          ],
          "methods": [
            {
              "Receiver": "*FileAPI",
              "Name": "ResolvePath",
              "calls": [
                "f.logger.Error(?)",
                "f.logger.Debug(?)",
                "f.logger.Debug(?)",
                "string",
                "string",
                "f.logger.Warn(?)",
                "f.logger.Debug(?)"
              ]
            }
          ]
        },
        "pkg/core/helpers.go": {
          "functions": [
            "min",
            "ConvertToBool",
            "ConvertToInt64E",
            "ConvertToSliceOfString",
            "convertToSliceOfAny",
            "NewTestInterpreter",
            "NewDefaultTestInterpreter"
          ],
          "methods": [
            {
              "Receiver": "*TestLogger",
              "Name": "Debug",
              "calls": [
                "l.t.Log(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Info",
              "calls": [
                "l.t.Log(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Warn",
              "calls": [
                "l.t.Log(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Error",
              "calls": [
                "l.t.Log(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Debugf",
              "calls": [
                "l.t.Logf(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Infof",
              "calls": [
                "l.t.Logf(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Warnf",
              "calls": [
                "l.t.Logf(?)"
              ]
            },
            {
              "Receiver": "*TestLogger",
              "Name": "Errorf",
              "calls": [
                "l.t.Logf(?)"
              ]
            }
          ]
        },
        "pkg/core/interpreter.go": {
          "functions": [
            "NewInterpreter"
          ],
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "SandboxDir"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "Logger"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "FileAPI"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "SetSandboxDir",
              "calls": [
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "NewFileAPI",
                "i.Logger().Info(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "SetToolRegistry",
              "calls": [
                "i.logger.Error(?)",
                "i.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "SetVariable",
              "calls": [
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "GetVariable"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "ToolRegistry",
              "calls": [
                "i.Logger().Error(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "GenAIClient",
              "calls": [
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "i.llmClient.Client(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "AddProcedure",
              "calls": [
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "KnownProcedures"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "GetVectorIndex"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "SetVectorIndex"
            },
            {
              "Receiver": "*Interpreter",
              "Name": "RegisterHandle",
              "calls": [
                "github.com/google/uuid.NewString",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "GetHandleValue",
              "calls": [
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "RemoveHandle",
              "calls": [
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "RunProcedure",
              "calls": [
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "func() {\n\tif r := recover(); r != nil {\n\t\terr = fmt.Errorf(\"panic occurred during procedure '%s': %v\", procName, r)\n\t\ti.Logger().Error(\"Panic recovered during procedure execution\", \"proc_name\", procName, \"panic_value\", r)\n\t}\n\ti.currentProcName = originalProcName\n\tlogArgs := []any{\"proc_name\", procName, \"restored_proc_name\", i.currentProcName, \"result\", result, \"result_type\", fmt.Sprintf(\"%T\", result), \"error\", err}\n\ti.Logger().Info(\"Finished procedure.\", logArgs...)\n}(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "func() {\n\ti.variables = originalScope\n\ti.Logger().Debug(\"Restored variable scope.\", \"proc_name\", procName)\n}(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.SetVariable(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "interface{}(?)",
                "i.SetVariable(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.executeSteps(?)",
                "reflect.ValueOf",
                "resultValue.Kind(?)",
                "resultValue.IsNil(?)",
                "resultValue.Elem(?)",
                "resultValue.Kind(?)",
                "resultValue.Len(?)",
                "resultValue.IsValid(?)",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            }
          ]
        },
        "pkg/core/interpreter_exec.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "executeSteps",
              "calls": [
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "interface{}(?)",
                "error",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "i.executeSet(?)",
                "NewRuntimeError",
                "i.executeReturn(?)",
                "i.executeEmit(?)",
                "i.executeIf(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.executeWhile(?)",
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "i.executeFor(?)",
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "i.executeMust(?)",
                "i.executeFail(?)",
                "i.executeOnError(?)",
                "i.executeClearError(?)",
                "i.executeAsk(?)",
                "i.executeBreak(?)",
                "i.executeContinue(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.executeSteps(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "currentErrorHandler.Pos.String(?)",
                "NewRuntimeError",
                "NewRuntimeError",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeBlock",
              "calls": [
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "i.executeSteps(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)"
              ]
            }
          ]
        },
        "pkg/core/interpreter_steps.go": {
          "methods": []
        },
        "pkg/core/interpreter_steps_ask.go": {
          "functions": [
            "ConvertToolSpecArgsToInputSchema"
          ],
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "executeAskAI",
              "calls": [
                "i.logger.Debug(?)",
                "step.Pos.String(?)",
                "NewRuntimeError",
                "step.Pos.String(?)",
                "i.prepareConversationForAsk(?)",
                "step.Pos.String(?)",
                "NewRuntimeError",
                "NewRuntimeError",
                "i.getAvailableToolsForAsk(?)",
                "step.Pos.String(?)",
                "NewRuntimeError",
                "i.logger.Debug(?)",
                "i.llmClient.AskWithTools(?)",
                "i.logger.Debug(?)",
                "i.llmClient.Ask(?)",
                "step.Pos.String(?)",
                "NewRuntimeError",
                "step.Pos.String(?)",
                "NewRuntimeError",
                "i.logger.Debug(?)",
                "i.addResponseToConversation(?)",
                "i.handleToolCalls(?)",
                "step.Pos.String(?)",
                "i.logger.Info(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "prepareConversationForAsk",
              "calls": [
                "i.evaluateExpression(?)",
                "promptExpr.GetPos().String(?)",
                "promptExpr.GetPos(?)",
                "NewRuntimeError",
                "promptExpr.GetPos().String(?)",
                "promptExpr.GetPos(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "getAvailableToolsForAsk",
              "calls": [
                "i.logger.Warn(?)",
                "step.Pos.String(?)",
                "i.toolRegistry.GetAllTools(?)",
                "ConvertToolSpecArgsToInputSchema",
                "i.logger.Warn(?)",
                "step.Pos.String(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "addResponseToConversation",
              "calls": [
                "i.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "handleToolCalls",
              "calls": [
                "i.logger.Info(?)",
                "pos.String(?)",
                "pos.String(?)",
                "NewRuntimeError",
                "i.logger.Debug(?)",
                "pos.String(?)",
                "i.toolRegistry.GetTool(?)",
                "i.toolRegistry.GetTool(?)",
                "i.logger.Error(?)",
                "pos.String(?)",
                "i.logger.Error(?)",
                "pos.String(?)",
                "ValidateAndConvertArgs",
                "i.logger.Error(?)",
                "pos.String(?)",
                "toolImpl.Func(?)",
                "i.logger.Error(?)",
                "pos.String(?)",
                "i.logger.Debug(?)",
                "i.addToolResultsToConversation(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "addToolResultsToConversation",
              "calls": [
                "i.logger.Debug(?)"
              ]
            }
          ]
        },
        "pkg/core/interpreter_steps_blocks.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "executeIf",
              "calls": [
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "step.Pos.String(?)",
                "NewRuntimeError",
                "isTruthy",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.executeBlock(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.executeBlock(?)",
                "step.Pos.String(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeWhile",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NewRuntimeError",
                "isTruthy",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.executeBlock(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeFor",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NewRuntimeError",
                "reflect.ValueOf",
                "NewRuntimeError",
                "i.SetVariable(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.executeBlock(?)",
                "val.Kind(?)",
                "val.Len(?)",
                "val.Index(idx).Interface(?)",
                "val.Index(?)",
                "executeLoopBody",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "val.MapRange(?)",
                "mapRange.Next(?)",
                "mapRange.Value().Interface(?)",
                "mapRange.Value(?)",
                "executeLoopBody",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "val.String(?)",
                "string",
                "executeLoopBody",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            }
          ]
        },
        "pkg/core/interpreter_steps_simple.go": {
          "methods": [
            {
              "Receiver": "*Interpreter",
              "Name": "executeSet",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NewRuntimeError",
                "NewRuntimeError",
                "i.SetVariable(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeReturn",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "exprNode.GetPos(?)",
                "nodePos.String(?)",
                "NewRuntimeError",
                "i.Logger().Error(?)",
                "i.Logger(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeEmit",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeMust",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NewRuntimeError",
                "isTruthy",
                "NodeToString",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeFail",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "ErrorCode",
                "ErrorCode",
                "int",
                "ErrorCode",
                "int",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeOnError",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeClearError",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)",
                "NewRuntimeError"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeAsk",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Info(?)",
                "i.Logger(?)",
                "i.evaluateExpression(?)",
                "NewRuntimeError",
                "NewRuntimeError",
                "i.Logger().Warn(?)",
                "i.Logger(?)",
                "i.SetVariable(?)",
                "NewRuntimeError",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeBreak",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            },
            {
              "Receiver": "*Interpreter",
              "Name": "executeContinue",
              "calls": [
                "step.Pos.String(?)",
                "i.Logger().Debug(?)",
                "i.Logger(?)"
              ]
            }
          ]
        },
        "pkg/core/interpreter_test.go": {
          "functions": [
            "TestExecuteStepsBlocksAndLoops"
          ],
          "methods": []
        },
        "pkg/core/llm.go": {
          "functions": [
            "NewLLMClient",
            "NewNoOpLLMClient"
          ],
          "methods": [
            {
              "Receiver": "*concreteLLMClient",
              "Name": "Ask",
              "calls": [
                "c.logger.Debug(?)",
                "c.logger.Warn(?)",
                "c.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*concreteLLMClient",
              "Name": "AskWithTools",
              "calls": [
                "c.logger.Debug(?)",
                "c.logger.Warn(?)",
                "c.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*concreteLLMClient",
              "Name": "Embed",
              "calls": [
                "c.logger.Debug(?)",
                "c.logger.Warn(?)",
                "c.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*concreteLLMClient",
              "Name": "Client"
            },
            {
              "Receiver": "*coreNoOpLLMClient",
              "Name": "Ask",
              "calls": [
                "c.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*coreNoOpLLMClient",
              "Name": "AskWithTools",
              "calls": [
                "c.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*coreNoOpLLMClient",
              "Name": "Embed",
              "calls": [
                "c.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*coreNoOpLLMClient",
              "Name": "Client"
            }
          ]
        },
        "pkg/core/llm_tools.go": {
          "functions": [
            "callLLM",
            "callLLMWithParts",
            "toolLLMAsk",
            "toolLLMAskWithParts",
            "RegisterLLMTools"
          ],
          "methods": []
        },
        "pkg/core/llm_types.go": {
          "methods": [
            {
              "Receiver": "*ConversationTurn",
              "Name": "String"
            }
          ]
        },
        "pkg/core/parser_api.go": {
          "functions": [
            "NewParserAPI",
            "NewErrorListener"
          ],
          "methods": [
            {
              "Receiver": "*ErrorListener",
              "Name": "SyntaxError",
              "calls": [
                "token.GetLine(?)",
                "token.GetColumn(?)",
                "token.GetText(?)",
                "l.logger.Error(?)"
              ]
            },
            {
              "Receiver": "*ParserAPI",
              "Name": "Parse",
              "calls": [
                "p.logger.Debug(?)",
                "antlr.NewInputStream(?)",
                "pkg/core/generated.NewNeuroScriptLexer",
                "lexer.RemoveErrorListeners(?)",
                "NewErrorListener",
                "lexer.AddErrorListener(?)",
                "antlr.NewCommonTokenStream(?)",
                "pkg/core/generated.NewNeuroScriptParser",
                "parser.RemoveErrorListeners(?)",
                "NewErrorListener",
                "parser.AddErrorListener(?)",
                "parser.SetErrorHandler(?)",
                "antlr.NewDefaultErrorStrategy(?)",
                "p.logger.Debug(?)",
                "parser.Program(?)",
                "p.logger.Debug(?)",
                "p.logger.Error(?)",
                "p.logger.Error(?)",
                "p.logger.Debug(?)"
              ]
            }
          ]
        },
        "pkg/core/parser_minimal_test.go": {
          "functions": [
            "TestParseMinimalNewline"
          ],
          "methods": []
        },
        "pkg/core/parser_test.go": {
          "functions": [
            "TestNeuroScriptParser"
          ],
          "methods": []
        },
        "pkg/core/security.go": {
          "functions": [
            "NewSecurityLayer",
            "SanitizeFilename",
            "SecureFilePath"
          ],
          "methods": [
            {
              "Receiver": "*SecurityLayer",
              "Name": "SandboxRoot"
            },
            {
              "Receiver": "*SecurityLayer",
              "Name": "GetToolDeclarations",
              "calls": [
                "sl.logger.Error(?)",
                "sl.toolRegistry.GetAllTools(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)",
                "argSpec.Type.ToGenaiType(?)",
                "sl.logger.Error(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*SecurityLayer",
              "Name": "ExecuteToolCall",
              "calls": [
                "sl.logger.Error(?)",
                "CreateErrorFunctionResultPart",
                "sl.ValidateToolCall(?)",
                "sl.logger.Debug(?)",
                "CreateErrorFunctionResultPart",
                "sl.toolRegistry.GetTool(?)",
                "sl.logger.Error(?)",
                "CreateErrorFunctionResultPart",
                "sl.logger.Error(?)",
                "CreateErrorFunctionResultPart",
                "sl.logger.Debug(?)",
                "toolImpl.Func(?)",
                "sl.logger.Error(?)",
                "CreateErrorFunctionResultPart",
                "sl.logger.Debug(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Debug(?)"
              ]
            },
            {
              "Receiver": "*SecurityLayer",
              "Name": "ValidateToolCall",
              "calls": [
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Error(?)",
                "sl.toolRegistry.GetTool(?)",
                "sl.logger.Error(?)",
                "sl.logger.Warn(?)",
                "sl.validateArgumentsAgainstSpec(?)",
                "sl.logger.Warn(?)",
                "sl.logger.Warn(?)"
              ]
            }
          ]
        },
        "pkg/core/security_helpers.go": {
          "functions": [
            "GetSandboxPath",
            "IsPathInSandbox",
            "ResolveAndSecurePath"
          ],
          "methods": []
        },
        "pkg/core/security_validation.go": {
          "methods": [
            {
              "Receiver": "*SecurityLayer",
              "Name": "validateArgumentsAgainstSpec",
              "calls": [
                "sl.logger.Debug(?)",
                "sl.logger.Debug(?)",
                "sl.logger.Debug(?)",
                "sl.logger.Debug(?)",
                "sl.validateAndCoerceType(?)",
                "sl.logger.Debug(?)",
                "ToNumeric",
                "sl.logger.Debug(?)",
                "SecureFilePath",
                "sl.logger.Debug(?)",
                "sl.logger.Debug(?)",
                "sl.logger.Debug(?)",
                "sl.logger.Warn(?)"
              ]
            },
            {
              "Receiver": "*SecurityLayer",
              "Name": "validateAndCoerceType",
              "calls": [
                "toInt64",
                "toFloat64",
                "ConvertToBool",
                "ConvertToSliceOfString",
                "convertToSliceOfAny"
              ]
            }
          ]
        },
        "pkg/core/sync_helpers.go": {
          "functions": [
            "checkGenAIClient",
            "HelperUploadAndPollFile",
            "calculateFileHash"
          ],
          "methods": []
        },
        "pkg/core/sync_logic.go": {
          "functions": [
            "gatherLocalFiles",
            "computeSyncActions",
            "toolSyncFiles"
          ],
          "methods": []
        },
        "pkg/core/sync_morehelpers.go": {
          "functions": [
            "initializeSyncState",
            "listExistingAPIFiles",
            "initializeGitignore"
          ],
          "methods": []
        },
        "pkg/core/sync_types.go": {
          "methods": []
        },
        "pkg/core/sync_workers.go": {
          "functions": [
            "startUploadWorkers",
            "processUploadJob",
            "startDeleteWorkers"
          ],
          "methods": []
        },
        "pkg/core/testing_helpers.go": {
          "functions": [
            "AssertNoError",
            "deepEqualWithTolerance",
            "runEvalExpressionTest",
            "runExecuteStepsTest",
            "createTestStep",
            "createIfStep",
            "createWhileStep",
            "createForStep"
          ],
          "methods": []
        },
        "pkg/core/testing_helpers_test.go": {
          "methods": []
        },
        "pkg/core/tools_file_api.go": {
          "functions": [
            "toolListAPIFiles",
            "toolDeleteAPIFile",
            "toolUploadFile",
            "registerFileAPITools"
          ],
          "methods": []
        },
        "pkg/core/tools_file_api_sync.go": {
          "functions": [
            "SyncDirectoryUpHelper",
            "waitForUploadResultsAndPrintProgress"
          ],
          "methods": []
        },
        "pkg/core/tools_file_api_test.go": {
          "functions": [
            "TestToolListAPIFilesValidation",
            "TestToolDeleteAPIFileValidation",
            "TestToolUploadFileValidation",
            "TestToolSyncFilesValidation"
          ],
          "methods": []
        },
        "pkg/core/tools_file_helpers.go": {
          "functions": [
            "readFileContent",
            "writeFileContent",
            "embedFileContent",
            "findFiles",
            "scanFileLines"
          ],
          "methods": []
        },
        "pkg/core/tools_fs.go": {
          "functions": [
            "registerFsTools",
            "registerFsFileTools"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_delete.go": {
          "functions": [
            "toolDeleteFile",
            "registerFsDeleteTools"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_delete_test.go": {
          "functions": [
            "TestToolDeleteFile"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_dirs.go": {
          "functions": [
            "registerFsDirTools",
            "toolListDirectory",
            "toolMkdir"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_dirs_test.go": {
          "functions": [
            "TestToolListDirectoryValidation",
            "TestToolListDirectoryFunctional",
            "TestToolMkdirValidation",
            "TestToolMkdirFunctional"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_hash.go": {
          "functions": [
            "toolFileHash",
            "registerFsHashTools"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_helpers_test.go": {
          "functions": [
            "testFsToolHelper"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_move.go": {
          "functions": [
            "toolMoveFile",
            "registerFsMoveTools"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_move_test.go": {
          "functions": [
            "TestToolMoveFileValidation",
            "TestToolMoveFileFunctional",
            "NewTestInterpreterWithSandbox"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_read.go": {
          "functions": [
            "toolReadFile"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_read_test.go": {
          "functions": [
            "TestToolReadFile"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_stat.go": {
          "functions": [
            "toolStat"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_stat_test.go": {
          "functions": [
            "createTestInterpreterWithSandbox",
            "createTempFile",
            "createTempDir",
            "TestToolStat"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_utils.go": {
          "functions": [
            "toolLineCountFile",
            "toolSanitizeFilename",
            "registerFsUtilTools"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_walk.go": {
          "functions": [
            "toolWalkDir"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_walk_test.go": {
          "functions": [
            "createWalkTestInterpreter",
            "createWalkTempFile",
            "createWalkTempDir",
            "assertWalkResultsEqual",
            "TestToolWalkDir"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_write.go": {
          "functions": [
            "toolWriteFile"
          ],
          "methods": []
        },
        "pkg/core/tools_fs_write_test.go": {
          "functions": [
            "TestToolWriteFile"
          ],
          "methods": []
        },
        "pkg/core/tools_git.go": {
          "functions": [
            "toolGitAdd",
            "toolGitCommit",
            "toolGitNewBranch",
            "toolGitCheckout",
            "toolGitRm",
            "toolGitMerge",
            "toolGitPull",
            "toolGitPush",
            "toolGitDiff"
          ],
          "methods": []
        },
        "pkg/core/tools_git_register.go": {
          "functions": [
            "registerGitTools"
          ],
          "methods": []
        },
        "pkg/core/tools_git_status.go": {
          "functions": [
            "toolGitStatus",
            "parseGitStatusOutput"
          ],
          "methods": []
        },
        "pkg/core/tools_git_status_test.go": {
          "functions": [
            "TestParseGitStatusOutput",
            "compareFileMaps"
          ],
          "methods": []
        },
        "pkg/core/tools_git_test.go": {
          "functions": [
            "runValidationTestCases",
            "TestToolGitNewBranchValidation",
            "TestToolGitCheckoutValidation",
            "TestToolGitRmValidation",
            "TestToolGitMergeValidation",
            "TestToolGitPullValidation",
            "TestToolGitPushValidation",
            "TestToolGitDiffValidation"
          ],
          "methods": []
        },
        "pkg/core/tools_go.go": {
          "functions": [
            "registerGoTools"
          ],
          "methods": []
        },
        "pkg/core/tools_go_execution.go": {
          "functions": [
            "toolGoBuild",
            "toolGoCheck",
            "toolGoTest",
            "toolGoModTidy",
            "toolGoListPackages",
            "executeGoCommandHelper"
          ],
          "methods": []
        },
        "pkg/core/tools_go_fmt.go": {
          "functions": [
            "toolGoFmt",
            "toolGoImports"
          ],
          "methods": []
        },
        "pkg/core/tools_go_mod.go": {
          "functions": [
            "FindAndParseGoMod",
            "toolGoGetModuleInfo"
          ],
          "methods": []
        },
        "pkg/core/tools_go_test.go": {
          "functions": [
            "TestToolGoGetModuleInfo"
          ],
          "methods": []
        },
        "pkg/core/tools_gofmt_test.go": {
          "functions": [
            "testGoFormatToolHelper",
            "TestToolGoFmt",
            "TestToolGoImports"
          ],
          "methods": []
        },
        "pkg/core/tools_helpers.go": {
          "functions": [
            "MakeArgs",
            "runGitCommand",
            "toolExec",
            "getStringArg",
            "makeArgMap"
          ],
          "methods": []
        },
        "pkg/core/tools_io.go": {
          "functions": [
            "toolIOInput",
            "toolLog",
            "registerLogTools",
            "registerIOTools"
          ],
          "methods": []
        },
        "pkg/core/tools_io_test.go": {
          "functions": [
            "TestToolIOInputValidation"
          ],
          "methods": []
        },
        "pkg/core/tools_list_impl.go": {
          "functions": [
            "toolListLength",
            "toolListAppend",
            "toolListPrepend",
            "toolListGet",
            "toolListSlice",
            "toolListContains",
            "toolListReverse",
            "toolListSort",
            "toolListHead",
            "toolListRest",
            "toolListTail",
            "toolListIsEmpty"
          ],
          "methods": []
        },
        "pkg/core/tools_list_register.go": {
          "functions": [
            "registerListTools"
          ],
          "methods": []
        },
        "pkg/core/tools_list_test.go": {
          "functions": [
            "testListToolHelper",
            "TestToolListLength",
            "TestToolListAppendPrepend",
            "TestToolListGet",
            "TestToolListSlice",
            "TestToolListContains",
            "TestToolListReverse",
            "TestToolListSort",
            "TestToolListIsEmpty",
            "TestToolListHead",
            "TestToolListRest",
            "TestToolListTail"
          ],
          "methods": []
        },
        "pkg/core/tools_math.go": {
          "functions": [
            "registerMathTools",
            "toolAdd",
            "toolSubtract",
            "toolMultiply",
            "toolDivide",
            "toolModulo"
          ],
          "methods": []
        },
        "pkg/core/tools_math_test.go": {
          "functions": [
            "testMathToolHelper",
            "TestToolAdd",
            "TestToolSubtract",
            "TestToolDivide"
          ],
          "methods": []
        },
        "pkg/core/tools_metadata.go": {
          "functions": [
            "registerMetadataTools",
            "toolExtractMetadataFromString"
          ],
          "methods": []
        },
        "pkg/core/tools_register.go": {
          "functions": [
            "registerCoreToolsInternal",
            "RegisterCoreTools"
          ],
          "methods": []
        },
        "pkg/core/tools_registry.go": {
          "functions": [
            "NewToolRegistry"
          ],
          "methods": [
            {
              "Receiver": "*ToolRegistry",
              "Name": "RegisterTool"
            },
            {
              "Receiver": "*ToolRegistry",
              "Name": "GetTool"
            },
            {
              "Receiver": "*ToolRegistry",
              "Name": "GetAllTools"
            }
          ]
        },
        "pkg/core/tools_shell.go": {
          "functions": [
            "registerShellTools",
            "toolExecuteCommand"
          ],
          "methods": []
        },
        "pkg/core/tools_shell_test.go": {
          "functions": [
            "TestToolExecuteCommand"
          ],
          "methods": []
        },
        "pkg/core/tools_string.go": {
          "functions": [
            "registerStringTools",
            "toolStringLength",
            "toolSubstring",
            "toolToUpper",
            "toolToLower",
            "toolTrimSpace",
            "toolSplitString",
            "toolSplitWords",
            "toolJoinStrings",
            "toolReplaceAll",
            "toolContains",
            "toolHasPrefix",
            "toolHasSuffix",
            "toolLineCountString"
          ],
          "methods": []
        },
        "pkg/core/tools_string_basic_test.go": {
          "functions": [
            "testStringToolHelper",
            "TestToolStringLength",
            "TestToolSubstring",
            "TestToolToUpperLower",
            "TestToolTrimSpace",
            "TestToolReplaceAll"
          ],
          "methods": []
        },
        "pkg/core/tools_string_predicates_test.go": {
          "functions": [
            "TestToolContainsPrefixSuffix"
          ],
          "methods": []
        },
        "pkg/core/tools_string_split_join_test.go": {
          "functions": [
            "testStringSplitJoinToolHelper",
            "TestToolSplitString",
            "TestToolSplitWords",
            "TestToolJoinStrings"
          ],
          "methods": []
        },
        "pkg/core/tools_string_utils_test.go": {
          "functions": [
            "TestToolLineCountString"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_find.go": {
          "functions": [
            "toolTreeFindNodes"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_load.go": {
          "functions": [
            "toolTreeLoadJSON"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_modify.go": {
          "functions": [
            "toolTreeModifyNode",
            "toolTreeSetAttribute",
            "toolTreeRemoveAttribute",
            "toolTreeAddNode",
            "toolTreeRemoveNode"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_modify_test.go": {
          "functions": [
            "setupTreeTestStd",
            "Pint",
            "getNodeValueStd",
            "getNodeAttributesStd",
            "getNodeChildrenStd",
            "TestTreeModifyNodeStd",
            "TestTreeSetAttributeStd",
            "TestTreeRemoveAttributeStd",
            "TestTreeAddNodeStd",
            "TestTreeRemoveNodeStd"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_nav.go": {
          "functions": [
            "toolTreeGetNode",
            "toolTreeGetChildren",
            "toolTreeGetParent"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_register.go": {
          "functions": [
            "registerTreeTools"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_render.go": {
          "functions": [
            "toolTreeFormatJSON",
            "toolTreeRenderText",
            "registerTreeRenderTools"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_render_test.go": {
          "functions": [
            "TestTreeFormatJSON",
            "TestTreeRenderText"
          ],
          "methods": []
        },
        "pkg/core/tools_tree_test.go": {
          "functions": [
            "loadJSONHelper",
            "getNodeHelper",
            "getNodeAttributes",
            "getNodeChildren",
            "getAttrNodeID",
            "getChildNodeID",
            "TestTreeLoadJSON",
            "TestTreeNavigation"
          ],
          "methods": []
        },
        "pkg/core/tools_types.go": {
          "methods": [
            {
              "Receiver": "ArgType",
              "Name": "ToGenaiType"
            }
          ]
        },
        "pkg/core/tools_validation.go": {
          "functions": [
            "ValidateAndConvertArgs",
            "validateAndCoerceType"
          ],
          "methods": []
        },
        "pkg/core/tools_vector.go": {
          "functions": [
            "registerVectorTools",
            "toolSearchSkills",
            "toolVectorUpdate"
          ],
          "methods": []
        },
        "pkg/core/tree_helpers.go": {
          "functions": [
            "getTreeFromHandle",
            "getNodeFromHandle",
            "removeChildFromParent",
            "removeNodeRecursive"
          ],
          "methods": []
        },
        "pkg/core/tree_types.go": {
          "functions": [
            "NewGenericTree"
          ],
          "methods": [
            {
              "Receiver": "*GenericTree",
              "Name": "NewNode"
            }
          ]
        },
        "pkg/core/universal_test_helpers.go": {
          "functions": [
            "LogTest",
            "NormalizeString",
            "DiffStrings",
            "AssertEqualStrings",
            "writeFileHelper",
            "max"
          ],
          "methods": [
            {
              "Receiver": "testWriter",
              "Name": "Write",
              "calls": [
                "string",
                "tw.t.Logf(?)"
              ]
            }
          ]
        },
        "pkg/core/universal_test_helpers_test.go": {
          "functions": [
            "TestNormalizeString",
            "newMockTB",
            "TestDiffStrings"
          ],
          "methods": [
            {
              "Receiver": "*mockTB",
              "Name": "Logf"
            },
            {
              "Receiver": "*mockTB",
              "Name": "Errorf"
            },
            {
              "Receiver": "*mockTB",
              "Name": "FailNow"
            },
            {
              "Receiver": "*mockTB",
              "Name": "Fail"
            },
            {
              "Receiver": "*mockTB",
              "Name": "Failed"
            },
            {
              "Receiver": "*mockTB",
              "Name": "Helper"
            }
          ]
        },
        "pkg/core/utils.go": {
          "functions": [
            "ConvertToIntE",
            "IsTruthy",
            "InterfaceToString",
            "normalizeNewlines",
            "NodeToString"
          ],
          "methods": [
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Debug"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Info"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Warn"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Error"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Debugf"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Infof"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Warnf"
            },
            {
              "Receiver": "*coreNoOpLogger",
              "Name": "Errorf"
            }
          ]
        }
      }
    },
    "pkg/core/generated": {
      "files": {
        "pkg/core/generated/neuroscript_base_listener.go": {
          "methods": [
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "VisitTerminal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "VisitErrorNode"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterEveryRule"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitEveryRule"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterProgram"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitProgram"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterFile_header"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitFile_header"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterProcedure_definition"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitProcedure_definition"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterSignature_part"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitSignature_part"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterNeeds_clause"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitNeeds_clause"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterOptional_clause"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitOptional_clause"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterReturns_clause"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitReturns_clause"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterParam_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitParam_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMetadata_block"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMetadata_block"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterStatement_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitStatement_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBody_line"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBody_line"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterStatement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitStatement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterSimple_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitSimple_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBlock_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBlock_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterExpressionStatement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitExpressionStatement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterSet_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitSet_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterCall_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitCall_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterReturn_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitReturn_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterEmit_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitEmit_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMust_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMust_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterFail_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitFail_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterClearErrorStmt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitClearErrorStmt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterAsk_stmt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitAsk_stmt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBreak_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBreak_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterContinue_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitContinue_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterIf_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitIf_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterWhile_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitWhile_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterFor_each_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitFor_each_statement"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterOnErrorStmt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitOnErrorStmt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterCall_target"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitCall_target"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterExpression"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitExpression"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterLogical_or_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitLogical_or_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterLogical_and_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitLogical_and_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBitwise_or_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBitwise_or_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBitwise_xor_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBitwise_xor_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBitwise_and_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBitwise_and_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterEquality_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitEquality_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterRelational_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitRelational_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterAdditive_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitAdditive_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMultiplicative_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMultiplicative_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterUnary_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitUnary_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterPower_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitPower_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterAccessor_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitAccessor_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterPrimary"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitPrimary"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterCallable_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitCallable_expr"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterPlaceholder"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitPlaceholder"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterLiteral"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitLiteral"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterBoolean_literal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitBoolean_literal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterList_literal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitList_literal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMap_literal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMap_literal"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterExpression_list_opt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitExpression_list_opt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterExpression_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitExpression_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMap_entry_list_opt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMap_entry_list_opt"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMap_entry_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMap_entry_list"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "EnterMap_entry"
            },
            {
              "Receiver": "*BaseNeuroScriptListener",
              "Name": "ExitMap_entry"
            }
          ]
        },
        "pkg/core/generated/neuroscript_base_visitor.go": {
          "methods": [
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitProgram",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitFile_header",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitProcedure_definition",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitSignature_part",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitNeeds_clause",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitOptional_clause",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitReturns_clause",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitParam_list",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMetadata_block",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitStatement_list",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBody_line",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitStatement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitSimple_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBlock_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitExpressionStatement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitSet_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitCall_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitReturn_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitEmit_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMust_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitFail_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitClearErrorStmt",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitAsk_stmt",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBreak_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitContinue_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitIf_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitWhile_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitFor_each_statement",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitOnErrorStmt",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitCall_target",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitExpression",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitLogical_or_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitLogical_and_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBitwise_or_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBitwise_xor_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBitwise_and_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitEquality_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitRelational_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitAdditive_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMultiplicative_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitUnary_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitPower_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitAccessor_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitPrimary",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitCallable_expr",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitPlaceholder",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitLiteral",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitBoolean_literal",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitList_literal",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMap_literal",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitExpression_list_opt",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitExpression_list",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMap_entry_list_opt",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMap_entry_list",
              "calls": [
                "v.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*BaseNeuroScriptVisitor",
              "Name": "VisitMap_entry",
              "calls": [
                "v.VisitChildren(?)"
              ]
            }
          ]
        },
        "pkg/core/generated/neuroscript_lexer.go": {
          "functions": [
            "neuroscriptlexerLexerInit",
            "NeuroScriptLexerInit",
            "NewNeuroScriptLexer"
          ],
          "methods": []
        },
        "pkg/core/generated/neuroscript_listener.go": {
          "methods": []
        },
        "pkg/core/generated/neuroscript_parser.go": {
          "functions": [
            "neuroscriptParserInit",
            "NeuroScriptParserInit",
            "NewNeuroScriptParser",
            "NewEmptyProgramContext",
            "InitEmptyProgramContext",
            "NewProgramContext",
            "NewEmptyFile_headerContext",
            "InitEmptyFile_headerContext",
            "NewFile_headerContext",
            "NewEmptyProcedure_definitionContext",
            "InitEmptyProcedure_definitionContext",
            "NewProcedure_definitionContext",
            "NewEmptySignature_partContext",
            "InitEmptySignature_partContext",
            "NewSignature_partContext",
            "NewEmptyNeeds_clauseContext",
            "InitEmptyNeeds_clauseContext",
            "NewNeeds_clauseContext",
            "NewEmptyOptional_clauseContext",
            "InitEmptyOptional_clauseContext",
            "NewOptional_clauseContext",
            "NewEmptyReturns_clauseContext",
            "InitEmptyReturns_clauseContext",
            "NewReturns_clauseContext",
            "NewEmptyParam_listContext",
            "InitEmptyParam_listContext",
            "NewParam_listContext",
            "NewEmptyMetadata_blockContext",
            "InitEmptyMetadata_blockContext",
            "NewMetadata_blockContext",
            "NewEmptyStatement_listContext",
            "InitEmptyStatement_listContext",
            "NewStatement_listContext",
            "NewEmptyBody_lineContext",
            "InitEmptyBody_lineContext",
            "NewBody_lineContext",
            "NewEmptyStatementContext",
            "InitEmptyStatementContext",
            "NewStatementContext",
            "NewEmptySimple_statementContext",
            "InitEmptySimple_statementContext",
            "NewSimple_statementContext",
            "NewEmptyBlock_statementContext",
            "InitEmptyBlock_statementContext",
            "NewBlock_statementContext",
            "NewEmptyExpressionStatementContext",
            "InitEmptyExpressionStatementContext",
            "NewExpressionStatementContext",
            "NewEmptySet_statementContext",
            "InitEmptySet_statementContext",
            "NewSet_statementContext",
            "NewEmptyCall_statementContext",
            "InitEmptyCall_statementContext",
            "NewCall_statementContext",
            "NewEmptyReturn_statementContext",
            "InitEmptyReturn_statementContext",
            "NewReturn_statementContext",
            "NewEmptyEmit_statementContext",
            "InitEmptyEmit_statementContext",
            "NewEmit_statementContext",
            "NewEmptyMust_statementContext",
            "InitEmptyMust_statementContext",
            "NewMust_statementContext",
            "NewEmptyFail_statementContext",
            "InitEmptyFail_statementContext",
            "NewFail_statementContext",
            "NewEmptyClearErrorStmtContext",
            "InitEmptyClearErrorStmtContext",
            "NewClearErrorStmtContext",
            "NewEmptyAsk_stmtContext",
            "InitEmptyAsk_stmtContext",
            "NewAsk_stmtContext",
            "NewEmptyBreak_statementContext",
            "InitEmptyBreak_statementContext",
            "NewBreak_statementContext",
            "NewEmptyContinue_statementContext",
            "InitEmptyContinue_statementContext",
            "NewContinue_statementContext",
            "NewEmptyIf_statementContext",
            "InitEmptyIf_statementContext",
            "NewIf_statementContext",
            "NewEmptyWhile_statementContext",
            "InitEmptyWhile_statementContext",
            "NewWhile_statementContext",
            "NewEmptyFor_each_statementContext",
            "InitEmptyFor_each_statementContext",
            "NewFor_each_statementContext",
            "NewEmptyOnErrorStmtContext",
            "InitEmptyOnErrorStmtContext",
            "NewOnErrorStmtContext",
            "NewEmptyCall_targetContext",
            "InitEmptyCall_targetContext",
            "NewCall_targetContext",
            "NewEmptyExpressionContext",
            "InitEmptyExpressionContext",
            "NewExpressionContext",
            "NewEmptyLogical_or_exprContext",
            "InitEmptyLogical_or_exprContext",
            "NewLogical_or_exprContext",
            "NewEmptyLogical_and_exprContext",
            "InitEmptyLogical_and_exprContext",
            "NewLogical_and_exprContext",
            "NewEmptyBitwise_or_exprContext",
            "InitEmptyBitwise_or_exprContext",
            "NewBitwise_or_exprContext",
            "NewEmptyBitwise_xor_exprContext",
            "InitEmptyBitwise_xor_exprContext",
            "NewBitwise_xor_exprContext",
            "NewEmptyBitwise_and_exprContext",
            "InitEmptyBitwise_and_exprContext",
            "NewBitwise_and_exprContext",
            "NewEmptyEquality_exprContext",
            "InitEmptyEquality_exprContext",
            "NewEquality_exprContext",
            "NewEmptyRelational_exprContext",
            "InitEmptyRelational_exprContext",
            "NewRelational_exprContext",
            "NewEmptyAdditive_exprContext",
            "InitEmptyAdditive_exprContext",
            "NewAdditive_exprContext",
            "NewEmptyMultiplicative_exprContext",
            "InitEmptyMultiplicative_exprContext",
            "NewMultiplicative_exprContext",
            "NewEmptyUnary_exprContext",
            "InitEmptyUnary_exprContext",
            "NewUnary_exprContext",
            "NewEmptyPower_exprContext",
            "InitEmptyPower_exprContext",
            "NewPower_exprContext",
            "NewEmptyAccessor_exprContext",
            "InitEmptyAccessor_exprContext",
            "NewAccessor_exprContext",
            "NewEmptyPrimaryContext",
            "InitEmptyPrimaryContext",
            "NewPrimaryContext",
            "NewEmptyCallable_exprContext",
            "InitEmptyCallable_exprContext",
            "NewCallable_exprContext",
            "NewEmptyPlaceholderContext",
            "InitEmptyPlaceholderContext",
            "NewPlaceholderContext",
            "NewEmptyLiteralContext",
            "InitEmptyLiteralContext",
            "NewLiteralContext",
            "NewEmptyBoolean_literalContext",
            "InitEmptyBoolean_literalContext",
            "NewBoolean_literalContext",
            "NewEmptyList_literalContext",
            "InitEmptyList_literalContext",
            "NewList_literalContext",
            "NewEmptyMap_literalContext",
            "InitEmptyMap_literalContext",
            "NewMap_literalContext",
            "NewEmptyExpression_list_optContext",
            "InitEmptyExpression_list_optContext",
            "NewExpression_list_optContext",
            "NewEmptyExpression_listContext",
            "InitEmptyExpression_listContext",
            "NewExpression_listContext",
            "NewEmptyMap_entry_list_optContext",
            "InitEmptyMap_entry_list_optContext",
            "NewMap_entry_list_optContext",
            "NewEmptyMap_entry_listContext",
            "InitEmptyMap_entry_listContext",
            "NewMap_entry_listContext",
            "NewEmptyMap_entryContext",
            "InitEmptyMap_entryContext",
            "NewMap_entryContext"
          ],
          "methods": [
            {
              "Receiver": "*ProgramContext",
              "Name": "IsProgramContext"
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "File_header",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "EOF",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "AllProcedure_definition",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "Procedure_definition",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "AllNEWLINE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterProgram(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitProgram(?)"
              ]
            },
            {
              "Receiver": "*ProgramContext",
              "Name": "Accept",
              "calls": [
                "t.VisitProgram(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Program",
              "calls": [
                "NewProgramContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.File_header(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Procedure_definition(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "IsFile_headerContext"
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "AllMETADATA_LINE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "METADATA_LINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "AllNEWLINE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterFile_header(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitFile_header(?)"
              ]
            },
            {
              "Receiver": "*File_headerContext",
              "Name": "Accept",
              "calls": [
                "t.VisitFile_header(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "File_header",
              "calls": [
                "NewFile_headerContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "IsProcedure_definitionContext"
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "KW_FUNC",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "Signature_part",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "KW_MEANS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "Statement_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "KW_ENDFUNC",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "Metadata_block",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterProcedure_definition(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitProcedure_definition(?)"
              ]
            },
            {
              "Receiver": "*Procedure_definitionContext",
              "Name": "Accept",
              "calls": [
                "t.VisitProcedure_definition(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Procedure_definition",
              "calls": [
                "NewProcedure_definitionContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Signature_part(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.GetInterpreter().AdaptivePredict(?)",
                "p.GetInterpreter(?)",
                "p.GetTokenStream(?)",
                "p.GetParserRuleContext(?)",
                "p.SetState(?)",
                "p.Metadata_block(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Statement_list(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "IsSignature_partContext"
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "LPAREN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "RPAREN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "Needs_clause",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "Optional_clause",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "Returns_clause",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterSignature_part(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitSignature_part(?)"
              ]
            },
            {
              "Receiver": "*Signature_partContext",
              "Name": "Accept",
              "calls": [
                "t.VisitSignature_part(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Signature_part",
              "calls": [
                "NewSignature_partContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Needs_clause(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Optional_clause(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Returns_clause(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Needs_clause(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Optional_clause(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Returns_clause(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Optional_clause(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Returns_clause(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Returns_clause(?)",
                "p.EnterOuterAlt(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "IsNeeds_clauseContext"
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "KW_NEEDS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "Param_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterNeeds_clause(?)"
              ]
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitNeeds_clause(?)"
              ]
            },
            {
              "Receiver": "*Needs_clauseContext",
              "Name": "Accept",
              "calls": [
                "t.VisitNeeds_clause(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Needs_clause",
              "calls": [
                "NewNeeds_clauseContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Param_list(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "IsOptional_clauseContext"
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "KW_OPTIONAL",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "Param_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterOptional_clause(?)"
              ]
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitOptional_clause(?)"
              ]
            },
            {
              "Receiver": "*Optional_clauseContext",
              "Name": "Accept",
              "calls": [
                "t.VisitOptional_clause(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Optional_clause",
              "calls": [
                "NewOptional_clauseContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Param_list(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "IsReturns_clauseContext"
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "KW_RETURNS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "Param_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterReturns_clause(?)"
              ]
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitReturns_clause(?)"
              ]
            },
            {
              "Receiver": "*Returns_clauseContext",
              "Name": "Accept",
              "calls": [
                "t.VisitReturns_clause(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Returns_clause",
              "calls": [
                "NewReturns_clauseContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Param_list(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "IsParam_listContext"
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "AllIDENTIFIER",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "AllCOMMA",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "COMMA",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterParam_list(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitParam_list(?)"
              ]
            },
            {
              "Receiver": "*Param_listContext",
              "Name": "Accept",
              "calls": [
                "t.VisitParam_list(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Param_list",
              "calls": [
                "NewParam_listContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "IsMetadata_blockContext"
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "AllMETADATA_LINE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "METADATA_LINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "AllNEWLINE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMetadata_block(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMetadata_block(?)"
              ]
            },
            {
              "Receiver": "*Metadata_blockContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMetadata_block(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Metadata_block",
              "calls": [
                "NewMetadata_blockContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "IsStatement_listContext"
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "AllBody_line",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "Body_line",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterStatement_list(?)"
              ]
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitStatement_list(?)"
              ]
            },
            {
              "Receiver": "*Statement_listContext",
              "Name": "Accept",
              "calls": [
                "t.VisitStatement_list(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Statement_list",
              "calls": [
                "NewStatement_listContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.SetState(?)",
                "p.Body_line(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "IsBody_lineContext"
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "Statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBody_line(?)"
              ]
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBody_line(?)"
              ]
            },
            {
              "Receiver": "*Body_lineContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBody_line(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Body_line",
              "calls": [
                "NewBody_lineContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Statement(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*StatementContext",
              "Name": "IsStatementContext"
            },
            {
              "Receiver": "*StatementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*StatementContext",
              "Name": "Simple_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*StatementContext",
              "Name": "Block_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*StatementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*StatementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*StatementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterStatement(?)"
              ]
            },
            {
              "Receiver": "*StatementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitStatement(?)"
              ]
            },
            {
              "Receiver": "*StatementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitStatement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Statement",
              "calls": [
                "NewStatementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Simple_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Block_statement(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "IsSimple_statementContext"
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Set_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Call_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Return_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Emit_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Must_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Fail_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "ClearErrorStmt",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Ask_stmt",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Break_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Continue_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterSimple_statement(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitSimple_statement(?)"
              ]
            },
            {
              "Receiver": "*Simple_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitSimple_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Simple_statement",
              "calls": [
                "NewSimple_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Set_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Call_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Return_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Emit_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Must_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Fail_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.ClearErrorStmt(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Ask_stmt(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Break_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Continue_statement(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "IsBlock_statementContext"
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "If_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "While_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "For_each_statement",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "OnErrorStmt",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBlock_statement(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBlock_statement(?)"
              ]
            },
            {
              "Receiver": "*Block_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBlock_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Block_statement",
              "calls": [
                "NewBlock_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.If_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.While_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.For_each_statement(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.OnErrorStmt(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "IsExpressionStatementContext"
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterExpressionStatement(?)"
              ]
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitExpressionStatement(?)"
              ]
            },
            {
              "Receiver": "*ExpressionStatementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitExpressionStatement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "ExpressionStatement",
              "calls": [
                "NewExpressionStatementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "IsSet_statementContext"
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "KW_SET",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "ASSIGN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterSet_statement(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitSet_statement(?)"
              ]
            },
            {
              "Receiver": "*Set_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitSet_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Set_statement",
              "calls": [
                "NewSet_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "IsCall_statementContext"
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "KW_CALL",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "Callable_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterCall_statement(?)"
              ]
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitCall_statement(?)"
              ]
            },
            {
              "Receiver": "*Call_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitCall_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Call_statement",
              "calls": [
                "NewCall_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Callable_expr(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "IsReturn_statementContext"
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "KW_RETURN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "Expression_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterReturn_statement(?)"
              ]
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitReturn_statement(?)"
              ]
            },
            {
              "Receiver": "*Return_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitReturn_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Return_statement",
              "calls": [
                "NewReturn_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.SetState(?)",
                "p.Expression_list(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "IsEmit_statementContext"
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "KW_EMIT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterEmit_statement(?)"
              ]
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitEmit_statement(?)"
              ]
            },
            {
              "Receiver": "*Emit_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitEmit_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Emit_statement",
              "calls": [
                "NewEmit_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "IsMust_statementContext"
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "KW_MUST",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "KW_MUSTBE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "Callable_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMust_statement(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMust_statement(?)"
              ]
            },
            {
              "Receiver": "*Must_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMust_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Must_statement",
              "calls": [
                "NewMust_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Callable_expr(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "IsFail_statementContext"
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "KW_FAIL",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterFail_statement(?)"
              ]
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitFail_statement(?)"
              ]
            },
            {
              "Receiver": "*Fail_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitFail_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Fail_statement",
              "calls": [
                "NewFail_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "IsClearErrorStmtContext"
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "KW_CLEAR_ERROR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterClearErrorStmt(?)"
              ]
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitClearErrorStmt(?)"
              ]
            },
            {
              "Receiver": "*ClearErrorStmtContext",
              "Name": "Accept",
              "calls": [
                "t.VisitClearErrorStmt(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "ClearErrorStmt",
              "calls": [
                "NewClearErrorStmtContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "IsAsk_stmtContext"
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "KW_ASK",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "KW_INTO",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterAsk_stmt(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitAsk_stmt(?)"
              ]
            },
            {
              "Receiver": "*Ask_stmtContext",
              "Name": "Accept",
              "calls": [
                "t.VisitAsk_stmt(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Ask_stmt",
              "calls": [
                "NewAsk_stmtContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "IsBreak_statementContext"
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "KW_BREAK",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBreak_statement(?)"
              ]
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBreak_statement(?)"
              ]
            },
            {
              "Receiver": "*Break_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBreak_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Break_statement",
              "calls": [
                "NewBreak_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "IsContinue_statementContext"
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "KW_CONTINUE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterContinue_statement(?)"
              ]
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitContinue_statement(?)"
              ]
            },
            {
              "Receiver": "*Continue_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitContinue_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Continue_statement",
              "calls": [
                "NewContinue_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "IsIf_statementContext"
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "KW_IF",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "AllNEWLINE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "AllStatement_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "Statement_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "KW_ENDIF",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "KW_ELSE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterIf_statement(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitIf_statement(?)"
              ]
            },
            {
              "Receiver": "*If_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitIf_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "If_statement",
              "calls": [
                "NewIf_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Statement_list(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Statement_list(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "IsWhile_statementContext"
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "KW_WHILE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "Statement_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "KW_ENDWHILE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterWhile_statement(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitWhile_statement(?)"
              ]
            },
            {
              "Receiver": "*While_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitWhile_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "While_statement",
              "calls": [
                "NewWhile_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Statement_list(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "IsFor_each_statementContext"
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "KW_FOR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "KW_EACH",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "KW_IN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "Statement_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "KW_ENDFOR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterFor_each_statement(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitFor_each_statement(?)"
              ]
            },
            {
              "Receiver": "*For_each_statementContext",
              "Name": "Accept",
              "calls": [
                "t.VisitFor_each_statement(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "For_each_statement",
              "calls": [
                "NewFor_each_statementContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Statement_list(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "IsOnErrorStmtContext"
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "KW_ON_ERROR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "KW_MEANS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "NEWLINE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "Statement_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "KW_ENDON",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterOnErrorStmt(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitOnErrorStmt(?)"
              ]
            },
            {
              "Receiver": "*OnErrorStmtContext",
              "Name": "Accept",
              "calls": [
                "t.VisitOnErrorStmt(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "OnErrorStmt",
              "calls": [
                "NewOnErrorStmtContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Statement_list(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "IsCall_targetContext"
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "KW_TOOL",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "DOT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterCall_target(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitCall_target(?)"
              ]
            },
            {
              "Receiver": "*Call_targetContext",
              "Name": "Accept",
              "calls": [
                "t.VisitCall_target(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Call_target",
              "calls": [
                "NewCall_targetContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "IsExpressionContext"
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "Logical_or_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterExpression(?)"
              ]
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitExpression(?)"
              ]
            },
            {
              "Receiver": "*ExpressionContext",
              "Name": "Accept",
              "calls": [
                "t.VisitExpression(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Expression",
              "calls": [
                "NewExpressionContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Logical_or_expr(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "IsLogical_or_exprContext"
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "AllLogical_and_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "Logical_and_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "AllKW_OR",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "KW_OR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterLogical_or_expr(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitLogical_or_expr(?)"
              ]
            },
            {
              "Receiver": "*Logical_or_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitLogical_or_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Logical_or_expr",
              "calls": [
                "NewLogical_or_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Logical_and_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Logical_and_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "IsLogical_and_exprContext"
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "AllBitwise_or_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "Bitwise_or_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "AllKW_AND",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "KW_AND",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterLogical_and_expr(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitLogical_and_expr(?)"
              ]
            },
            {
              "Receiver": "*Logical_and_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitLogical_and_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Logical_and_expr",
              "calls": [
                "NewLogical_and_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Bitwise_or_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Bitwise_or_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "IsBitwise_or_exprContext"
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "AllBitwise_xor_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "Bitwise_xor_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "AllPIPE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "PIPE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBitwise_or_expr(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBitwise_or_expr(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_or_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBitwise_or_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Bitwise_or_expr",
              "calls": [
                "NewBitwise_or_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Bitwise_xor_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Bitwise_xor_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "IsBitwise_xor_exprContext"
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "AllBitwise_and_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "Bitwise_and_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "AllCARET",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "CARET",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBitwise_xor_expr(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBitwise_xor_expr(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_xor_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBitwise_xor_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Bitwise_xor_expr",
              "calls": [
                "NewBitwise_xor_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Bitwise_and_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Bitwise_and_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "IsBitwise_and_exprContext"
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "AllEquality_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "Equality_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "AllAMPERSAND",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "AMPERSAND",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBitwise_and_expr(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBitwise_and_expr(?)"
              ]
            },
            {
              "Receiver": "*Bitwise_and_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBitwise_and_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Bitwise_and_expr",
              "calls": [
                "NewBitwise_and_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Equality_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Equality_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "IsEquality_exprContext"
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "AllRelational_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "Relational_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "AllEQ",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "EQ",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "AllNEQ",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "NEQ",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterEquality_expr(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitEquality_expr(?)"
              ]
            },
            {
              "Receiver": "*Equality_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitEquality_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Equality_expr",
              "calls": [
                "NewEquality_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Relational_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.Relational_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "IsRelational_exprContext"
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "AllAdditive_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "Additive_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "AllGT",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "GT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "AllLT",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "LT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "AllGTE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "GTE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "AllLTE",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "LTE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterRelational_expr(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitRelational_expr(?)"
              ]
            },
            {
              "Receiver": "*Relational_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitRelational_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Relational_expr",
              "calls": [
                "NewRelational_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Additive_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.Additive_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "IsAdditive_exprContext"
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "AllMultiplicative_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "Multiplicative_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "AllPLUS",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "PLUS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "AllMINUS",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "MINUS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterAdditive_expr(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitAdditive_expr(?)"
              ]
            },
            {
              "Receiver": "*Additive_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitAdditive_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Additive_expr",
              "calls": [
                "NewAdditive_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Multiplicative_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.Multiplicative_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "IsMultiplicative_exprContext"
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "AllUnary_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "Unary_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "AllSTAR",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "STAR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "AllSLASH",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "SLASH",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "AllPERCENT",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "PERCENT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMultiplicative_expr(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMultiplicative_expr(?)"
              ]
            },
            {
              "Receiver": "*Multiplicative_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMultiplicative_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Multiplicative_expr",
              "calls": [
                "NewMultiplicative_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Unary_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.Unary_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "IsUnary_exprContext"
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "Unary_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "MINUS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "KW_NOT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "KW_NO",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "KW_SOME",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "TILDE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "Power_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterUnary_expr(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitUnary_expr(?)"
              ]
            },
            {
              "Receiver": "*Unary_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitUnary_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Unary_expr",
              "calls": [
                "NewUnary_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.Unary_expr(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Power_expr(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "IsPower_exprContext"
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "Accessor_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "STAR_STAR",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "Power_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterPower_expr(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitPower_expr(?)"
              ]
            },
            {
              "Receiver": "*Power_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitPower_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Power_expr",
              "calls": [
                "NewPower_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Accessor_expr(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Power_expr(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "IsAccessor_exprContext"
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "Primary",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "AllLBRACK",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "LBRACK",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "AllExpression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "AllRBRACK",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "RBRACK",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterAccessor_expr(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitAccessor_expr(?)"
              ]
            },
            {
              "Receiver": "*Accessor_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitAccessor_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Accessor_expr",
              "calls": [
                "NewAccessor_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Primary(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "IsPrimaryContext"
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "Literal",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "Placeholder",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "KW_LAST",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "Callable_expr",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "KW_EVAL",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "LPAREN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "RPAREN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterPrimary(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitPrimary(?)"
              ]
            },
            {
              "Receiver": "*PrimaryContext",
              "Name": "Accept",
              "calls": [
                "t.VisitPrimary(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Primary",
              "calls": [
                "NewPrimaryContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetInterpreter().AdaptivePredict(?)",
                "p.GetInterpreter(?)",
                "p.GetTokenStream(?)",
                "p.GetParserRuleContext(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Literal(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Placeholder(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Callable_expr(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "IsCallable_exprContext"
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "LPAREN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "Expression_list_opt",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "RPAREN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "Call_target",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_LN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_LOG",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_SIN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_COS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_TAN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_ASIN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_ACOS",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "KW_ATAN",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterCallable_expr(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitCallable_expr(?)"
              ]
            },
            {
              "Receiver": "*Callable_exprContext",
              "Name": "Accept",
              "calls": [
                "t.VisitCallable_expr(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Callable_expr",
              "calls": [
                "NewCallable_exprContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Call_target(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression_list_opt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "IsPlaceholderContext"
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "PLACEHOLDER_START",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "PLACEHOLDER_END",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "IDENTIFIER",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "KW_LAST",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterPlaceholder(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitPlaceholder(?)"
              ]
            },
            {
              "Receiver": "*PlaceholderContext",
              "Name": "Accept",
              "calls": [
                "t.VisitPlaceholder(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Placeholder",
              "calls": [
                "NewPlaceholderContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "IsLiteralContext"
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "STRING_LIT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "TRIPLE_BACKTICK_STRING",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "NUMBER_LIT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "List_literal",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "Map_literal",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "Boolean_literal",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterLiteral(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitLiteral(?)"
              ]
            },
            {
              "Receiver": "*LiteralContext",
              "Name": "Accept",
              "calls": [
                "t.VisitLiteral(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Literal",
              "calls": [
                "NewLiteralContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.List_literal(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Map_literal(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Boolean_literal(?)",
                "p.SetError(?)",
                "antlr.NewNoViableAltException(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "IsBoolean_literalContext"
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "KW_TRUE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "KW_FALSE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterBoolean_literal(?)"
              ]
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitBoolean_literal(?)"
              ]
            },
            {
              "Receiver": "*Boolean_literalContext",
              "Name": "Accept",
              "calls": [
                "t.VisitBoolean_literal(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Boolean_literal",
              "calls": [
                "NewBoolean_literalContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.GetErrorHandler().RecoverInline(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().ReportMatch(?)",
                "p.GetErrorHandler(?)",
                "p.Consume(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "IsList_literalContext"
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "LBRACK",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "Expression_list_opt",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "RBRACK",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterList_literal(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitList_literal(?)"
              ]
            },
            {
              "Receiver": "*List_literalContext",
              "Name": "Accept",
              "calls": [
                "t.VisitList_literal(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "List_literal",
              "calls": [
                "NewList_literalContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression_list_opt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "IsMap_literalContext"
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "LBRACE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "Map_entry_list_opt",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "RBRACE",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMap_literal(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMap_literal(?)"
              ]
            },
            {
              "Receiver": "*Map_literalContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMap_literal(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Map_literal",
              "calls": [
                "NewMap_literalContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Map_entry_list_opt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "IsExpression_list_optContext"
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "Expression_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterExpression_list_opt(?)"
              ]
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitExpression_list_opt(?)"
              ]
            },
            {
              "Receiver": "*Expression_list_optContext",
              "Name": "Accept",
              "calls": [
                "t.VisitExpression_list_opt(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Expression_list_opt",
              "calls": [
                "NewExpression_list_optContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "int64",
                "int64",
                "p.SetState(?)",
                "p.Expression_list(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "IsExpression_listContext"
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "AllExpression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "AllCOMMA",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "COMMA",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterExpression_list(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitExpression_list(?)"
              ]
            },
            {
              "Receiver": "*Expression_listContext",
              "Name": "Accept",
              "calls": [
                "t.VisitExpression_list(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Expression_list",
              "calls": [
                "NewExpression_listContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "IsMap_entry_list_optContext"
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "Map_entry_list",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMap_entry_list_opt(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMap_entry_list_opt(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_list_optContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMap_entry_list_opt(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Map_entry_list_opt",
              "calls": [
                "NewMap_entry_list_optContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Map_entry_list(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "IsMap_entry_listContext"
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "AllMap_entry",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "Map_entry",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "AllCOMMA",
              "calls": [
                "s.GetTokens(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "COMMA",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMap_entry_list(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMap_entry_list(?)"
              ]
            },
            {
              "Receiver": "*Map_entry_listContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMap_entry_list(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Map_entry_list",
              "calls": [
                "NewMap_entry_listContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Map_entry(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Map_entry(?)",
                "p.SetState(?)",
                "p.GetErrorHandler().Sync(?)",
                "p.GetErrorHandler(?)",
                "p.HasError(?)",
                "p.GetTokenStream().LA(?)",
                "p.GetTokenStream(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "IsMap_entryContext"
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "GetParser"
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "STRING_LIT",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "COLON",
              "calls": [
                "s.GetToken(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "Expression",
              "calls": [
                "s.GetChildren(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "GetRuleContext"
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "ToStringTree",
              "calls": [
                "antlr.TreesStringTree(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "EnterRule",
              "calls": [
                "listenerT.EnterMap_entry(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "ExitRule",
              "calls": [
                "listenerT.ExitMap_entry(?)"
              ]
            },
            {
              "Receiver": "*Map_entryContext",
              "Name": "Accept",
              "calls": [
                "t.VisitMap_entry(?)",
                "t.VisitChildren(?)"
              ]
            },
            {
              "Receiver": "*NeuroScriptParser",
              "Name": "Map_entry",
              "calls": [
                "NewMap_entryContext",
                "p.GetParserRuleContext(?)",
                "p.GetState(?)",
                "p.EnterRule(?)",
                "p.EnterOuterAlt(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Match(?)",
                "p.HasError(?)",
                "p.SetState(?)",
                "p.Expression(?)",
                "p.HasError(?)",
                "p.GetError(?)",
                "localctx.SetException(?)",
                "p.GetErrorHandler().ReportError(?)",
                "p.GetErrorHandler(?)",
                "p.GetErrorHandler().Recover(?)",
                "p.GetErrorHandler(?)",
                "p.SetError(?)",
                "p.ExitRule(?)"
              ]
            }
          ]
        },
        "pkg/core/generated/neuroscript_visitor.go": {
          "methods": []
        }
      }
    },
    "pkg/core/prompts": {
      "files": {
        "pkg/core/prompts/prompts.go": {
          "methods": []
        }
      }
    },
    "pkg/core/tools/goast": {
      "files": {
        "pkg/core/tools/goast/tools_go_ast.go": {
          "functions": [
            "toolGoParseFile",
            "toolGoFormatAST",
            "registerGoAstTools",
            "NewDefaultTestInterpreter"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_analyze.go": {
          "functions": [
            "getOffsetFromLineCol",
            "formatPos",
            "toolGoGetNodeInfo"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_find.go": {
          "functions": [
            "toolGoFindIdentifiers"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_modify.go": {
          "functions": [
            "toolGoModifyAST"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_package.go": {
          "functions": [
            "toolGoUpdateImportsForMovedPackage"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_package_helpers.go": {
          "functions": [
            "analyzeImportsAndSymbols",
            "applyAstImportChanges",
            "collectGoFiles"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_package_helpers_test.go": {
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_package_test.go": {
          "functions": [
            "TestToolGoUpdateImportsForMovedPackage"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_path_helper.go": {
          "functions": [
            "debugCalculateCanonicalPath"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_path_helper_test.go": {
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_symbol_map.go": {
          "functions": [
            "buildSymbolMap"
          ],
          "methods": []
        },
        "pkg/core/tools/goast/tools_go_ast_symbol_map_test.go": {
          "functions": [
            "setupSymbolMapTestEnv",
            "TestBuildSymbolMapLogic"
          ],
          "methods": []
        }
      }
    },
    "pkg/interfaces": {
      "files": {
        "pkg/interfaces/logger.go": {
          "methods": [
            {
              "Receiver": "*NoOpLogger",
              "Name": "Debug"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Info"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Warn"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Error"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Debugf"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Infof"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Warnf"
            },
            {
              "Receiver": "*NoOpLogger",
              "Name": "Errorf"
            }
          ]
        }
      }
    },
    "pkg/logging": {
      "files": {
        "pkg/logging/logger.go": {
          "methods": []
        }
      }
    },
    "pkg/neurodata/blocks": {
      "files": {
        "pkg/neurodata/blocks/blocks_complex_test.go": {
          "functions": [
            "TestExtractAllAndMetadataComplex"
          ],
          "methods": []
        },
        "pkg/neurodata/blocks/blocks_extractor.go": {
          "functions": [
            "ExtractAll",
            "FormatBlocks"
          ],
          "methods": []
        },
        "pkg/neurodata/blocks/blocks_helpers.go": {
          "functions": [
            "minInt",
            "compareBlockSlices"
          ],
          "methods": []
        },
        "pkg/neurodata/blocks/blocks_simple_test.go": {
          "functions": [
            "TestExtractAllAndMetadataSimple"
          ],
          "methods": []
        },
        "pkg/neurodata/blocks/blocks_tool.go": {
          "functions": [
            "init",
            "RegisterBlockTools",
            "toolBlocksExtractAll"
          ],
          "methods": []
        }
      }
    },
    "pkg/neurodata/checklist": {
      "files": {
        "pkg/neurodata/checklist/checklist_adapter.go": {
          "functions": [
            "ChecklistToTree",
            "mapParserStatusToTreeStatus",
            "TreeToChecklistString",
            "formatChecklistNodeRecursive",
            "mapTreeStatusToMarkdown"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_adapter_test.go": {
          "functions": [
            "verifyTreeNode",
            "TestChecklistToTree",
            "TestTreeToChecklistString"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_modify_tool_test.go": {
          "functions": [
            "getNodeViaTool",
            "TestChecklistSetItemTextTool"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_status.go": {
          "functions": [
            "calculateAutomaticStatus"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_status_test.go": {
          "functions": [
            "TestCalculateAutomaticStatus"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_tool.go": {
          "functions": [
            "init",
            "RegisterChecklistTools",
            "toolChecklistLoadTree",
            "toolChecklistSetItemStatus"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_tool2.go": {
          "functions": [
            "toolChecklistFormatTree",
            "toolChecklistSetItemText",
            "toolChecklistUpdateStatus",
            "updateChecklistTreeStatus",
            "updateAutomaticNodeStatus"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_tool_add.go": {
          "functions": [
            "toolChecklistAddItem"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_tool_add_test.go": {
          "functions": [
            "TestChecklistAddItemTool",
            "TestChecklistUpdateStatusTool",
            "verifyNodeStatus",
            "getNodeChildrenIDs"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/checklist_tool_test.go": {
          "functions": [
            "getNodeAttributes",
            "TestChecklistLoadTree",
            "TestChecklistSetItemStatusTool",
            "TestChecklistFormatTreeTool"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/defined_errors.go": {
          "methods": []
        },
        "pkg/neurodata/checklist/scanner_parser.go": {
          "functions": [
            "ParseChecklist"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/scanner_parser_test.go": {
          "functions": [
            "checklistsEqual",
            "TestParseChecklistScannerFixtures"
          ],
          "methods": []
        },
        "pkg/neurodata/checklist/test_helpers.go": {
          "functions": [
            "newTestInterpreterWithAllTools",
            "getNodeValue",
            "getNodeAttributesMap",
            "assertNoErrorSetup",
            "assertToolFound",
            "pstr",
            "pbool",
            "pint"
          ],
          "methods": []
        }
      }
    },
    "pkg/neurodata/metadata": {
      "files": {
        "pkg/neurodata/metadata/metadata.go": {
          "functions": [
            "IsMetadataLine",
            "IsCommentOrBlank",
            "ExtractKeyValue",
            "Extract",
            "startsWithMetadataPrefixFunc",
            "commentOrBlankPatternFunc"
          ],
          "methods": []
        },
        "pkg/neurodata/metadata/metadata_test.go": {
          "functions": [
            "TestExtractMetadata"
          ],
          "methods": []
        }
      }
    },
    "pkg/neurodata/models": {
      "files": {
        "pkg/neurodata/models/models.go": {
          "methods": []
        }
      }
    },
    "pkg/neurogo": {
      "files": {
        "pkg/neurogo/agent_context.go": {
          "functions": [
            "NewAgentContext"
          ],
          "methods": [
            {
              "Receiver": "*AgentContext",
              "Name": "SetSandboxDir",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "GetSandboxDir",
              "calls": [
                "ac.mu.RLock(?)",
                "ac.mu.RUnlock(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "SetAllowlistPath",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "GetAllowlistPath",
              "calls": [
                "ac.mu.RLock(?)",
                "ac.mu.RUnlock(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "SetModelName",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "GetModelName",
              "calls": [
                "ac.mu.RLock(?)",
                "ac.mu.RUnlock(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "UpdateSyncedURIs",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "PinFile",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "UnpinFile",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "UnpinAllFiles",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "AddTemporaryURI",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "GetURIsForNextContext",
              "calls": [
                "ac.mu.Lock(?)",
                "ac.mu.Unlock(?)",
                "ac.Logger.Info(?)",
                "ac.Logger.Info(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "LookupURI",
              "calls": [
                "ac.mu.RLock(?)",
                "ac.mu.RUnlock(?)",
                "ac.Logger.Info(?)"
              ]
            },
            {
              "Receiver": "*AgentContext",
              "Name": "getRelativePath",
              "calls": [
                "ac.mu.RLock(?)",
                "ac.mu.RUnlock(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/agent_tools.go": {
          "functions": [
            "toolAgentSetSandbox",
            "toolAgentSetModel",
            "toolAgentSetAllowlist",
            "toolAgentPin",
            "RegisterAgentTools"
          ],
          "methods": []
        },
        "pkg/neurogo/app.go": {
          "functions": [
            "NewApp",
            "findProjectRoot"
          ],
          "methods": [
            {
              "Receiver": "*App",
              "Name": "Run",
              "calls": [
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "app.Log.Debug(?)",
                "app.loadSchema(?)",
                "app.Log.Warn(?)",
                "app.Log.Info(?)",
                "app.Log.Info(?)",
                "app.Log.Info(?)",
                "app.createLLMClient(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "pkg/core.NewInterpreter",
                "app.interpreter.SetSandboxDir(?)",
                "app.Log.Info(?)",
                "app.Log.Warn(?)",
                "app.Log.Info(?)",
                "app.Log.Info(?)",
                "pkg/toolsets.RegisterExtendedTools",
                "app.GetInterpreter().ToolRegistry(?)",
                "app.GetInterpreter(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "app.interpreter.FileAPI(?)",
                "app.Log.Warn(?)",
                "app.Log.Warn(?)",
                "app.Log.Info(?)",
                "app.Log.Debug(?)",
                "app.Log.Info(?)",
                "app.runScriptMode(?)",
                "app.Log.Info(?)",
                "app.runTuiMode(?)",
                "app.Log.Info(?)",
                "app.runSyncMode(?)",
                "app.Log.Info(?)",
                "app.runAgentMode(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "GetInterpreter",
              "calls": [
                "app.Log.Error(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "loadSchema",
              "calls": [
                "app.Log.Info(?)",
                "app.Log.Warn(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "createLLMClient",
              "calls": [
                "app.Log.Info(?)",
                "pkg/core.NewNoOpLLMClient",
                "app.Log.Info(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "app.Log.Debug(?)",
                "pkg/core.NewLLMClient",
                "app.Log.Error(?)",
                "app.Log.Info(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "GetModelName"
            },
            {
              "Receiver": "*App",
              "Name": "GetSyncDir"
            },
            {
              "Receiver": "*App",
              "Name": "GetSandboxDir"
            },
            {
              "Receiver": "*App",
              "Name": "GetSyncFilter"
            },
            {
              "Receiver": "*App",
              "Name": "GetSyncIgnoreGitignore"
            },
            {
              "Receiver": "*App",
              "Name": "GetLogger"
            },
            {
              "Receiver": "*App",
              "Name": "GetLLMClient",
              "calls": [
                "a.Log.Warn(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/app_acc_uris.go": {
          "functions": [
            "updateAccumulatedURIs"
          ],
          "methods": []
        },
        "pkg/neurogo/app_agent.go": {
          "functions": [
            "getAvailableTools",
            "snippet"
          ],
          "methods": [
            {
              "Receiver": "*App",
              "Name": "runAgentMode",
              "calls": [
                "app.Log.Info(?)",
                "pkg/core.NewConversationManager",
                "NewAgentContext",
                "agentCtx.SetSandboxDir(?)",
                "app.registerAgentTools(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "app.executeStartupScript(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "reader.ReadString(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)",
                "convoManager.AddUserMessage(?)",
                "app.handleTurn(?)",
                "app.Log.Error(?)",
                "convoManager.GetHistory(?)",
                "modelTextResponse.WriteString(?)",
                "string",
                "modelTextResponse.String(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "registerAgentTools",
              "calls": [
                "app.Log.Info(?)",
                "app.interpreter.ToolRegistry(?)",
                "RegisterAgentTools",
                "app.Log.Info(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "handleTurn",
              "calls": [
                "app.Log.Debug(?)",
                "app.GetLLMClient(?)",
                "app.Log.Error(?)",
                "app.interpreter.ToolRegistry(?)",
                "app.Log.Error(?)",
                "app.interpreter.SandboxDir(?)",
                "pkg/core.NewSecurityLayer",
                "getAvailableTools",
                "agentCtx.GetURIsForNextContext(?)",
                "app.handleAgentTurn(?)",
                "app.Log.Error(?)",
                "app.Log.Debug(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "executeStartupScript",
              "calls": [
                "app.Log.Info(?)",
                "app.Log.Error(?)",
                "app.processNeuroScriptFile(?)",
                "app.Log.Debug(?)",
                "app.Log.Warn(?)",
                "app.Log.Info(?)",
                "app.interpreter.RunProcedure(?)",
                "app.Log.Error(?)",
                "app.Log.Info(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/app_helpers.go": {
          "functions": [
            "min"
          ],
          "methods": [
            {
              "Receiver": "*App",
              "Name": "runCleanAPIMode",
              "calls": [
                "a.Log.Info(?)",
                "reader.ReadString(?)",
                "a.Log.Info(?)",
                "a.Log.Warn(?)",
                "a.GetLLMClient(?)",
                "llmClient.Client(?)",
                "a.GetLogger(?)",
                "logger.Info(?)",
                "logger.Error(?)",
                "logger.Info(?)",
                "logger.Info(?)",
                "deleteWg.Add(?)",
                "func(workerID int) {\n\tdefer deleteWg.Done()\n\tlogger.Debug(\"API Delete Worker started.\", \"worker_id\", workerID)\n\tfor fileToDelete := range deleteJobsChan {\n\t\tif fileToDelete == nil || fileToDelete.Name == \"\" {\n\t\t\tlogger.Debug(\"API Delete Worker received nil/empty file, skipping.\", \"worker_id\", workerID)\n\t\t\tcontinue\n\t\t}\n\t\tlogger.Debug(\"API Delete Worker deleting file.\", \"worker_id\", workerID, \"file_name\", fileToDelete.Name, \"display_name\", fileToDelete.DisplayName)\n\t\tdelCtx, cancelDel := context.WithTimeout(ctx, 30*time.Second)\n\n\t\tdeleteErr := genaiClient.DeleteFile(delCtx, fileToDelete.Name)\n\t\tcancelDel()\n\t\tif deleteErr != nil {\n\t\t\tdetailedErr := fmt.Errorf(\"worker %d failed delete %s (%s): %w\", workerID, fileToDelete.Name, fileToDelete.DisplayName, deleteErr)\n\t\t\tlogger.Error(\"API file deletion failed.\", \"worker_id\", workerID, \"file_name\", fileToDelete.Name, \"error\", detailedErr)\n\t\t\terrorChan \u003c- detailedErr\n\t\t} else {\n\t\t\tlogger.Debug(\"API Delete Worker deleted file.\", \"worker_id\", workerID, \"file_name\", fileToDelete.Name)\n\t\t}\n\t}\n\tlogger.Debug(\"API Delete Worker exiting.\", \"worker_id\", workerID)\n}(?)",
                "deleteWg.Done(?)",
                "logger.Debug(?)",
                "logger.Debug(?)",
                "logger.Debug(?)",
                "genaiClient.DeleteFile(?)",
                "cancelDel",
                "logger.Error(?)",
                "logger.Debug(?)",
                "logger.Debug(?)",
                "logger.Debug(?)",
                "logger.Debug(?)",
                "logger.Debug(?)",
                "deleteWg.Wait(?)",
                "logger.Debug(?)",
                "logger.Error(?)",
                "logger.Error(?)",
                "logger.Info(?)",
                "logger.Info(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/app_interface.go": {
          "methods": []
        },
        "pkg/neurogo/app_script.go": {
          "methods": [
            {
              "Receiver": "*App",
              "Name": "runScriptMode",
              "calls": [
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Error(?)",
                "a.Log.Debug(?)",
                "a.loadLibraries(?)",
                "a.Log.Error(?)",
                "a.Log.Info(?)",
                "a.determineProcedureToRun(?)",
                "a.Log.Error(?)",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Warn(?)",
                "interpreter.RunProcedure(?)",
                "interpreter.RunProcedure(?)",
                "execEndTime.Sub(?)",
                "a.Log.Info(?)",
                "a.Log.Error(?)",
                "a.Log.Info(?)",
                "a.Log.Debug(?)",
                "a.Log.Debug(?)",
                "a.Log.Info(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "loadLibraries",
              "calls": [
                "a.Log.Debug(?)",
                "a.Log.Warn(?)",
                "a.Log.Info(?)",
                "a.Log.Warn(?)",
                "info.IsDir(?)",
                "a.Log.Warn(?)",
                "d.IsDir(?)",
                "d.Name(?)",
                "a.Log.Debug(?)",
                "a.processNeuroScriptFile(?)",
                "a.Log.Error(?)",
                "a.Log.Error(?)",
                "info.Name(?)",
                "a.Log.Debug(?)",
                "a.processNeuroScriptFile(?)",
                "a.Log.Error(?)",
                "a.Log.Warn(?)",
                "a.Log.Debug(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "determineProcedureToRun",
              "calls": [
                "a.Log.Info(?)",
                "a.processNeuroScriptFile(?)",
                "a.Log.Warn(?)",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Info(?)"
              ]
            },
            {
              "Receiver": "*App",
              "Name": "processNeuroScriptFile",
              "calls": [
                "a.Log.Debug(?)",
                "a.Log.Error(?)",
                "string",
                "pkg/core.NewParserAPI",
                "parser.Parse(?)",
                "a.Log.Error(?)",
                "a.Log.Error(?)",
                "a.Log.Debug(?)",
                "pkg/core.NewASTBuilder",
                "astBuilder.Build(?)",
                "a.Log.Error(?)",
                "a.Log.Error(?)",
                "a.Log.Debug(?)",
                "a.Log.Warn(?)",
                "interp.AddProcedure(?)",
                "a.Log.Error(?)",
                "a.Log.Debug(?)",
                "a.Log.Debug(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/app_script_break_continue_test.go": {
          "functions": [
            "TestApp_RunScriptMode_BreakContinue"
          ],
          "methods": []
        },
        "pkg/neurogo/app_script_test.go": {
          "functions": [
            "TestApp_RunScriptMode_MultiReturn"
          ],
          "methods": []
        },
        "pkg/neurogo/app_sync.go": {
          "methods": [
            {
              "Receiver": "*App",
              "Name": "runSyncMode",
              "calls": [
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Error(?)",
                "a.Log.Error(?)",
                "a.Log.Debug(?)",
                "a.Log.Error(?)",
                "a.Log.Error(?)",
                "dirInfo.IsDir(?)",
                "a.Log.Error(?)",
                "a.Log.Info(?)",
                "a.Log.Error(?)",
                "a.llmClient.Client(?)",
                "a.Log.Error(?)",
                "a.Log.Info(?)",
                "pkg/core.SyncDirectoryUpHelper",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "logStat",
                "a.Log.Info(?)",
                "a.Log.Info(?)",
                "a.Log.Error(?)",
                "a.Log.Warn(?)",
                "a.Log.Warn(?)",
                "a.Log.Warn(?)",
                "a.Log.Warn(?)",
                "a.Log.Info(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/app_tui.go": {
          "methods": [
            {
              "Receiver": "*App",
              "Name": "runTuiMode",
              "calls": [
                "a.Log.Info(?)",
                "a.GetLLMClient(?)",
                "a.Log.Warn(?)",
                "llmClient.Client(?)",
                "a.Log.Warn(?)",
                "pkg/neurogo/tui.Start",
                "a.Log.Error(?)",
                "a.Log.Info(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/config.go": {
          "functions": [
            "NewConfig"
          ],
          "methods": [
            {
              "Receiver": "*stringSliceFlag",
              "Name": "String"
            },
            {
              "Receiver": "*stringSliceFlag",
              "Name": "Set"
            },
            {
              "Receiver": "*Config",
              "Name": "ParseFlags"
            }
          ]
        },
        "pkg/neurogo/handle_turn.go": {
          "methods": [
            {
              "Receiver": "*App",
              "Name": "handleAgentTurn",
              "calls": [
                "a.GetLogger(?)",
                "logger.Info(?)",
                "convoManager.GetHistory(?)",
                "logger.Warn(?)",
                "pkg/core.Role",
                "textContent.WriteString(?)",
                "string",
                "logger.Warn(?)",
                "logger.Warn(?)",
                "logger.Warn(?)",
                "textContent.String(?)",
                "logger.Warn(?)",
                "logger.Warn(?)",
                "logger.Debug(?)",
                "llmClient.AskWithTools(?)",
                "logger.Error(?)",
                "logger.Info(?)",
                "snippet",
                "logger.Info(?)",
                "logger.Info(?)",
                "logger.Info(?)",
                "logger.Warn(?)",
                "logger.Warn(?)",
                "logger.Debug(?)",
                "snippet",
                "accumulatedText.WriteString(?)",
                "logger.Info(?)",
                "securityLayer.ExecuteToolCall(?)",
                "logger.Error(?)",
                "pkg/core.CreateErrorFunctionResultPart",
                "logger.Info(?)",
                "convoManager.AddFunctionResultMessage(?)",
                "logger.Error(?)",
                "logger.Debug(?)",
                "accumulatedText.Reset(?)",
                "accumulatedText.String(?)",
                "logger.Info(?)",
                "logger.Debug(?)",
                "snippet",
                "logger.Info(?)",
                "a.patchHandler.ApplyPatch(?)",
                "logger.Error(?)",
                "logger.Info(?)",
                "logger.Warn(?)",
                "logger.Info(?)",
                "logger.Error(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/helpers.go": {
          "functions": [
            "loadToolListFromFile",
            "executeAgentTool",
            "formatToolResult",
            "formatErrorResponse"
          ],
          "methods": []
        },
        "pkg/neurogo/patch_handler.go": {
          "functions": [
            "readLines",
            "writeLines",
            "handleReceivedPatch"
          ],
          "methods": []
        }
      }
    },
    "pkg/neurogo/tui": {
      "files": {
        "pkg/neurogo/tui/interfaces.go": {
          "methods": []
        },
        "pkg/neurogo/tui/model.go": {
          "functions": [
            "newModel"
          ],
          "methods": [
            {
              "Receiver": "keyMap",
              "Name": "ShortHelp"
            },
            {
              "Receiver": "keyMap",
              "Name": "FullHelp"
            }
          ]
        },
        "pkg/neurogo/tui/msgs.go": {
          "methods": [
            {
              "Receiver": "errMsg",
              "Name": "Error",
              "calls": [
                "e.err.Error(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/tui/tui.go": {
          "functions": [
            "Start"
          ],
          "methods": []
        },
        "pkg/neurogo/tui/update.go": {
          "methods": [
            {
              "Receiver": "model",
              "Name": "Init"
            },
            {
              "Receiver": "model",
              "Name": "Update",
              "calls": [
                "m.viewport.Update(?)",
                "m.spinner.Update(?)",
                "github.com/charmbracelet/bubbles/key.Matches",
                "m.addMessage(?)",
                "github.com/charmbracelet/bubbles/key.Matches",
                "m.setSizes(?)",
                "m.viewport.GotoBottom(?)",
                "github.com/charmbracelet/bubbles/key.Matches",
                "m.promptInput.Blur(?)",
                "m.commandInput.Focus(?)",
                "m.addMessage(?)",
                "m.commandInput.Blur(?)",
                "m.promptInput.Focus(?)",
                "m.addMessage(?)",
                "m.commandInput.Value(?)",
                "m.addMessage(?)",
                "m.commandInput.Reset(?)",
                "m.addMessage(?)",
                "m.setSizes(?)",
                "m.addMessage(?)",
                "m.addMessage(?)",
                "m.addMessage(?)",
                "m.runSyncCmd(?)",
                "m.addMessage(?)",
                "m.promptInput.Value(?)",
                "m.addMessage(?)",
                "m.promptInput.Reset(?)",
                "m.viewport.GotoBottom(?)",
                "m.addMessage(?)",
                "m.commandInput.Update(?)",
                "m.promptInput.Update(?)",
                "m.setSizes(?)",
                "m.viewport.GotoBottom(?)",
                "int",
                "int",
                "m.addMessage(?)",
                "errorStyle.Render(?)",
                "m.addMessage(?)",
                "m.viewport.GotoBottom(?)",
                "m.addMessage(?)",
                "errorStyle.Render(?)",
                "m.viewport.GotoBottom(?)",
                "m.commandInput.Focused(?)",
                "m.commandInput.Focus(?)",
                "m.promptInput.Blur(?)",
                "m.promptInput.Focused(?)",
                "m.promptInput.Focus(?)",
                "m.commandInput.Blur(?)",
                "m.viewport.SetContent(?)",
                "m.renderMessages(?)",
                "m.viewport.GotoBottom(?)",
                "github.com/charmbracelet/bubbletea.Batch"
              ]
            }
          ]
        },
        "pkg/neurogo/tui/update_helpers.go": {
          "functions": [
            "max"
          ],
          "methods": [
            {
              "Receiver": "*model",
              "Name": "addMessage",
              "calls": [
                "m.viewport.SetContent(?)",
                "m.renderMessages(?)",
                "m.viewport.GotoBottom(?)"
              ]
            },
            {
              "Receiver": "*model",
              "Name": "renderMessages",
              "calls": [
                "systemStyle.Copy().Italic(true).Foreground(?)",
                "systemStyle.Copy().Italic(?)",
                "systemStyle.Copy(?)",
                "github.com/charmbracelet/lipgloss.Color",
                "systemStyle.Copy().Foreground(?)",
                "systemStyle.Copy(?)",
                "github.com/charmbracelet/lipgloss.Color",
                "content.WriteString(?)",
                "style.Render(?)",
                "content.String(?)"
              ]
            },
            {
              "Receiver": "*model",
              "Name": "renderStatusBar",
              "calls": [
                "m.spinner.View(?)",
                "m.spinner.View(?)",
                "m.spinner.View(?)",
                "m.spinner.View(?)",
                "errorStyle.Render(?)",
                "github.com/charmbracelet/lipgloss.Width",
                "github.com/charmbracelet/lipgloss.Width",
                "statusBarSyle.GetHorizontalPadding(?)",
                "github.com/charmbracelet/lipgloss.JoinHorizontal",
                "statusBarSyle.Render(?)",
                "github.com/charmbracelet/lipgloss.PlaceHorizontal",
                "github.com/charmbracelet/lipgloss.WithWhitespaceChars",
                "github.com/charmbracelet/lipgloss.WithWhitespaceForeground",
                "statusBarSyle.GetBackground(?)"
              ]
            },
            {
              "Receiver": "*model",
              "Name": "runSyncCmd",
              "calls": [
                "m.app.GetLogger(?)",
                "logger.Error(?)",
                "m.app.GetSyncDir(?)",
                "logger.Error(?)",
                "m.app.GetInterpreter(?)",
                "logger.Error(?)",
                "interp.FileAPI(?)",
                "logger.Error(?)",
                "fileAPI.ResolvePath(?)",
                "logger.Error(?)",
                "logger.Error(?)",
                "dirInfo.IsDir(?)",
                "logger.Error(?)",
                "m.app.GetSyncFilter(?)",
                "m.app.GetSyncIgnoreGitignore(?)",
                "pkg/core.SyncDirectoryUpHelper"
              ]
            },
            {
              "Receiver": "*model",
              "Name": "setSizes",
              "calls": [
                "m.commandInput.Height(?)",
                "m.promptInput.Height(?)",
                "github.com/charmbracelet/lipgloss.Height",
                "m.renderStatusBar(?)",
                "github.com/charmbracelet/lipgloss.Height",
                "m.help.View(?)",
                "m.commandInput.SetWidth(?)",
                "m.promptInput.SetWidth(?)",
                "m.viewport.SetContent(?)",
                "m.renderMessages(?)"
              ]
            }
          ]
        },
        "pkg/neurogo/tui/view.go": {
          "methods": [
            {
              "Receiver": "model",
              "Name": "View",
              "calls": [
                "m.viewport.View(?)",
                "m.renderStatusBar(?)",
                "m.commandInput.View(?)",
                "m.promptInput.View(?)",
                "github.com/charmbracelet/lipgloss.JoinHorizontal",
                "m.help.View(?)",
                "github.com/charmbracelet/lipgloss.JoinVertical",
                "github.com/charmbracelet/lipgloss.JoinVertical"
              ]
            }
          ]
        }
      }
    },
    "pkg/nspatch": {
      "files": {
        "pkg/nspatch/nspatch.go": {
          "functions": [
            "SetLogger",
            "VerifyChanges",
            "ApplyPatch",
            "LoadPatchFile",
            "calculateErrorPosition"
          ],
          "methods": []
        },
        "pkg/nspatch/nspatch_end_test.go": {
          "functions": [
            "TestVerifyChanges"
          ],
          "methods": []
        },
        "pkg/nspatch/nspatch_test.go": {
          "functions": [
            "readFileLinesForTest",
            "compareStringSlices",
            "checkFixtures",
            "TestLoadPatchFile",
            "TestApplyPatch"
          ],
          "methods": []
        }
      }
    },
    "pkg/toolsets": {
      "files": {
        "pkg/toolsets/register.go": {
          "functions": [
            "AddToolsetRegistration",
            "RegisterExtendedTools"
          ],
          "methods": []
        }
      }
    },
    "test_files": {
      "files": {
        "test_files/simple_test.go": {
          "functions": [
            "main"
          ],
          "methods": []
        }
      }
    }
  }
}
// NeuroScript Version: 0.7.4
// File version: 16
// Purpose: FIX: Corrects test logic to load funcs into the root runner and applies a permissive policy for tool-calling user runners.
// filename: pkg/api/ax_wiring_test.go
// nlines: 209
// risk_rating: HIGH

package api

import (
	"context"
	"errors"
	"sync"
	"testing"

	"github.com/aprice2704/neuroscript/pkg/ax"
	"github.com/aprice2704/neuroscript/pkg/lang"
	"github.com/aprice2704/neuroscript/pkg/policy"
)

// mockID implements the ax.ID interface for testing.
type mockID struct{ did ax.DID }

func (m *mockID) DID() ax.DID { return m.did }

// mockRuntime implements the api.Runtime and ax.IdentityCap interfaces for testing.
type mockRuntime struct {
	id ax.ID
}

func (m *mockRuntime) Identity() ax.ID { return m.id }

// Stubs to satisfy the api.Runtime interface
func (m *mockRuntime) Println(...any)                                 {}
func (m *mockRuntime) PromptUser(string) (string, error)              { return "", nil }
func (m *mockRuntime) GetVar(string) (any, bool)                      { return nil, false }
func (m *mockRuntime) SetVar(string, any)                             {}
func (m *mockRuntime) CallTool(FullName, []any) (any, error)          { return nil, nil }
func (m *mockRuntime) GetLogger() Logger                              { return nil }
func (m *mockRuntime) SandboxDir() string                             { return "" }
func (m *mockRuntime) ToolRegistry() ToolRegistry                     { return nil }
func (m *mockRuntime) LLM() LLMClient                                 { return nil }
func (m *mockRuntime) RegisterHandle(any, string) (string, error)     { return "", nil }
func (m *mockRuntime) GetHandleValue(string, string) (any, error)     { return nil, nil }
func (m *mockRuntime) AgentModels() AgentModelReader                  { return nil }
func (m *mockRuntime) AgentModelsAdmin() AgentModelAdmin              { return nil }
func (m *mockRuntime) GetGrantSet() *GrantSet                         { return nil }
func (m *mockRuntime) Accounts() AccountReader                        { return nil }
func (m *mockRuntime) AccountsAdmin() AccountAdmin                    { return nil }
func (m *mockRuntime) CapsuleStore() *CapsuleRegistry                 { return nil }
func (m *mockRuntime) CapsuleRegistryForAdmin() *AdminCapsuleRegistry { return nil }

// decoupledTool asserts the ax.IdentityCap, not a concrete runtime type.
func decoupledTool(rt Runtime, _ []any) (any, error) {
	if ri, ok := rt.(ax.IdentityCap); ok && ri.Identity() != nil {
		return "called by: " + string(ri.Identity().DID()), nil
	}
	return nil, errors.New("missing identity capability in runtime")
}

// TestAXWiring_FullLifecycle covers the checklist from impl_wiring.md using the public helpers.
func TestAXWiring_FullLifecycle(t *testing.T) {
	ctx := context.Background()
	bootID := &mockID{did: "did:test:boot"}
	baseRT := &mockRuntime{id: bootID}

	fac, err := NewAXFactory(ctx, ax.RunnerOpts{SandboxDir: "/tmp/ax-test"}, baseRT, bootID)
	if err != nil {
		t.Fatalf("NewAXFactory() failed: %v", err)
	}

	// 1. Bootloading and Environment Configuration
	bootLibScript := `
        func get_lib_msg(returns string) means
            return "from the library"
        endfunc
    `
	bootCmdScript := `
        command
            set boot_var = "secret"
        endcommand
    `
	// FIX: Load library functions directly into the factory's root interpreter
	// so they can be inherited by all subsequent user runners.
	libTree, err := Parse([]byte(bootLibScript), ParseSkipComments)
	if err != nil {
		t.Fatalf("boot: failed to parse library script: %v", err)
	}
	axFac := fac.(*axFactory)
	if err := axFac.root.AppendScript(libTree); err != nil {
		t.Fatalf("boot: failed to append library script to root: %v", err)
	}

	// Now run the command script in a separate config runner to test state isolation.
	configRunner, err := fac.NewRunner(ctx, ax.RunnerConfig, ax.RunnerOpts{})
	if err != nil {
		t.Fatalf("NewRunner(Config) for boot failed: %v", err)
	}
	if err := configRunner.LoadScript([]byte(bootCmdScript)); err != nil {
		t.Fatalf("boot: LoadScript(cmd) failed: %v", err)
	}
	if _, err := configRunner.Execute(); err != nil {
		t.Fatalf("boot: Execute() failed: %v", err)
	}

	// 2. User Runner Execution: Running a Func
	t.Run("FunctionInheritanceAndStateIsolation", func(t *testing.T) {
		userRunner, err := fac.NewRunner(ctx, ax.RunnerUser, ax.RunnerOpts{})
		if err != nil {
			t.Fatalf("NewRunner(User) failed: %v", err)
		}

		userScript := `
            func main(returns string) means
                return get_lib_msg()
            endfunc
        `
		res, err := AXRunScript(ctx, userRunner, []byte(userScript), "main")
		if err != nil {
			t.Fatalf("AXRunScript() failed: %v", err)
		}

		if s, ok := res.(string); !ok || s != "from the library" {
			t.Errorf("Inherited function returned wrong value: got %q, want 'from the library'", s)
		}

		interp, ok := AXInterpreter(userRunner)
		if !ok {
			t.Fatal("Could not get internal interpreter for test verification")
		}
		_, found := interp.GetVariable("boot_var")
		if found {
			t.Error("State (boot_var) leaked from boot runner to user runner")
		}
	})

	// 3. User Runner Execution: Running a Command Block
	t.Run("CommandBlockExecution", func(t *testing.T) {
		userRunner, err := fac.NewRunner(ctx, ax.RunnerUser, ax.RunnerOpts{})
		if err != nil {
			t.Fatalf("NewRunner(User) for command test failed: %v", err)
		}

		var emittedValue any
		var wg sync.WaitGroup
		wg.Add(1)

		interp, _ := AXInterpreter(userRunner)
		interp.SetEmitFunc(func(v lang.Value) {
			emittedValue = lang.Unwrap(v)
			wg.Done()
		})

		cmdScript := `
			command
				emit "command block was executed"
			endcommand
		`
		if err := userRunner.LoadScript([]byte(cmdScript)); err != nil {
			t.Fatalf("LoadScript() for command block failed: %v", err)
		}
		if _, err := userRunner.Execute(); err != nil {
			t.Fatalf("Execute() for command block failed: %v", err)
		}

		wg.Wait()

		expected := "command block was executed"
		if s, ok := emittedValue.(string); !ok || s != expected {
			t.Errorf("Execute() did not produce the correct emitted value: got %q, want %q", s, expected)
		}
	})

	// 4. Identity and Tool Decoupling
	t.Run("IdentityCapabilityInTools", func(t *testing.T) {
		userID := &mockID{did: "did:test:user123"}
		userRT := &mockRuntime{id: userID}
		userFac, _ := NewAXFactory(ctx, ax.RunnerOpts{}, userRT, userID)
		userRunner, _ := userFac.NewRunner(ctx, ax.RunnerUser, ax.RunnerOpts{})

		// FIX: User runners default to a deny-all policy. For this test,
		// we must grant permission to call the tool.
		interp, ok := AXInterpreter(userRunner)
		if !ok {
			t.Fatal("Could not get internal interpreter to set policy")
		}
		allowToolPolicy := policy.NewBuilder(policy.ContextUser).Allow("tool.host.whoami").Build()
		interp.ExecPolicy = allowToolPolicy

		decoupledToolImpl := ToolImplementation{
			Spec: ToolSpec{Name: "whoami", Group: "host"},
			Func: decoupledTool,
		}
		if err := userRunner.Tools().Register("tool.host.whoami", decoupledToolImpl); err != nil {
			t.Fatalf("Failed to register tool: %v", err)
		}

		toolScript := `
            func main(returns string) means
                return tool.host.whoami()
            endfunc
        `
		res, err := AXRunScript(ctx, userRunner, []byte(toolScript), "main")
		if err != nil {
			t.Fatalf("AXRunScript() with identity-aware tool failed: %v", err)
		}

		expected := "called by: did:test:user123"
		if s, ok := res.(string); !ok || s != expected {
			t.Errorf("Identity tool returned wrong value: got %q, want %q", s, expected)
		}
	})
}

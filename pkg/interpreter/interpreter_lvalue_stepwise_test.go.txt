// filename: pkg/interpreter/interpreter_lvalue_stepwise_test.go
// NeuroScript Version: 0.5.2
// File version: 3.0.0
// Purpose: A dedicated, stepwise test file to debug l-value auto-vivification, now with a direct AST inspection test.
package interpreter

import (
	"testing"

	"github.com/aprice2704/neuroscript/pkg/ast"
	"github.com/aprice2704/neuroscript/pkg/lang"
	"github.com/aprice2704/neuroscript/pkg/parser"
	"github.com/aprice2704/neuroscript/pkg/types"
	"github.com/google/go-cmp/cmp"
)

// --- Local Helpers to make this test self-contained ---

var stepWiseTestPos = &types.Position{Line: 1, Column: 1, File: "lvalue_stepwise_test"}

func strLit(val string) *ast.StringLiteralNode {
	return &ast.StringLiteralNode{Pos: stepWiseTestPos, Value: val}
}

func numLit(i int64) *ast.NumberLiteralNode {
	// AST Builder uses float64, so we must match it.
	return &ast.NumberLiteralNode{Pos: stepWiseTestPos, Value: float64(i)}
}

func lvalAccessor(key ast.Expression, accType ast.AccessorType) *ast.AccessorNode {
	return &ast.AccessorNode{Pos: stepWiseTestPos, Type: accType, Key: key}
}

func lvalNode(name string, accessors ...*ast.AccessorNode) *ast.LValueNode {
	return &ast.LValueNode{
		Position:   *stepWiseTestPos,
		Identifier: name,
		Accessors:  accessors,
	}
}

func setStep(lval *ast.LValueNode, rval ast.Expression) ast.Step {
	return ast.Step{
		Type:     "set",
		Position: *stepWiseTestPos,
		LValues:  []*ast.LValueNode{lval},
		Values:   []ast.Expression{rval},
	}
}

// --- Stepwise Test ---

func TestLValueAutoVivification_Stepwise(t *testing.T) {
	// Step 0: Directly inspect the AST generated by the parser.
	t.Run("Step 0: Inspect Parser-Generated AST", func(t *testing.T) {
		script := `func main() means
			set a.b[0]["c"].d[1] = "deep value"
		endfunc`

		interp, _ := newLocalTestInterpreter(t, nil, nil)
		parserAPI := parser.NewParserAPI(interp.GetLogger())
		parseTree, pErr := parserAPI.Parse(script)
		if pErr != nil {
			t.Fatalf("Step 0 parser failed: %v", pErr)
		}
		program, _, bErr := parser.NewASTBuilder(interp.GetLogger()).Build(parseTree)
		if bErr != nil {
			t.Fatalf("Step 0 AST builder failed: %v", bErr)
		}

		// This is the AST node generated by the full pipeline
		gotLVal := program.Procedures["main"].Steps[0].LValues[0]

		// This is the "perfect" AST node we build manually
		expectedLVal := lvalNode("a",
			lvalAccessor(strLit("b"), ast.DotAccess),
			lvalAccessor(numLit(0), ast.BracketAccess),
			lvalAccessor(strLit("c"), ast.BracketAccess),
			lvalAccessor(strLit("d"), ast.DotAccess),
			lvalAccessor(numLit(1), ast.BracketAccess),
		)

		// We ignore the position fields for comparison as they will naturally differ.
		opts := cmp.FilterPath(func(p cmp.Path) bool {
			return p.String() == "Pos" || p.String() == "Position"
		}, cmp.Ignore())

		if diff := cmp.Diff(expectedLVal, gotLVal, opts); diff != "" {
			t.Fatalf("Step 0 AST inspection failed. The generated AST does not match the expected AST.\nMismatch (-want +got):\n%s", diff)
		}
	})

	interp, err := newLocalTestInterpreter(t, nil, nil)
	if err != nil {
		t.Fatalf("Failed to create test interpreter: %v", err)
	}

	// Step 1: set a.b = "level 1"
	t.Run("Step 1: Create nested map", func(t *testing.T) {
		step1 := setStep(
			lvalNode("a", lvalAccessor(strLit("b"), ast.DotAccess)),
			strLit("level 1"),
		)
		_, _, _, err := interp.executeSteps([]ast.Step{step1}, false, nil)
		if err != nil {
			t.Fatalf("Step 1 failed: %v", err)
		}
	})

	// Step 2: set a.b[0] = "list value"
	t.Run("Step 2: Overwrite with list", func(t *testing.T) {
		step2 := setStep(
			lvalNode("a",
				lvalAccessor(strLit("b"), ast.DotAccess),
				lvalAccessor(numLit(0), ast.BracketAccess),
			),
			strLit("list value"),
		)
		_, _, _, err := interp.executeSteps([]ast.Step{step2}, false, nil)
		if err != nil {
			t.Fatalf("Step 2 failed: %v", err)
		}
	})

	// Step 3: set a.b[0]["c"] = "map in list"
	t.Run("Step 3: Create map in list", func(t *testing.T) {
		interp.SetVariable("a", lang.NewMapValue(map[string]lang.Value{
			"b": &lang.ListValue{Value: []lang.Value{
				&lang.NilValue{},
			}},
		}))
		step3 := setStep(
			lvalNode("a",
				lvalAccessor(strLit("b"), ast.DotAccess),
				lvalAccessor(numLit(0), ast.BracketAccess),
				lvalAccessor(strLit("c"), ast.BracketAccess),
			),
			strLit("map in list"),
		)
		_, _, _, err := interp.executeSteps([]ast.Step{step3}, false, nil)
		if err != nil {
			t.Fatalf("Step 3 failed: %v", err)
		}
	})

	// Step 4: The final failing case: set a.b[0]["c"].d[1] = "deep value"
	t.Run("Step 4: The final failing case", func(t *testing.T) {
		interp.SetVariable("a", lang.NewMapValue(map[string]lang.Value{
			"b": &lang.ListValue{Value: []lang.Value{
				lang.NewMapValue(map[string]lang.Value{
					"c": lang.NewMapValue(make(map[string]lang.Value)),
				}),
			}},
		}))
		step4 := setStep(
			lvalNode("a",
				lvalAccessor(strLit("b"), ast.DotAccess),
				lvalAccessor(numLit(0), ast.BracketAccess),
				lvalAccessor(strLit("c"), ast.BracketAccess),
				lvalAccessor(strLit("d"), ast.DotAccess),
				lvalAccessor(numLit(1), ast.BracketAccess),
			),
			strLit("deep value"),
		)
		_, _, _, err := interp.executeSteps([]ast.Step{step4}, false, nil)
		if err != nil {
			t.Fatalf("Step 4 failed: %v", err)
		}
	})

	// Step 5: Test literal index into a list, as requested.
	t.Run("Step 5: Literal index into list", func(t *testing.T) {
		interp.SetVariable("a", lang.NewMapValue(map[string]lang.Value{
			"b": &lang.ListValue{Value: []lang.Value{
				lang.StringValue{Value: "original value"},
				lang.StringValue{Value: "another one"},
			}},
		}))
		step5 := setStep(
			lvalNode("a",
				lvalAccessor(strLit("b"), ast.DotAccess),
				lvalAccessor(numLit(1), ast.BracketAccess),
			),
			strLit("new value"),
		)
		_, _, _, err := interp.executeSteps([]ast.Step{step5}, false, nil)
		if err != nil {
			t.Fatalf("Step 5 failed: %v", err)
		}
	})
}

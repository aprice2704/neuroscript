// NeuroScript Version: 0.6.0
// File version: 5.0.0
// Purpose: Corrected mock AgentModel config to include the required 'api_key_ref', fixing policy validation failures in the E2E test.
// filename: pkg/interpreter/ask/agentmodel_e2e_test.go
// nlines: 200
// risk_rating: HIGH

package ask

import (
	"context"
	"errors"
	"fmt"
	"os"
	"testing"

	"github.com/aprice2704/neuroscript/pkg/interpreter"
	"github.com/aprice2704/neuroscript/pkg/lang"
	"github.com/aprice2704/neuroscript/pkg/logging"
	"github.com/aprice2704/neuroscript/pkg/parser"
	"github.com/aprice2704/neuroscript/pkg/policy"
	"github.com/aprice2704/neuroscript/pkg/policy/capability"
	"github.com/aprice2704/neuroscript/pkg/provider"
	"github.com/aprice2704/neuroscript/pkg/tool"
	"github.com/aprice2704/neuroscript/pkg/tool/agentmodel"
)

// --- Mock E2E AI Provider ---

type mockE2EProvider struct {
	t                *testing.T
	ExpectedAPIKey   string
	WasCalled        bool
	ResponseToReturn *provider.AIResponse
	ErrorToReturn    error
}

func (m *mockE2EProvider) Chat(ctx context.Context, req provider.AIRequest) (*provider.AIResponse, error) {
	m.t.Helper()
	m.WasCalled = true

	if m.ExpectedAPIKey != "" && req.APIKey != m.ExpectedAPIKey {
		err := fmt.Errorf("mock provider received wrong API key. got: '%s', want: '%s'", req.APIKey, m.ExpectedAPIKey)
		m.t.Error(err)
		return nil, err
	}

	if m.ErrorToReturn != nil {
		return nil, m.ErrorToReturn
	}
	if m.ResponseToReturn == nil {
		return &provider.AIResponse{TextContent: "mock e2e success"}, nil
	}
	return m.ResponseToReturn, nil
}

const e2eScript = `
:: name: E2E AgentModel Registration and Use
:: version: 1.0

func _SetupMockAgent() means
    :: description: Registers the mock agent using the tool.
    set config = {\
        "provider": "mock_e2e_provider",\
        "model": "e2e_model",\
        "api_key_ref": "MOCK_API_KEY_ENV_VAR"\
    }
    must tool.agentmodel.Register("mock_e2e_agent", config)
endfunc

func TestTheAsk(returns result) means
    :: description: Uses the configured agent via the 'ask' statement.
    ask "mock_e2e_agent", "Does the API key work?" into result
    return result
endfunc
`

// TestAgentModelE2E_SuccessWithPrivileges verifies the full flow works when the
// interpreter is configured with a policy that allows trusted tools to run.
func TestAgentModelE2E_SuccessWithPrivileges(t *testing.T) {
	const mockAPIKey = "secret-key-for-e2e-test"
	const mockEnvVar = "MOCK_API_KEY_ENV_VAR"
	t.Setenv(mockEnvVar, mockAPIKey)
	defer os.Unsetenv(mockEnvVar)

	// Define a policy that allows the script's setup function to succeed.
	configPolicy := &policy.ExecPolicy{
		Context: policy.ContextConfig,
		Allow:   []string{"tool.agentmodel.*"},
		Grants: capability.NewGrantSet(
			[]capability.Capability{
				{Resource: "model", Verbs: []string{"admin", "use"}, Scopes: []string{"*"}},
				{Resource: "env", Verbs: []string{"read"}, Scopes: []string{"*"}},
				{Resource: "net", Verbs: []string{"read"}, Scopes: []string{"*"}},
			},
			capability.Limits{},
		),
	}

	interp := interpreter.NewInterpreter(
		interpreter.WithoutStandardTools(),
		interpreter.WithLogger(logging.NewTestLogger(t)),
		interpreter.WithExecPolicy(configPolicy),
	)
	mockProv := &mockE2EProvider{t: t, ExpectedAPIKey: mockAPIKey}
	regFunc := tool.CreateRegistrationFunc("agentmodel", agentmodel.AgentModelToolsToRegister)
	if err := regFunc(interp.ToolRegistry()); err != nil {
		t.Fatalf("Failed to register agentmodel toolset: %v", err)
	}
	interp.RegisterProvider("mock_e2e_provider", mockProv)

	parserAPI := parser.NewParserAPI(interp.GetLogger())
	p, pErr := parserAPI.Parse(e2eScript)
	if pErr != nil {
		t.Fatalf("Failed to parse script: %v", pErr)
	}
	program, _, bErr := parser.NewASTBuilder(interp.GetLogger()).Build(p)
	if bErr != nil {
		t.Fatalf("Failed to build AST: %v", bErr)
	}
	if err := interp.Load(program); err != nil {
		t.Fatalf("Failed to load program: %v", err)
	}

	// Run the setup procedure, which should succeed with the correct policy.
	_, err := interp.Run("_SetupMockAgent")
	if err != nil {
		t.Fatalf("Agent setup procedure failed unexpectedly: %v", err)
	}
	_, exists := interp.GetAgentModel("mock_e2e_agent")
	if !exists {
		t.Fatal("AgentModel 'mock_e2e_agent' was not registered by the setup script.")
	}

	// Run the main test procedure.
	resultVal, err := interp.Run("TestTheAsk")
	if err != nil {
		t.Fatalf("Main test procedure 'TestTheAsk' failed: %v", err)
	}

	// Assertions
	if !mockProv.WasCalled {
		t.Error("Mock AI provider's Chat method was never called.")
	}
	resultStr, _ := lang.ToString(resultVal)
	expectedResponse := "mock e2e success"
	if resultStr != expectedResponse {
		t.Errorf("Expected final result to be '%s', but got '%s'", expectedResponse, resultStr)
	}
	t.Log("Successfully verified E2E success path with a privileged policy.")
}

// TestAgentModelE2E_FailureNoPrivileges verifies that the setup script fails
// as expected when the interpreter is run with a default, non-privileged policy.
func TestAgentModelE2E_FailureNoPrivileges(t *testing.T) {
	// No ExecPolicy is provided, so the interpreter defaults to ContextNormal.
	interp := interpreter.NewInterpreter(
		interpreter.WithoutStandardTools(),
		interpreter.WithLogger(logging.NewTestLogger(t)),
	)
	mockProv := &mockE2EProvider{t: t}
	regFunc := tool.CreateRegistrationFunc("agentmodel", agentmodel.AgentModelToolsToRegister)
	if err := regFunc(interp.ToolRegistry()); err != nil {
		t.Fatalf("Failed to register agentmodel toolset: %v", err)
	}
	interp.RegisterProvider("mock_e2e_provider", mockProv)

	parserAPI := parser.NewParserAPI(interp.GetLogger())
	p, pErr := parserAPI.Parse(e2eScript)
	if pErr != nil {
		t.Fatalf("Failed to parse script: %v", pErr)
	}
	program, _, bErr := parser.NewASTBuilder(interp.GetLogger()).Build(p)
	if bErr != nil {
		t.Fatalf("Failed to build AST: %v", bErr)
	}
	if err := interp.Load(program); err != nil {
		t.Fatalf("Failed to load program: %v", err)
	}

	// Run the setup procedure, which is now expected to fail.
	_, err := interp.Run("_SetupMockAgent")
	if err == nil {
		t.Fatal("Agent setup procedure was expected to fail due to lack of privileges, but it succeeded.")
	}

	// Check for the specific error from the policy gate.
	var rtErr *lang.RuntimeError
	if !errors.As(err, &rtErr) {
		t.Fatalf("Expected a RuntimeError, but got %T", err)
	}
	if !errors.Is(rtErr.Unwrap(), policy.ErrTrust) {
		t.Errorf("Expected error to wrap policy.ErrTrust, but it wrapped: %v", rtErr.Unwrap())
	}

	t.Logf("Successfully verified that setup fails with the expected error: %v", err)
}

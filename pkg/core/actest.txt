=== RUN   TestIfThenElse_SimpleIfThen
--- PASS: TestIfThenElse_SimpleIfThen (0.00s)
=== RUN   TestIfThenElse_SimpleIfThenElse
--- PASS: TestIfThenElse_SimpleIfThenElse (0.00s)
=== RUN   TestIfThenElse_IfElseIfElse
--- PASS: TestIfThenElse_IfElseIfElse (0.00s)
=== RUN   TestIfThenElse_IfElseIfOnly
--- PASS: TestIfThenElse_IfElseIfOnly (0.00s)
=== RUN   TestIfThenElse_MultipleElseIfs
--- PASS: TestIfThenElse_MultipleElseIfs (0.00s)
=== RUN   TestIfThenElse_NestedIfInThen
--- PASS: TestIfThenElse_NestedIfInThen (0.00s)
=== RUN   TestIfThenElse_NestedIfInElse
--- PASS: TestIfThenElse_NestedIfInElse (0.00s)
=== RUN   TestIfThenElse_EmptyThenBlock
--- PASS: TestIfThenElse_EmptyThenBlock (0.00s)
=== RUN   TestIfThenElse_EmptyElseBlock
--- PASS: TestIfThenElse_EmptyElseBlock (0.00s)
=== RUN   TestIfThenElse_EmptyThenAndElseBlocks
--- PASS: TestIfThenElse_EmptyThenAndElseBlocks (0.00s)
=== RUN   TestIfThenElse_MultipleStatementsInBlocks
--- PASS: TestIfThenElse_MultipleStatementsInBlocks (0.00s)
=== RUN   TestLValueParsing
=== RUN   TestLValueParsing/simple_identifier
=== RUN   TestLValueParsing/single_dot_access
=== RUN   TestLValueParsing/multiple_dot_access
=== RUN   TestLValueParsing/single_bracket_access_string_key
=== RUN   TestLValueParsing/single_bracket_access_numeric_index
=== RUN   TestLValueParsing/multiple_bracket_access_string_keys
=== RUN   TestLValueParsing/mixed_dot_and_bracket
=== RUN   TestLValueParsing/mixed_bracket_and_dot
=== RUN   TestLValueParsing/complex_nested_access
=== RUN   TestLValueParsing/bracket_access_with_simple_expression_(variable)
--- PASS: TestLValueParsing (0.00s)
    --- PASS: TestLValueParsing/simple_identifier (0.00s)
    --- PASS: TestLValueParsing/single_dot_access (0.00s)
    --- PASS: TestLValueParsing/multiple_dot_access (0.00s)
    --- PASS: TestLValueParsing/single_bracket_access_string_key (0.00s)
    --- PASS: TestLValueParsing/single_bracket_access_numeric_index (0.00s)
    --- PASS: TestLValueParsing/multiple_bracket_access_string_keys (0.00s)
    --- PASS: TestLValueParsing/mixed_dot_and_bracket (0.00s)
    --- PASS: TestLValueParsing/mixed_bracket_and_dot (0.00s)
    --- PASS: TestLValueParsing/complex_nested_access (0.00s)
    --- PASS: TestLValueParsing/bracket_access_with_simple_expression_(variable) (0.00s)
=== RUN   TestTypeOfOperator_LiteralsAndVariables
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_string_literal
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_string_literal/typeof_string_literal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_string_literaltypeof_string_literal1968584033/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof("hello") pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
string
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=string final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(int)
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(int)/typeof_number_literal_(int)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_number_literal_(int)typeof_number_literal_(int)1895657304/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof(123) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
number
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=number final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(float)
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(float)/typeof_number_literal_(float)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_number_literal_(float)typeof_number_literal_(float)808459441/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof(123.45) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
number
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=number final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_boolean_literal_(true)
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_boolean_literal_(true)/typeof_boolean_literal_(true)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_boolean_literal_(true)typeof_boolean_literal_(true)2552849042/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof(true) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
boolean
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=boolean final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_nil_literal
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_nil_literal/typeof_nil_literal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_nil_literaltypeof_nil_literal672833791/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof(nil) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=nil final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_list_literal
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_list_literal/typeof_list_literal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_list_literaltypeof_list_literal1957979032/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof([1, "a"]) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
list
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=list final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_map_literal
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_map_literal/typeof_map_literal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_map_literaltypeof_map_literal4094012089/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof({"key": "value", "num": 1}) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
map
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=map final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_arithmetic_expression
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_arithmetic_expression/typeof_arithmetic_expression
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_arithmetic_expressiontypeof_arithmetic_expression861260587/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=typeof((1 + 2)) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
number
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=number final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(string)
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(string)/typeof_variable_(string)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_variable_(string)typeof_variable_(string)3805969032/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=myVar pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=EMIT subject=typeof(myVar) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
string
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=string final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(list)
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(list)/typeof_variable_(list)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_variable_(list)typeof_variable_(list)1627723511/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=myList pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=EMIT subject=typeof(myList) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
list
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=list final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_last_expression_(number)
=== RUN   TestTypeOfOperator_LiteralsAndVariables/typeof_last_expression_(number)/typeof_last_expression_(number)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_LiteralsAndVariablestypeof_last_expression_(number)typeof_last_expression_(number)847103667/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=100 pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
100
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=EMIT subject=typeof(last) pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 1, col 1
number
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=number final_lastCallResultType=core.StringValue final_wasCleared=false
--- PASS: TestTypeOfOperator_LiteralsAndVariables (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_string_literal (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_string_literal/typeof_string_literal (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(int) (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(int)/typeof_number_literal_(int) (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(float) (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_number_literal_(float)/typeof_number_literal_(float) (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_boolean_literal_(true) (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_boolean_literal_(true)/typeof_boolean_literal_(true) (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_nil_literal (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_nil_literal/typeof_nil_literal (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_list_literal (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_list_literal/typeof_list_literal (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_map_literal (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_map_literal/typeof_map_literal (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_arithmetic_expression (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_arithmetic_expression/typeof_arithmetic_expression (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(string) (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(string)/typeof_variable_(string) (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(list) (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_variable_(list)/typeof_variable_(list) (0.00s)
    --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_last_expression_(number) (0.00s)
        --- PASS: TestTypeOfOperator_LiteralsAndVariables/typeof_last_expression_(number)/typeof_last_expression_(number) (0.00s)
=== RUN   TestTypeOfOperator_Function
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_Function2748284946/001
    helpers.go:67: [DEBUG] Added procedure definition. name=myTestFuncForTypeOf
--- PASS: TestTypeOfOperator_Function (0.00s)
=== RUN   TestTypeOfOperator_Tool
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTypeOfOperator_Tool3847489778/001
--- PASS: TestTypeOfOperator_Tool (0.00s)
=== RUN   TestEvaluateElementAccess
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateElementAccess3136653607/001
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateElementAccess3136653607/002
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateElementAccess3136653607/003
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateElementAccess3136653607/004
--- PASS: TestEvaluateElementAccess (0.00s)
=== RUN   TestArithmeticOps
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestArithmeticOps2571938972/001
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestArithmeticOps2571938972/002
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestArithmeticOps2571938972/003
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestArithmeticOps2571938972/004
--- PASS: TestArithmeticOps (0.00s)
=== RUN   TestEvaluateCondition
=== RUN   TestEvaluateCondition/Boolean_Literal_True
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateConditionBoolean_Literal_True2034103528/001
    helpers.go:67: [DEBUG] -INTERP]        Condition node %T evaluated to %v (%T), truthiness: %t (Logger Warning: expected string key, got *core.BooleanLiteralNode) true=true (Logger Warning: expected string key, got core.BoolValue) true=true
=== RUN   TestEvaluateCondition/Var_Boolean_True
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateConditionVar_Boolean_True999869147/001
    helpers.go:67: [DEBUG] -INTERP]        Condition node %T evaluated to %v (%T), truthiness: %t (Logger Warning: expected string key, got *core.VariableNode) trueVar=true (Logger Warning: expected string key, got core.BoolValue) true=true
=== RUN   TestEvaluateCondition/String_Literal_True
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateConditionString_Literal_True625075669/001
    helpers.go:67: [DEBUG] -INTERP]        Condition node %T evaluated to %v (%T), truthiness: %t (Logger Warning: expected string key, got *core.StringLiteralNode) "true"=true (Logger Warning: expected string key, got core.StringValue) true=true
=== RUN   TestEvaluateCondition/String_Literal_Other
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateConditionString_Literal_Other2108184196/001
    helpers.go:67: [DEBUG] -INTERP]        Condition node %T evaluated to %v (%T), truthiness: %t (Logger Warning: expected string key, got *core.StringLiteralNode) "yes"=yes (Logger Warning: expected string key, got core.StringValue) yes=false
=== RUN   TestEvaluateCondition/Var_String_False
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateConditionVar_String_False2701419780/001
    helpers.go:67: [DEBUG] -INTERP]        Condition node %T evaluated to %v (%T), truthiness: %t (Logger Warning: expected string key, got *core.VariableNode) strFalse=false (Logger Warning: expected string key, got core.StringValue) false=false
=== RUN   TestEvaluateCondition/Comp_Numeric_Error_Types
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateConditionComp_Numeric_Error_Types466038597/001
--- PASS: TestEvaluateCondition (0.00s)
    --- PASS: TestEvaluateCondition/Boolean_Literal_True (0.00s)
    --- PASS: TestEvaluateCondition/Var_Boolean_True (0.00s)
    --- PASS: TestEvaluateCondition/String_Literal_True (0.00s)
    --- PASS: TestEvaluateCondition/String_Literal_Other (0.00s)
    --- PASS: TestEvaluateCondition/Var_String_False (0.00s)
    --- PASS: TestEvaluateCondition/Comp_Numeric_Error_Types (0.00s)
=== RUN   TestOnEventHandling
=== RUN   TestOnEventHandling/Basic_event_handler_sets_variable_from_payload
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=206
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> EnterOnEventStmt (push marker)
    helpers.go:67: [DEBUG] pushed *core.onEventStackMarker onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"user_login\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"user_login\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "user_login"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"user_login\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"user_login\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"user_login\"" (Pass through)
    helpers.go:67: [DEBUG] >>> Enter ON_EVENT_BODY Block (valDepth: 2)
    helpers.go:67: [DEBUG] ExitLvalue: payload_map
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Enter Expression: "data[\"payload\"]" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Primary: "data"
    helpers.go:67: [DEBUG]     Constructed VariableNode: data
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"payload\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"payload\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "payload"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"payload\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"payload\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"payload\"" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG]       Constructed ElementAccessNode: [Coll: *core.VariableNode Acc: *core.StringLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.ElementAccessNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]       Final Accessor_expr result pushed: *core.ElementAccessNode
    helpers.go:67: [DEBUG] --- Exit Power_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "data[\"payload\"]"
    helpers.go:67: [DEBUG] --- Exit Expression: "data[\"payload\"]" (Pass through)
    helpers.go:67: [DEBUG] popped *core.ElementAccessNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] ExitLvalue: login_name
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Enter Expression: "payload_map[\"username\"]" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Primary: "payload_map"
    helpers.go:67: [DEBUG]     Constructed VariableNode: payload_map
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"username\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"username\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "username"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"username\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"username\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"username\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"username\"" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG]       Constructed ElementAccessNode: [Coll: *core.VariableNode Acc: *core.StringLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.ElementAccessNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]       Final Accessor_expr result pushed: *core.ElementAccessNode
    helpers.go:67: [DEBUG] --- Exit Power_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "payload_map[\"username\"]"
    helpers.go:67: [DEBUG] --- Exit Expression: "payload_map[\"username\"]" (Pass through)
    helpers.go:67: [DEBUG] popped *core.ElementAccessNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] <<< Exit ON_EVENT_BODY Block (items: 2, valDepth: 2)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 3)
    helpers.go:67: [DEBUG] <<< ExitOnEventStmt (pop to marker)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.onEventStackMarker from value stack (new size: 0)
    helpers.go:67: [DEBUG]      Added on event declaration (event expr *core.StringLiteralNode)
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for main. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 0, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for main. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure main to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for main
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=handler activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=payload_map pos=line 3, col 13
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=login_name pos=line 4, col 13
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=testuser final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestOnEventHandling/Multiple_handlers_for_the_same_event
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=219
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> EnterOnEventStmt (push marker)
    helpers.go:67: [DEBUG] pushed *core.onEventStackMarker onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"test_event\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"test_event\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "test_event"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"test_event\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"test_event\"" (Pass through)
    helpers.go:67: [DEBUG] >>> Enter ON_EVENT_BODY Block (valDepth: 2)
    helpers.go:67: [DEBUG] ExitLvalue: var_a
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Enter Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] <<< Exit ON_EVENT_BODY Block (items: 1, valDepth: 2)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 3)
    helpers.go:67: [DEBUG] <<< ExitOnEventStmt (pop to marker)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.onEventStackMarker from value stack (new size: 0)
    helpers.go:67: [DEBUG]      Added on event declaration (event expr *core.StringLiteralNode)
    helpers.go:67: [DEBUG] >>> EnterOnEventStmt (push marker)
    helpers.go:67: [DEBUG] pushed *core.onEventStackMarker onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"test_event\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"test_event\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "test_event"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"test_event\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"test_event\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"test_event\"" (Pass through)
    helpers.go:67: [DEBUG] >>> Enter ON_EVENT_BODY Block (valDepth: 2)
    helpers.go:67: [DEBUG] ExitLvalue: var_b
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Enter Expression: "2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "2"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "2"
    helpers.go:67: [DEBUG]  >> Exit Literal: 2
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "2"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "2"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Expression: "2" (Pass through)
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] <<< Exit ON_EVENT_BODY Block (items: 1, valDepth: 2)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 3)
    helpers.go:67: [DEBUG] <<< ExitOnEventStmt (pop to marker)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.onEventStackMarker from value stack (new size: 0)
    helpers.go:67: [DEBUG]      Added on event declaration (event expr *core.StringLiteralNode)
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for main. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 0, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for main. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure main to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for main
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=handler activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=var_a pos=line 3, col 13
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=1 final_lastCallResultType=core.NumberValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=handler activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=var_b pos=line 7, col 13
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=2 final_lastCallResultType=core.NumberValue final_wasCleared=false
    evaluation_event_handler_test.go:95: Dumping variables after event emission to check state:
    testing_helpers.go:304: --- INTERPRETER VARIABLE DUMP ---
    testing_helpers.go:315:   - NEUROSCRIPT_DEVELOP_PROMPT (string) = "You are generating NeuroScript code based on the NeuroScript.g4 grammar (reflecting v0.5.0 features like line continuation).\nAdhere strictly to the following rules. Generate ONLY the raw code, with no explanations or markdown fences (using three backticks).\n**NeuroScript Syntax Rules (Reflecting NeuroScript.g4 v0.5.0 & Language Spec v0.3.0):**\n\n1.  **File Structure:** Optional '# comment' or '-- comment' lines. File-level ':: metadata' (e.g., ':: lang_version:', ':: file_version:') MUST be at the START of the file, before any procedure definitions. Follow with zero or more procedure definitions.\n2.  **Procedure Definition:** Start with 'func ProcedureName'. Follow with the signature part. Follow with 'means' keyword and a newline. End with 'endfunc'.\n3.  **Signature Part:** After 'ProcedureName', optionally include clauses 'needs param1, param2', 'optional opt1', 'returns ret1, ret2'. Parentheses '()' around these clauses are optional, for grouping only. If no clauses, nothing is needed between the name and 'means'.\n4.  **Metadata ('::')**: Procedure-level metadata (e.g., ':: description:', ':: param:<name>:', ':: return:<name>:') MUST be immediately after 'func ... means NEWLINE' and before the first statement. Step-level metadata immediately precedes the step. Use ':: key: value' format. Values can span lines using '\\' at line end. See docs/metadata.md for standard keys.\n5.  **Assignment ('set')**: Use 'set variable = expression'. Variable must be a valid identifier.\n6.  **Calls**: Procedure and tool calls are expressions. Use in assignments: 'set result = MyProcedure(arg)', 'set data = tool.ReadFile(\"path\")'. To call for side effects without assigning, MUST use the 'call' statement: 'call tool.LogMessage(\"Done\")'. An expression like 'MyProcedure()' on its own line is NOT valid.\n7.  **'last' Keyword**: Use 'last' keyword directly in an expression to refer to the result of the *most recent* successful procedure or tool call expression that produced a value.\n8.  **'eval(expr)' Function**: Use 'eval(expression)' explicitly to resolve '{{placeholder}}' syntax within the string *result* of the expression. Essential for resolving placeholders in standard quoted strings.\n9.  **Placeholders ('{{...}}')**: Syntax '{{varname}}' or '{{LAST}}' is auto-resolved within raw strings (```...```) during execution. Use 'eval()' to resolve them within standard quoted strings. Use bare 'varname' or 'last' directly in most other expression contexts.\n10. **Block Structure ('if', 'while', 'for each', 'on_error'):**\n    * Headers: 'if condition NEWLINE', 'while condition NEWLINE', 'for each var in collection NEWLINE', 'on_error means NEWLINE'. Note required newline.\n    * Body: One or more 'statement NEWLINE' or just 'newline'.\n    * Termination: Use 'endif', 'endwhile', 'endfor', 'endon' respectively.\n    * 'else': Optional 'else NEWLINE statement_list' within 'if'.\n11. **Looping ('while', 'for each')**:\n    * 'while condition ... endwhile': Executes body while condition is truthy.\n    * 'for each var in collection ... endfor': 'collection' expression must evaluate to list, map (iterates values), or string (iterates characters).\n    * 'break': Immediately exits the innermost loop.\n    * 'continue': Immediately skips to the next iteration of the innermost loop.\n12. **Literals**:\n    * Strings: '\"...\"' or \"'...'\" (support escapes like \\n, \\t; can span lines with '\\' at EOL).\n    * Raw Strings: '```...```' (Triple backticks; literal content including newlines, '{{...}}' placeholders evaluated on execution).\n    * Lists: '[expr, ...]' (elements are evaluated expressions).\n    * Maps: '{\"key\": expr, ...}' (keys MUST be string literals).\n    * Numbers: '123', '4.5' (parsed as int64 or float64).\n    * Booleans: 'true', 'false'.\n    * Nil: 'nil'.\n13. **Element Access**: Use 'collection_expr[accessor_expr]'.\n14. **Operators**: Standard precedence (Power '**' -> Unary '- not no some ~ typeof' -> Mul/Div/Mod '* / %' -> Add/Sub '+ -' -> Relational '> < >= <=' -> Equality '== !=' -> Bitwise '& ^ |' -> Logical 'and or'). Use '()' for grouping. '+' concatenates strings or adds numbers.\n15. **Built-in Functions**: Use math functions like 'ln(expr)', 'sin(expr)', etc., directly within expressions. Also 'typeof(expr)'.\n16. **Statements**: Valid statements are 'set', 'call', 'return', 'emit', 'must', 'mustbe', 'fail', 'clear_error', 'ask', 'if', 'while', 'for each', 'on_error', 'break', 'continue'.\n17. **'ask' Statement**: Use 'ask prompt_expr' or 'ask prompt_expr into variable'. Interacts with a configured AI agent.\n18. **Available 'tool's:** (Refer to 'tooldefs_*.go' or 'tool.Meta.ListTools()' for actual list & signatures) Examples: tool.FS.Read, tool.FS.Write, tool.AIWorker.ExecuteStatelessTask, tool.Git.Commit, tool.List.Length. Tool names can be qualified (e.g., tool.FS.Read). Do NOT invent tools or their arguments/return types.\n19. **Comments**: Use '#' or '--' for single-line comments (skipped by parser). Use '::' metadata for documentation.\n20. **Output Format**: Generate ONLY raw NeuroScript code. Start with optional file-level ':: metadata', then 'func' definitions. End each procedure with 'endfunc'. Ensure a final newline if content exists.\n21. **Tool Error Handling & Return Values (for Generation & Execution understanding):**\n    * **Primary Error Handling:** Interpreter-level errors during tool execution (Go panics, critical issues) typically trigger an 'on_error' block or halt the script. The direct result assigned in NeuroScript may be 'nil'.\n    * **Interpreting Successful Returns (Consult Tool Spec - e.g., tool.Meta.ListTools()):**\n        * Data-returning tools (e.g., 'tool.FS.Read', 'tool.Go.GetModuleInfo'): Assign result to a variable. A 'nil' result post-call (without 'on_error') might indicate an issue caught by the tool itself (e.g., file not found but not a panic). Otherwise, variable holds data (string, map, list, etc.).\n        * Side-effect tools (e.g., 'tool.FS.Write', 'tool.Git.Commit'): Often return a success message string (e.g., \"OK\", \"Commit successful...\") or nil on success. Presence of a non-nil string implies Go-level success. Do not assume specific string content unless documented for THAT tool.\n        * Map-returning tools (e.g., 'tool.AIWorker.ExecuteStatelessTask', 'tool.Shell.Execute'): If call succeeds (no interpreter error), inspect documented keys within the map for specific results ('output', 'error', 'status', 'stdout', 'stderr', etc.).\n        * Nil-returning tools (e.g., 'tool.AIWorkerDefinition.Remove'): If specified to return 'nil' on success, script continuation without error implies success.\n    * **Best Practices (Generation):** Use 'on_error ... endon' for unexpected failures. Use 'must' or 'if' checks on tool results (e.g., `must result != nil`, `if result_map[\"error\"] != nil`).\n22. **Line Continuation ('\\'):**\n    * **Code:** A '\\' at the very end of a line followed by a newline joins it with the next line for the parser (e.g., for long expressions or `if` conditions).\n    * **String Literals & Metadata Values:** A '\\' at the end of a line *within* a standard string ('\"...\"', \"'...'\"') or a metadata value allows it to span multiple physical lines; the '\\' and newline become part of the raw token, typically processed by the interpreter to join parts.\n    * **Raw Strings ('```...```'):** Do not use '\\' for line continuation; they inherently support multi-line content.\n\n**Global Constants** The following constants are injected into the global variable scope:\n\n1.  Development and Execution Prompts:\n    * NEUROSCRIPT_DEVELOP_PROMPT: (string) Contains the detailed PromptDevelop\n        text defined in this file. This is useful if a script needs to instruct an\n        AI to generate further NeuroScript code adhering to the same set of rules.\n    * NEUROSCRIPT_EXECUTE_PROMPT: (string) Contains the detailed PromptExecute\n        text. This might be used for advanced scenarios where a script reasons about\n        or simulates execution.\n\n2.  Standardized Type Strings:\n    These constants correspond to the string representation of types returned by\n    the typeof() built-in function. Using these constants for type comparisons\n    is more robust than using literal strings, as it protects against typos and\n    centralizes the type string definitions.\n\n    * TYPE_STRING:   (string) Represents the string \"string\".\n        Example: if typeof(my_var) == TYPE_STRING\n    * TYPE_NUMBER:   (string) Represents the string \"number\" (for both integers and floats).\n    * TYPE_BOOLEAN:  (string) Represents the string \"boolean\".\n    * TYPE_LIST:     (string) Represents the string \"list\".\n    * TYPE_MAP:      (string) Represents the string \"map\".\n    * TYPE_NIL:      (string) Represents the string \"nil\".\n    * TYPE_FUNCTION: (string) Represents the string \"function\" (for user-defined procedures).\n    * TYPE_TOOL:     (string) Represents the string \"tool\" (for registered tools).\n    * TYPE_ERROR:    (string) Represents the string \"error\" (for error objects/values).\n    * TYPE_UNKNOWN:  (string) Represents the string \"unknown\" (for types not otherwise classified).\n\nUsage Example in NeuroScript:\n\nfunc CheckVariableType(needs some_variable) means\n  :: description: Checks the type of a variable and emits it.\n  set var_type = typeof(some_variable)\n  emit \"The variable is of type: \" + var_type\n\n  if var_type == TYPE_LIST\n    emit \"It's a list! Processing each item...\"\n    for each item in some_variable\n      emit \"Item: \" + item\n    endfor\n  else\n    if var_type == TYPE_STRING\n      emit \"It's a string with length: \" + tool.Length(some_variable)\n    endif\n  endif\nendfunc\n\n**Illustrative Examples:**\n\n:: lang_version: neuroscript@0.5.0\n:: file_version: 1.0.1\n:: purpose: Basic NeuroScript file and function example.\n\nfunc GreetUser(needs user_name returns greeting_message) means\n  :: description: Creates a personalized greeting.\n  :: param:user_name: The name of the user.\n  :: return:greeting_message: The composed greeting string.\n\n  set greeting_message = \"Hello, \" + user_name + \"! Welcome to NeuroScript.\"\n  return greeting_message\nendfunc\n\n\nfunc CheckValue(needs input_value) means\n  :: description: Demonstrates if/else if/else logic.\n  if input_value > 100\n    emit \"Value is greater than 100.\"\n  else\n    if input_value > 50\n      emit \"Value is greater than 50 but not over 100.\"\n    else\n      emit \"Value is 50 or less.\"\n    endif\n  endif\nendfunc\n\n\nfunc ProcessFiles(needs directory, file_suffix) means\n  :: description: Lists files, filters by suffix, and reads content.\n  :: param:directory: The directory to scan.\n  :: param:file_suffix: The suffix to filter files by (e.g., \".txt\").\n\n  on_error means\n    emit \"An error occurred during file processing: \" + last # 'last' might hold error info from tool\n    fail \"File processing failed.\"\n  endon\n\n  set all_entries = tool.FS.List(directory)\n  must typeof(all_entries) == \"list\" # Ensure FS.List returned a list\n\n  set matching_files_contents = []\n  for each entry_map in all_entries\n    set entry_name = entry_map[\"name\"]\n    set is_dir = entry_map[\"isDir\"]\n\n    if not is_dir and tool.HasSuffix(entry_name, file_suffix)\n      set file_path = directory + \"/\" + entry_name\n      emit \"Reading file: \" + file_path\n      set content = tool.FS.Read(file_path)\n      if content != nil and typeof(content) == \"string\"\n        set matching_files_contents = tool.List.Append(matching_files_contents, content)\n      else\n        emit \"[WARN] Could not read or content invalid for: \" + file_path\n      endif\n    endif\n  endfor\n\n  emit \"Total matching files processed: \" + tool.List.Length(matching_files_contents)\n  # Further processing of matching_files_contents could happen here\n  return matching_files_contents\nendfunc\n\n\nfunc QueryAIAboutUser(needs user_id, user_name, task_description, ai_worker_def) returns ai_response means\n  :: description: Uses raw strings, eval, and 'ask' for an AI query.\n  :: param:user_id: The ID of the user.\n  :: param:user_name: The name of the user.\n  :: param:task_description: The task for the AI.\n  :: param:ai_worker_def: Name of the AI worker definition to use.\n\n  set context_info_raw = ```User ID is {{user_id}}. User name is {{user_name}}.```\n  # 'context_info_raw' now holds \"User ID is <actual_user_id>. User name is <actual_user_name>.\"\n\n  set prompt_template_std = \"Based on the context: {{CONTEXT}}, please {{TASK}}.\"\n  set intermediate_prompt = tool.StrReplaceAll(prompt_template_std, \"{{CONTEXT}}\", context_info_raw)\n  set final_prompt = eval(tool.StrReplaceAll(intermediate_prompt, \"{{TASK}}\", task_description))\n  # 'final_prompt' has all placeholders resolved.\n\n  emit \"Sending to AI (\" + ai_worker_def + \"): \" + final_prompt\n  ask final_prompt into ai_response\n\n  if ai_response == nil or ai_response == \"\"\n    emit \"[WARN] AI returned no response or an empty response.\"\n    return \"AI query failed to yield a response.\"\n  endif\n  return ai_response\nendfunc\n\n\n:: file_version: 1.2.0\n:: purpose: Demonstrate line continuation for code and strings.\n\nfunc CalculateComplexValue(needs val1, val2, val3, val4, val5) returns final_result means\n  :: description: Shows line continuation in a complex expression.\n  set intermediate_sum = val1 + val2 + \\\n                         val3 - val4\n\n  if intermediate_sum > 100 and \\\n     val5 < 50 or \\\n     val1 == val2\n    set final_result = intermediate_sum * val5\n  else\n    set final_result = intermediate_sum + val5\n  endif\n\n  set long_message = \"The calculation for values (\" + val1 + \", \" + val2 + \", \" + val3 + \", \" + val4 + \", \" + val5 + \") \\\nhas been completed and the intermediate sum was: \" + intermediate_sum + \". \\\nThe final result is: \" + final_result + \".\"\n  emit long_message\n  return final_result\nendfunc\n\n\nfunc ExecuteRemoteTask(needs worker_name, command_prompt) returns status_summary means\n  :: description: Example of calling a tool that returns a map and checking its fields.\n  :: param:worker_name: The AI worker definition for the task.\n  :: param:command_prompt: The prompt to send to the worker.\n\n  set task_result_map = tool.AIWorker.ExecuteStatelessTask(worker_name, command_prompt, nil)\n\n  if task_result_map == nil or typeof(task_result_map) != \"map\"\n    emit \"[ERROR] AIWorker task for '\" + worker_name + \"' returned nil or non-map.\"\n    fail \"AI task did not return a valid map.\"\n  endif\n\n  set output_content = task_result_map[\"output\"] # Expected key for successful output\n  set error_message = task_result_map[\"error\"]   # Expected key for error message\n\n  if error_message != nil and typeof(error_message) == \"string\" and error_message != \"\"\n    emit \"[ERROR] AIWorker task '\" + worker_name + \"' reported error: \" + error_message\n    set status_summary = \"Task failed: \" + error_message\n  else\n    if output_content != nil and typeof(output_content) == \"string\"\n      emit \"[INFO] AIWorker task '\" + worker_name + \"' successful. Output preview: \" + tool.Substring(output_content, 0, 50)\n      # Assuming 'output_content' is the primary successful result.\n      # Potentially write 'output_content' to a file or process further.\n      set status_summary = \"Task Succeeded. Output length: \" + tool.Length(output_content)\n    else\n      emit \"[WARN] AIWorker task '\" + worker_name + \"' had no error message, but output was nil or not a string. Type: \" + typeof(output_content)\n      set status_summary = \"Task completed with unexpected output format.\"\n    endif\n  endif\n  return status_summary\nendfunc\n"
    testing_helpers.go:315:   - NEUROSCRIPT_EXECUTE_PROMPT (string) = "You are executing the provided NeuroScript procedure step-by-step based on the NeuroScript.g4 grammar (v0.5.0 features). Track variable state precisely.\nKey execution points:\n\n* **'set var = expr'**: Evaluate 'expr' (raw value: string, int64, float64, bool, list, map, or nil). Store in 'var'. Placeholders '{{...}}' in standard strings remain literal unless 'eval()'. Raw strings ('```...```') with '{{...}}' ARE evaluated on use/assignment.\n* **Calls (Expressions & 'call' statement)**: Evaluate args (raw), execute Procedure/TOOL.Function. Return value (raw) available for expression, also stored in 'last'. 'call MyProc()' discards return (still populates 'last').\n* **'last'**: Keyword evaluates to raw value from most recent successful call (procedure/tool) or 'call' statement.\n* **'eval(expr)'**: Evaluate 'expr' (must be string). Recursively resolve '{{placeholder}}' within that string using current var/'last' values. Returns final resolved string.\n* **Placeholders ('{{...}}')**: Resolved via 'eval()' or implicitly in raw strings. Otherwise, likely literal.\n* **'if cond ... [else ...] endif'**: Evaluate 'cond'. Truthiness: true, non-zero numbers, \"true\"/\"1\" are true; false, 0, other strings, nil, empty collections are false. Execute relevant block.\n* **'while cond ... endwhile'**: Evaluate 'cond'. Repeat block if truthy. 'break' exits, 'continue' skips to next iteration.\n* **'for each var in coll ... endfor'**: Evaluate 'coll'. Iterate list elements, map values, or string chars. Assign item to 'var'. 'break' exits, 'continue' skips.\n* **'on_error means ... endon'**: Jumps here on runtime error. 'clear_error' resets error state. Otherwise, error propagates post-block.\n* **List/Map Literals**: '[...]' -> []interface{} (raw elements). '{ \"key\": expr, ... }' -> map[string]interface{} (raw values, literal keys).\n* **Element Access**: 'list[index_expr]' (index_expr to int64). 'map[key_expr]' (key_expr to string). Error if OOB, key not found, or wrong type.\n* **Operators**: Standard precedence. '+' concatenates if any operand is string (converts non-strings), else adds. Others: arithmetic, comparison, bitwise, logical ('and', 'or', 'not', 'no', 'some', '~'), power ('**'), 'typeof'.\n* **Built-in Functions**: 'ln(num)', 'sin(num)', 'typeof(val)' etc. - Evaluate arg(s), call corresponding function.\n* **'return expr?'**: Evaluate 'expr' (raw), stop procedure, return value (or nil).\n* **'emit expr'**: Evaluate 'expr' (placeholders resolved as if via 'eval'), print string representation.\n* **'must expr' / 'mustbe check()'**: Evaluate condition. Halt with error if false.\n* **'fail expr?'**: Evaluate message, halt with error.\n* **'ask prompt [into var]'**: Evaluate prompt (placeholders resolved). Send to AI. If 'into var', store text response. Result in 'last'.\n* **Metadata/Comments**: '::', '#', '--' ignored for execution flow.\n21. **Tool Error Handling & Return Values (for Generation & Execution understanding):**\n    * **Primary Error Handling:** Interpreter-level errors during tool execution (Go panics, critical issues) typically trigger an 'on_error' block or halt the script. The direct result assigned in NeuroScript may be 'nil'.\n    * **Interpreting Successful Returns (Consult Tool Spec - e.g., tool.Meta.ListTools()):**\n        * Data-returning tools (e.g., 'tool.FS.Read', 'tool.Go.GetModuleInfo'): Assign result to a variable. A 'nil' result post-call (without 'on_error') might indicate an issue caught by the tool itself (e.g., file not found but not a panic). Otherwise, variable holds data (string, map, list, etc.).\n        * Side-effect tools (e.g., 'tool.FS.Write', 'tool.Git.Commit'): Often return a success message string (e.g., \"OK\", \"Commit successful...\") or nil on success. Presence of a non-nil string implies Go-level success. Do not assume specific string content unless documented for THAT tool.\n        * Map-returning tools (e.g., 'tool.AIWorker.ExecuteStatelessTask', 'tool.Shell.Execute'): If call succeeds (no interpreter error), inspect documented keys within the map for specific results ('output', 'error', 'status', 'stdout', 'stderr', etc.).\n        * Nil-returning tools (e.g., 'tool.AIWorkerDefinition.Remove'): If specified to return 'nil' on success, script continuation without error implies success.\n    * **Best Practices (Generation):** Use 'on_error ... endon' for unexpected failures. Use 'must' or 'if' checks on tool results (e.g., `must result != nil`, `if result_map[\"error\"] != nil`).\nExecute step-by-step, maintain variable state, handle 'last', determine final 'RETURN' value or error outcome.\n\n**Consider these examples during execution analysis:**\n\n:: lang_version: neuroscript@0.5.0\n:: file_version: 1.0.1\n:: purpose: Basic NeuroScript file and function example.\n\nfunc GreetUser(needs user_name returns greeting_message) means\n  :: description: Creates a personalized greeting.\n  :: param:user_name: The name of the user.\n  :: return:greeting_message: The composed greeting string.\n\n  set greeting_message = \"Hello, \" + user_name + \"! Welcome to NeuroScript.\"\n  return greeting_message\nendfunc\n\n\nfunc CheckValue(needs input_value) means\n  :: description: Demonstrates if/else if/else logic.\n  if input_value > 100\n    emit \"Value is greater than 100.\"\n  else\n    if input_value > 50\n      emit \"Value is greater than 50 but not over 100.\"\n    else\n      emit \"Value is 50 or less.\"\n    endif\n  endif\nendfunc\n\n\nfunc ProcessFiles(needs directory, file_suffix) means\n  :: description: Lists files, filters by suffix, and reads content.\n  :: param:directory: The directory to scan.\n  :: param:file_suffix: The suffix to filter files by (e.g., \".txt\").\n\n  on_error means\n    emit \"An error occurred during file processing: \" + last # 'last' might hold error info from tool\n    fail \"File processing failed.\"\n  endon\n\n  set all_entries = tool.FS.List(directory)\n  must typeof(all_entries) == \"list\" # Ensure FS.List returned a list\n\n  set matching_files_contents = []\n  for each entry_map in all_entries\n    set entry_name = entry_map[\"name\"]\n    set is_dir = entry_map[\"isDir\"]\n\n    if not is_dir and tool.HasSuffix(entry_name, file_suffix)\n      set file_path = directory + \"/\" + entry_name\n      emit \"Reading file: \" + file_path\n      set content = tool.FS.Read(file_path)\n      if content != nil and typeof(content) == \"string\"\n        set matching_files_contents = tool.List.Append(matching_files_contents, content)\n      else\n        emit \"[WARN] Could not read or content invalid for: \" + file_path\n      endif\n    endif\n  endfor\n\n  emit \"Total matching files processed: \" + tool.List.Length(matching_files_contents)\n  # Further processing of matching_files_contents could happen here\n  return matching_files_contents\nendfunc\n\n\nfunc QueryAIAboutUser(needs user_id, user_name, task_description, ai_worker_def) returns ai_response means\n  :: description: Uses raw strings, eval, and 'ask' for an AI query.\n  :: param:user_id: The ID of the user.\n  :: param:user_name: The name of the user.\n  :: param:task_description: The task for the AI.\n  :: param:ai_worker_def: Name of the AI worker definition to use.\n\n  set context_info_raw = ```User ID is {{user_id}}. User name is {{user_name}}.```\n  # 'context_info_raw' now holds \"User ID is <actual_user_id>. User name is <actual_user_name>.\"\n\n  set prompt_template_std = \"Based on the context: {{CONTEXT}}, please {{TASK}}.\"\n  set intermediate_prompt = tool.StrReplaceAll(prompt_template_std, \"{{CONTEXT}}\", context_info_raw)\n  set final_prompt = eval(tool.StrReplaceAll(intermediate_prompt, \"{{TASK}}\", task_description))\n  # 'final_prompt' has all placeholders resolved.\n\n  emit \"Sending to AI (\" + ai_worker_def + \"): \" + final_prompt\n  ask final_prompt into ai_response\n\n  if ai_response == nil or ai_response == \"\"\n    emit \"[WARN] AI returned no response or an empty response.\"\n    return \"AI query failed to yield a response.\"\n  endif\n  return ai_response\nendfunc\n\n\n:: file_version: 1.2.0\n:: purpose: Demonstrate line continuation for code and strings.\n\nfunc CalculateComplexValue(needs val1, val2, val3, val4, val5) returns final_result means\n  :: description: Shows line continuation in a complex expression.\n  set intermediate_sum = val1 + val2 + \\\n                         val3 - val4\n\n  if intermediate_sum > 100 and \\\n     val5 < 50 or \\\n     val1 == val2\n    set final_result = intermediate_sum * val5\n  else\n    set final_result = intermediate_sum + val5\n  endif\n\n  set long_message = \"The calculation for values (\" + val1 + \", \" + val2 + \", \" + val3 + \", \" + val4 + \", \" + val5 + \") \\\nhas been completed and the intermediate sum was: \" + intermediate_sum + \". \\\nThe final result is: \" + final_result + \".\"\n  emit long_message\n  return final_result\nendfunc\n\n\nfunc ExecuteRemoteTask(needs worker_name, command_prompt) returns status_summary means\n  :: description: Example of calling a tool that returns a map and checking its fields.\n  :: param:worker_name: The AI worker definition for the task.\n  :: param:command_prompt: The prompt to send to the worker.\n\n  set task_result_map = tool.AIWorker.ExecuteStatelessTask(worker_name, command_prompt, nil)\n\n  if task_result_map == nil or typeof(task_result_map) != \"map\"\n    emit \"[ERROR] AIWorker task for '\" + worker_name + \"' returned nil or non-map.\"\n    fail \"AI task did not return a valid map.\"\n  endif\n\n  set output_content = task_result_map[\"output\"] # Expected key for successful output\n  set error_message = task_result_map[\"error\"]   # Expected key for error message\n\n  if error_message != nil and typeof(error_message) == \"string\" and error_message != \"\"\n    emit \"[ERROR] AIWorker task '\" + worker_name + \"' reported error: \" + error_message\n    set status_summary = \"Task failed: \" + error_message\n  else\n    if output_content != nil and typeof(output_content) == \"string\"\n      emit \"[INFO] AIWorker task '\" + worker_name + \"' successful. Output preview: \" + tool.Substring(output_content, 0, 50)\n      # Assuming 'output_content' is the primary successful result.\n      # Potentially write 'output_content' to a file or process further.\n      set status_summary = \"Task Succeeded. Output length: \" + tool.Length(output_content)\n    else\n      emit \"[WARN] AIWorker task '\" + worker_name + \"' had no error message, but output was nil or not a string. Type: \" + typeof(output_content)\n      set status_summary = \"Task completed with unexpected output format.\"\n    endif\n  endif\n  return status_summary\nendfunc\n"
    testing_helpers.go:315:   - TYPE_BOOLEAN (string) = "boolean"
    testing_helpers.go:315:   - TYPE_ERROR (string) = "error"
    testing_helpers.go:315:   - TYPE_FUNCTION (string) = "function"
    testing_helpers.go:315:   - TYPE_LIST (string) = "list"
    testing_helpers.go:315:   - TYPE_MAP (string) = "map"
    testing_helpers.go:315:   - TYPE_NIL (string) = "nil"
    testing_helpers.go:315:   - TYPE_NUMBER (string) = "number"
    testing_helpers.go:315:   - TYPE_STRING (string) = "string"
    testing_helpers.go:315:   - TYPE_TOOL (string) = "tool"
    testing_helpers.go:315:   - TYPE_UNKNOWN (string) = "unknown"
    testing_helpers.go:315:   - var_a (core.NumberValue) = core.NumberValue{Value:1}
    testing_helpers.go:315:   - var_b (core.NumberValue) = core.NumberValue{Value:2}
    testing_helpers.go:318: --- END VARIABLE DUMP ---
=== RUN   TestOnEventHandling/Event_name_must_be_a_static_string
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=162
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for main. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: my_event
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"some_event\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"some_event\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "some_event"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"some_event\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"some_event\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"some_event\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for main. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure main to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for main
    helpers.go:67: [DEBUG] >>> EnterOnEventStmt (push marker)
    helpers.go:67: [DEBUG] pushed *core.onEventStackMarker onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "my_event" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "my_event"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Primary: "my_event"
    helpers.go:67: [DEBUG]     Constructed VariableNode: my_event
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "my_event"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "my_event"
    helpers.go:67: [DEBUG] --- Exit Expression: "my_event" (Pass through)
    helpers.go:67: [DEBUG] >>> Enter ON_EVENT_BODY Block (valDepth: 2)
    helpers.go:67: [DEBUG] ExitLvalue: x
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Enter Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] <<< Exit ON_EVENT_BODY Block (items: 1, valDepth: 2)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 3)
    helpers.go:67: [DEBUG] <<< ExitOnEventStmt (pop to marker)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.onEventStackMarker from value stack (new size: 0)
    helpers.go:67: [ERROR] AST Builder Error pos=line 6, col 18 message=Event name must be a static string literal, not a variable (my_event)
    helpers.go:67: [DEBUG]      Added on event declaration (event expr *core.VariableNode)
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [ERROR] AST Builder: Failing build error=AST build failed with 1 error(s): AST build error near line 6, col 18: Event name must be a static string literal, not a variable (my_event)
--- PASS: TestOnEventHandling (0.00s)
    --- PASS: TestOnEventHandling/Basic_event_handler_sets_variable_from_payload (0.00s)
    --- PASS: TestOnEventHandling/Multiple_handlers_for_the_same_event (0.00s)
    --- PASS: TestOnEventHandling/Event_name_must_be_a_static_string (0.00s)
=== RUN   TestMathFunctions
=== RUN   TestMathFunctions/LN(e)
=== PAUSE TestMathFunctions/LN(e)
=== RUN   TestMathFunctions/LN(1)
=== PAUSE TestMathFunctions/LN(1)
=== RUN   TestMathFunctions/LN(0)
=== PAUSE TestMathFunctions/LN(0)
=== RUN   TestMathFunctions/LN(-1)
=== PAUSE TestMathFunctions/LN(-1)
=== RUN   TestMathFunctions/LN_Type_Error
=== PAUSE TestMathFunctions/LN_Type_Error
=== RUN   TestMathFunctions/LN_Arg_Count_Error
=== PAUSE TestMathFunctions/LN_Arg_Count_Error
=== RUN   TestMathFunctions/LOG(10)
=== PAUSE TestMathFunctions/LOG(10)
=== RUN   TestMathFunctions/LOG(1)
=== PAUSE TestMathFunctions/LOG(1)
=== RUN   TestMathFunctions/LOG(0)
=== PAUSE TestMathFunctions/LOG(0)
=== RUN   TestMathFunctions/LOG_Type_Error
=== PAUSE TestMathFunctions/LOG_Type_Error
=== RUN   TestMathFunctions/SIN(Pi/2)
=== PAUSE TestMathFunctions/SIN(Pi/2)
=== RUN   TestMathFunctions/SIN(0)
=== PAUSE TestMathFunctions/SIN(0)
=== RUN   TestMathFunctions/COS(Pi/2)
=== PAUSE TestMathFunctions/COS(Pi/2)
=== RUN   TestMathFunctions/COS(0)
=== PAUSE TestMathFunctions/COS(0)
=== RUN   TestMathFunctions/TAN(0)
=== PAUSE TestMathFunctions/TAN(0)
=== RUN   TestMathFunctions/SIN_Type_Error
=== PAUSE TestMathFunctions/SIN_Type_Error
=== RUN   TestMathFunctions/ASIN(1)
=== PAUSE TestMathFunctions/ASIN(1)
=== RUN   TestMathFunctions/ASIN(0)
=== PAUSE TestMathFunctions/ASIN(0)
=== RUN   TestMathFunctions/ASIN(2)
=== PAUSE TestMathFunctions/ASIN(2)
=== RUN   TestMathFunctions/ACOS(1)
=== PAUSE TestMathFunctions/ACOS(1)
=== RUN   TestMathFunctions/ACOS(0)
=== PAUSE TestMathFunctions/ACOS(0)
=== RUN   TestMathFunctions/ACOS(-1)
=== PAUSE TestMathFunctions/ACOS(-1)
=== RUN   TestMathFunctions/ACOS(2)
=== PAUSE TestMathFunctions/ACOS(2)
=== RUN   TestMathFunctions/ASIN_Type_Error
=== PAUSE TestMathFunctions/ASIN_Type_Error
=== RUN   TestMathFunctions/ATAN(0)
=== PAUSE TestMathFunctions/ATAN(0)
=== RUN   TestMathFunctions/ATAN(1)
=== PAUSE TestMathFunctions/ATAN(1)
=== RUN   TestMathFunctions/ATAN_Type_Error
=== PAUSE TestMathFunctions/ATAN_Type_Error
=== RUN   TestMathFunctions/Unknown_Func
=== PAUSE TestMathFunctions/Unknown_Func
=== CONT  TestMathFunctions/LN(e)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/TAN(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ACOS(-1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LN(e)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLN(e)2438784166/001
=== CONT  TestMathFunctions/ASIN(2)
=== CONT  TestMathFunctions/ACOS(0)
=== NAME  TestMathFunctions/ASIN(2)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/TAN(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsTAN(0)3445323393/001
=== NAME  TestMathFunctions/ACOS(-1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsACOS(-1)3596612487/001
=== NAME  TestMathFunctions/ACOS(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ACOS(1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/ACOS(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsACOS(0)2734079342/001
=== CONT  TestMathFunctions/LOG(1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/ACOS(1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsACOS(1)3366015510/001
=== CONT  TestMathFunctions/LN_Type_Error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/COS(0)
=== NAME  TestMathFunctions/ASIN(2)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsASIN(2)309330859/001
=== CONT  TestMathFunctions/COS(Pi/2)
=== NAME  TestMathFunctions/COS(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LN_Type_Error
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLN_Type_Error3554126768/001
=== NAME  TestMathFunctions/COS(Pi/2)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/SIN(Pi/2)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/LN_Arg_Count_Error
=== CONT  TestMathFunctions/LOG_Type_Error
=== CONT  TestMathFunctions/LOG(0)
=== NAME  TestMathFunctions/COS(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsCOS(0)3659118162/001
=== NAME  TestMathFunctions/LOG(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LOG(1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLOG(1)610081392/001
=== CONT  TestMathFunctions/SIN(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/LOG(10)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/SIN(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsSIN(0)3844170223/001
=== NAME  TestMathFunctions/LOG(10)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLOG(10)3551467135/001
=== NAME  TestMathFunctions/LOG_Type_Error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ASIN(0)
=== NAME  TestMathFunctions/COS(Pi/2)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsCOS(Pi2)1347070735/001
=== NAME  TestMathFunctions/LOG(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLOG(0)4234893322/001
=== NAME  TestMathFunctions/SIN(Pi/2)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsSIN(Pi2)1103452437/001
=== NAME  TestMathFunctions/LN_Arg_Count_Error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ASIN(1)
=== CONT  TestMathFunctions/LN(0)
=== NAME  TestMathFunctions/ASIN(1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LN(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LOG_Type_Error
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLOG_Type_Error815793099/001
=== NAME  TestMathFunctions/ASIN(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LN_Arg_Count_Error
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLN_Arg_Count_Error3700465050/001
=== CONT  TestMathFunctions/LN(-1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/ASIN(1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsASIN(1)4131540393/001
=== NAME  TestMathFunctions/LN(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLN(0)3001458364/001
=== NAME  TestMathFunctions/ASIN(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsASIN(0)3354718073/001
=== CONT  TestMathFunctions/SIN_Type_Error
=== NAME  TestMathFunctions/LN(-1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLN(-1)605043624/001
=== NAME  TestMathFunctions/SIN_Type_Error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/Unknown_Func
=== CONT  TestMathFunctions/ATAN_Type_Error
=== CONT  TestMathFunctions/ATAN(0)
=== NAME  TestMathFunctions/ATAN_Type_Error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/ATAN(0)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/SIN_Type_Error
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsSIN_Type_Error1917030185/001
=== NAME  TestMathFunctions/Unknown_Func
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ATAN(1)
=== NAME  TestMathFunctions/ATAN_Type_Error
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsATAN_Type_Error1844877072/001
=== NAME  TestMathFunctions/ATAN(1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ACOS(2)
=== CONT  TestMathFunctions/LN(1)
=== NAME  TestMathFunctions/ATAN(0)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsATAN(0)3141205310/001
=== NAME  TestMathFunctions/ACOS(2)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestMathFunctions/ASIN_Type_Error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/LN(1)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestMathFunctions/ATAN(1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsATAN(1)1983013555/001
=== NAME  TestMathFunctions/ACOS(2)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsACOS(2)70545268/001
=== NAME  TestMathFunctions/ASIN_Type_Error
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsASIN_Type_Error1311225779/001
=== NAME  TestMathFunctions/Unknown_Func
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsUnknown_Func3564645133/001
    helpers.go:67: [DEBUG] Running procedure name=SQRT caller=
    helpers.go:67: [DEBUG] Finished procedure name=SQRT caller=
=== NAME  TestMathFunctions/LN(1)
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestMathFunctionsLN(1)652042166/001
--- PASS: TestMathFunctions (0.00s)
    --- PASS: TestMathFunctions/TAN(0) (0.00s)
    --- PASS: TestMathFunctions/LN(e) (0.00s)
    --- PASS: TestMathFunctions/ACOS(-1) (0.00s)
    --- PASS: TestMathFunctions/ACOS(1) (0.00s)
    --- PASS: TestMathFunctions/ACOS(0) (0.00s)
    --- PASS: TestMathFunctions/ASIN(2) (0.00s)
    --- PASS: TestMathFunctions/LN_Type_Error (0.00s)
    --- PASS: TestMathFunctions/SIN(0) (0.00s)
    --- PASS: TestMathFunctions/LOG(10) (0.00s)
    --- PASS: TestMathFunctions/LOG(1) (0.00s)
    --- PASS: TestMathFunctions/LOG(0) (0.00s)
    --- PASS: TestMathFunctions/COS(0) (0.00s)
    --- PASS: TestMathFunctions/SIN(Pi/2) (0.00s)
    --- PASS: TestMathFunctions/LN(0) (0.00s)
    --- PASS: TestMathFunctions/LN_Arg_Count_Error (0.00s)
    --- PASS: TestMathFunctions/LOG_Type_Error (0.00s)
    --- PASS: TestMathFunctions/ASIN(0) (0.00s)
    --- PASS: TestMathFunctions/LN(-1) (0.00s)
    --- PASS: TestMathFunctions/COS(Pi/2) (0.00s)
    --- PASS: TestMathFunctions/ATAN(1) (0.00s)
    --- PASS: TestMathFunctions/SIN_Type_Error (0.00s)
    --- PASS: TestMathFunctions/ASIN(1) (0.00s)
    --- PASS: TestMathFunctions/ATAN(0) (0.00s)
    --- PASS: TestMathFunctions/ATAN_Type_Error (0.00s)
    --- PASS: TestMathFunctions/ACOS(2) (0.00s)
    --- PASS: TestMathFunctions/Unknown_Func (0.00s)
    --- PASS: TestMathFunctions/ASIN_Type_Error (0.00s)
    --- PASS: TestMathFunctions/LN(1) (0.00s)
=== RUN   TestLogicalBitwiseOps
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLogicalBitwiseOps2649180674/001
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLogicalBitwiseOps2649180674/002
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLogicalBitwiseOps2649180674/003
--- PASS: TestLogicalBitwiseOps (0.00s)
=== RUN   TestNewTypesIntegration
=== RUN   TestNewTypesIntegration/TypeOf_New_Types
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestNewTypesIntegrationTypeOf_New_Types281715293/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: TestNewTypesIntegration_TypeOf_New_Types
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=165
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for TestNewTypesIntegration_TypeOf_New_Types. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: t
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Time.Now()" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Time.Now"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Time.Now
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Time.Now', Pos: line 3, col 17
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Time.Now, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Time.Now
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Time.Now
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Time.Now, Args=0
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Time.Now()"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Time.Now()" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: e
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Error.New(404,\"not found\")" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Error.New"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Error.New
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Error.New', Pos: line 4, col 17
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Error.New, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Error.New
    helpers.go:67: [DEBUG] --- Enter Expression: "404" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "404"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "404"
    helpers.go:67: [DEBUG]  >> Exit Literal: 404
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "404"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "404"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "404"
    helpers.go:67: [DEBUG] --- Exit Expression: "404" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"not found\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"not found\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "not found"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"not found\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"not found\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"not found\"" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] popped 2 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Error.New
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Error.New, Args=2
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Error.New(404,\"not found\")"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Error.New(404,\"not found\")" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "typeof(t)" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "(t)"
    helpers.go:67: [DEBUG] --- Enter Expression: "t" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "t"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Primary: "t"
    helpers.go:67: [DEBUG]     Constructed VariableNode: t
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "t"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "t"
    helpers.go:67: [DEBUG] --- Exit Expression: "t" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Primary: "(t)"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "(t)"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "(t)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "(t)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "typeof(t)"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.TypeOfNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "typeof(t)"
    helpers.go:67: [DEBUG] --- Exit Expression: "typeof(t)" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "typeof(e)" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "(e)"
    helpers.go:67: [DEBUG] --- Enter Expression: "e" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "e"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Primary: "e"
    helpers.go:67: [DEBUG]     Constructed VariableNode: e
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "e"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "e"
    helpers.go:67: [DEBUG] --- Exit Expression: "e" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Primary: "(e)"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "(e)"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "(e)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "(e)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "typeof(e)"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] pushed *core.TypeOfNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "typeof(e)"
    helpers.go:67: [DEBUG] --- Exit Expression: "typeof(e)" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.TypeOfNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 3, valDepth: 1)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 2)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 1)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=[{line 3, col 4 set t tool.Time.Now() <nil> <nil> [] []  <nil> <nil>  []} {line 4, col 4 set e tool.Error.New(404, "not found") <nil> <nil> [] []  <nil> <nil>  []} {line 5, col 4 return <nil> <nil> <nil> <nil> [] []  <nil> <nil>  [typeof(e)]}]
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for TestNewTypesIntegration_TypeOf_New_Types. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped *core.TypeOfNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure TestNewTypesIntegration_TypeOf_New_Types to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for TestNewTypesIntegration_TypeOf_New_Types
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=RETURN subject=returning 1 values pos=line 5, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 5, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 5, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[nil] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.ListValue script_name:TestNewTypesIntegration_TypeOf_New_Types]
    evaluation_new_types_test.go:67: Expected a slice of 2 results, got [nil] ([]interface {})
=== RUN   TestNewTypesIntegration/Timedate_Comparison
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestNewTypesIntegrationTimedate_Comparison2639552352/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: TestNewTypesIntegration_Timedate_Comparison
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=253
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for TestNewTypesIntegration_Timedate_Comparison. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: t1
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Time.Now()" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Time.Now"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Time.Now
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Time.Now', Pos: line 3, col 18
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Time.Now, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Time.Now
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Time.Now
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Time.Now, Args=0
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Time.Now()"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Time.Now()" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Time.Sleep"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Time.Sleep
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Time.Sleep', Pos: line 5, col 14
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Time.Sleep, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 1)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Time.Sleep
    helpers.go:67: [DEBUG] --- Enter Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Time.Sleep(1)"
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Time.Sleep
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Time.Sleep, Args=1
    helpers.go:67: [DEBUG] <<< ExitCall_statement
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: t2
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Time.Now()" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Time.Now"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Time.Now
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Time.Now', Pos: line 6, col 18
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Time.Now, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Time.Now
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Time.Now
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Time.Now, Args=0
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Time.Now()"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Time.Now()"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Time.Now()" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "t1<t2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "t1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Primary: "t1"
    helpers.go:67: [DEBUG]     Constructed VariableNode: t1
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "t1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "t1"
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "t2"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Primary: "t2"
    helpers.go:67: [DEBUG]     Constructed VariableNode: t2
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "t2"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "t1<t2"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode < *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "t1<t2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "t1<t2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "t1<t2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "t1<t2"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "t1<t2"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "t1<t2"
    helpers.go:67: [DEBUG] --- Exit Expression: "t1<t2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "t1<=t2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "t1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Primary: "t1"
    helpers.go:67: [DEBUG]     Constructed VariableNode: t1
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "t1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "t1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "t1"
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "t2"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Primary: "t2"
    helpers.go:67: [DEBUG]     Constructed VariableNode: t2
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "t2"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "t2"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "t1<=t2"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode <= *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "t1<=t2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "t1<=t2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "t1<=t2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "t1<=t2"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "t1<=t2"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "t1<=t2"
    helpers.go:67: [DEBUG] --- Exit Expression: "t1<=t2" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 4, valDepth: 1)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 2)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 1)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=[{line 3, col 4 set t1 tool.Time.Now() <nil> <nil> [] []  <nil> <nil>  []} {line 5, col 4 call <nil> <nil> tool.Time.Sleep(1) <nil> [] []  <nil> <nil>  []} {line 6, col 4 set t2 tool.Time.Now() <nil> <nil> [] []  <nil> <nil>  []} {line 7, col 4 return <nil> <nil> <nil> <nil> [] []  <nil> <nil>  [(t1 <= t2)]}]
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for TestNewTypesIntegration_Timedate_Comparison. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure TestNewTypesIntegration_Timedate_Comparison to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for TestNewTypesIntegration_Timedate_Comparison
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=RETURN subject=returning 1 values pos=line 7, col 14
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 7, col 14
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 7, col 14
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=<nil> returnValueType=<nil> wasReturn=true err=NeuroScript Error 9: evaluating return expression 1: variable 't1' not found at line 7, col 14 (wrapped: variable not found)
    helpers.go:82: [ERROR] Error executing script 'TestNewTypesIntegration_Timedate_Comparison': NeuroScript Error 9: evaluating return expression 1: variable 't1' not found at line 7, col 14 (wrapped: variable not found)
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:NeuroScript Error 9: evaluating return expression 1: variable 't1' not found at line 7, col 14 (wrapped: variable not found) restored_proc_name: result_type:<nil> script_name:TestNewTypesIntegration_Timedate_Comparison]
    evaluation_new_types_test.go:88: script execution failed: NeuroScript Error 9: evaluating return expression 1: variable 't1' not found at line 7, col 14 (wrapped: variable not found)
=== RUN   TestNewTypesIntegration/Fuzzy_Logic_Operators
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestNewTypesIntegrationFuzzy_Logic_Operators1527705702/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: TestNewTypesIntegration_Fuzzy_Logic_Operators
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=333
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for TestNewTypesIntegration_Fuzzy_Logic_Operators. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: f_true
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Test.NewFuzzy(0.8)" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Test.NewFuzzy"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Test.NewFuzzy
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Test.NewFuzzy', Pos: line 3, col 22
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Test.NewFuzzy, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Test.NewFuzzy
    helpers.go:67: [DEBUG] --- Enter Expression: "0.8" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0.8"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0.8"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0.8
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0.8"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0.8"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0.8"
    helpers.go:67: [DEBUG] --- Exit Expression: "0.8" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Test.NewFuzzy
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Test.NewFuzzy, Args=1
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Test.NewFuzzy(0.8)"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Test.NewFuzzy(0.8)" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: f_false
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Test.NewFuzzy(0.3)" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Test.NewFuzzy"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Test.NewFuzzy
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Test.NewFuzzy', Pos: line 4, col 23
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Test.NewFuzzy, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Test.NewFuzzy
    helpers.go:67: [DEBUG] --- Enter Expression: "0.3" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0.3"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0.3"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0.3
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0.3"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0.3"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0.3"
    helpers.go:67: [DEBUG] --- Exit Expression: "0.3" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Test.NewFuzzy
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Test.NewFuzzy, Args=1
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Test.NewFuzzy(0.3)"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Test.NewFuzzy(0.3)" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: res_not
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "notf_true" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Primary: "f_true"
    helpers.go:67: [DEBUG]     Constructed VariableNode: f_true
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "f_true"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "f_true"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "notf_true"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] pushed *core.UnaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed UnaryOpNode: not [*core.VariableNode]
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "notf_true"
    helpers.go:67: [DEBUG] --- Exit Expression: "notf_true" (Pass through)
    helpers.go:67: [DEBUG] popped *core.UnaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: res_and
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "f_trueandf_false" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "f_true"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Primary: "f_true"
    helpers.go:67: [DEBUG]     Constructed VariableNode: f_true
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "f_true"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "f_true"
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "f_false"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Primary: "f_false"
    helpers.go:67: [DEBUG]     Constructed VariableNode: f_false
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "f_false"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "f_trueandf_false"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode and *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "f_trueandf_false"
    helpers.go:67: [DEBUG] --- Exit Expression: "f_trueandf_false" (Pass through)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: res_or
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "f_trueorf_false" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "f_true"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Primary: "f_true"
    helpers.go:67: [DEBUG]     Constructed VariableNode: f_true
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "f_true"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "f_true"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "f_true"
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "f_false"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Primary: "f_false"
    helpers.go:67: [DEBUG]     Constructed VariableNode: f_false
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "f_false"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "f_trueorf_false"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode or *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Expression: "f_trueorf_false" (Pass through)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: res_mixed
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "f_falseortrue" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "f_false"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Primary: "f_false"
    helpers.go:67: [DEBUG]     Constructed VariableNode: f_false
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "f_false"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "f_false"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "f_false"
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "true"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "true"
    helpers.go:67: [DEBUG]  >> Exit BooleanLiteral: true
    helpers.go:67: [DEBUG] pushed *core.BooleanLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit BooleanLiteral, Pushed Node: *core.BooleanLiteralNode
    helpers.go:67: [DEBUG]  >> Exit Literal: true
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "true"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "true"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "true"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "f_falseortrue"
    helpers.go:67: [DEBUG] popped *core.BooleanLiteralNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode or *core.BooleanLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Expression: "f_falseortrue" (Pass through)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "res_not" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "res_not"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Primary: "res_not"
    helpers.go:67: [DEBUG]     Constructed VariableNode: res_not
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "res_not"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "res_not"
    helpers.go:67: [DEBUG] --- Exit Expression: "res_not" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "res_and" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "res_and"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Primary: "res_and"
    helpers.go:67: [DEBUG]     Constructed VariableNode: res_and
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "res_and"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "res_and"
    helpers.go:67: [DEBUG] --- Exit Expression: "res_and" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "res_or" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "res_or"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Primary: "res_or"
    helpers.go:67: [DEBUG]     Constructed VariableNode: res_or
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "res_or"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "res_or"
    helpers.go:67: [DEBUG] --- Exit Expression: "res_or" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "res_mixed" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Primary: "res_mixed"
    helpers.go:67: [DEBUG]     Constructed VariableNode: res_mixed
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "res_mixed"
    helpers.go:67: [DEBUG] --- Exit Expression: "res_mixed" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 7, valDepth: 3)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 4)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 3)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=[{line 3, col 4 set f_true tool.Test.NewFuzzy(0.8) <nil> <nil> [] []  <nil> <nil>  []} {line 4, col 4 set f_false tool.Test.NewFuzzy(0.3) <nil> <nil> [] []  <nil> <nil>  []} {line 6, col 4 set res_not notf_true <nil> <nil> [] []  <nil> <nil>  []} {line 7, col 4 set res_and (f_true and f_false) <nil> <nil> [] []  <nil> <nil>  []} {line 8, col 4 set res_or (f_true or f_false) <nil> <nil> [] []  <nil> <nil>  []} {line 9, col 4 set res_mixed (f_false or true) <nil> <nil> [] []  <nil> <nil>  []} {line 11, col 4 return <nil> <nil> <nil> <nil> [] []  <nil> <nil>  [res_mixed]}]
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=res_or
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=res_and
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for TestNewTypesIntegration_Fuzzy_Logic_Operators. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure TestNewTypesIntegration_Fuzzy_Logic_Operators to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for TestNewTypesIntegration_Fuzzy_Logic_Operators
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=RETURN subject=returning 1 values pos=line 11, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 11, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 11, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=<nil> returnValueType=<nil> wasReturn=true err=NeuroScript Error 9: evaluating return expression 1: variable 'res_not' not found at line 11, col 11 (wrapped: variable not found)
    helpers.go:82: [ERROR] Error executing script 'TestNewTypesIntegration_Fuzzy_Logic_Operators': NeuroScript Error 9: evaluating return expression 1: variable 'res_not' not found at line 11, col 11 (wrapped: variable not found)
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:NeuroScript Error 9: evaluating return expression 1: variable 'res_not' not found at line 11, col 11 (wrapped: variable not found) restored_proc_name: result_type:<nil> script_name:TestNewTypesIntegration_Fuzzy_Logic_Operators]
    evaluation_new_types_test.go:118: script execution failed: NeuroScript Error 9: evaluating return expression 1: variable 'res_not' not found at line 11, col 11 (wrapped: variable not found)
=== RUN   TestNewTypesIntegration/Error_Tool_and_is-error_built-in
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestNewTypesIntegrationError_Tool_and_is-error_built-in4266516917/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: TestNewTypesIntegration_Error_Tool_and_is_error_built_in
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=259
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for TestNewTypesIntegration_Error_Tool_and_is_error_built_in. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: my_err
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "tool.Error.New(\"E_FAIL\",\"it failed\")" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Call_target: "tool.Error.New"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: tool.Error.New
    helpers.go:67: [DEBUG]          Tool call identified. Name: 'Error.New', Pos: line 3, col 22
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: Error.New, IsTool: true)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=true, Name=Error.New
    helpers.go:67: [DEBUG] --- Enter Expression: "\"E_FAIL\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "E_FAIL"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"E_FAIL\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"E_FAIL\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"E_FAIL\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"it failed\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"it failed\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "it failed"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"it failed\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"it failed\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"it failed\"" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] popped 2 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=true, Name=Error.New
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=Error.New, Args=2
    helpers.go:67: [DEBUG] --- Exit Primary: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "tool.Error.New(\"E_FAIL\",\"it failed\")"
    helpers.go:67: [DEBUG] --- Exit Expression: "tool.Error.New(\"E_FAIL\",\"it failed\")" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: check_true
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "is_error(my_err)" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Call_target: "is_error"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: is_error
    helpers.go:67: [DEBUG]          User function call identified. Name: 'is_error', Pos: line 4, col 21
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: is_error, IsTool: false)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=false, Name=is_error
    helpers.go:67: [DEBUG] --- Enter Expression: "my_err" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "my_err"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Primary: "my_err"
    helpers.go:67: [DEBUG]     Constructed VariableNode: my_err
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "my_err"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Expression: "my_err" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=false, Name=is_error
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=is_error, Args=1
    helpers.go:67: [DEBUG] --- Exit Primary: "is_error(my_err)"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "is_error(my_err)"
    helpers.go:67: [DEBUG] --- Exit Expression: "is_error(my_err)" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: check_false
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "is_error(\"just a string\")" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Call_target: "is_error"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: is_error
    helpers.go:67: [DEBUG]          User function call identified. Name: 'is_error', Pos: line 5, col 22
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: is_error, IsTool: false)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=false, Name=is_error
    helpers.go:67: [DEBUG] --- Enter Expression: "\"just a string\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"just a string\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "just a string"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"just a string\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"just a string\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"just a string\"" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=false, Name=is_error
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=is_error, Args=1
    helpers.go:67: [DEBUG] --- Exit Primary: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "is_error(\"just a string\")"
    helpers.go:67: [DEBUG] --- Exit Expression: "is_error(\"just a string\")" (Pass through)
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "check_true" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "check_true"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Primary: "check_true"
    helpers.go:67: [DEBUG]     Constructed VariableNode: check_true
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "check_true"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "check_true"
    helpers.go:67: [DEBUG] --- Exit Expression: "check_true" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "check_false" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "check_false"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Primary: "check_false"
    helpers.go:67: [DEBUG]     Constructed VariableNode: check_false
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "check_false"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "check_false"
    helpers.go:67: [DEBUG] --- Exit Expression: "check_false" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "my_err" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "my_err"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Primary: "my_err"
    helpers.go:67: [DEBUG]     Constructed VariableNode: my_err
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "my_err"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "my_err"
    helpers.go:67: [DEBUG] --- Exit Expression: "my_err" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 4, valDepth: 2)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 3)
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 2)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=[{line 3, col 4 set my_err tool.Error.New("E_FAIL", "it failed") <nil> <nil> [] []  <nil> <nil>  []} {line 4, col 4 set check_true is_error(my_err) <nil> <nil> [] []  <nil> <nil>  []} {line 5, col 4 set check_false is_error("just a string") <nil> <nil> [] []  <nil> <nil>  []} {line 6, col 4 return <nil> <nil> <nil> <nil> [] []  <nil> <nil>  [my_err]}]
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [WARN] [AST] stray value purged during %s exit: %T PROC_BODY=check_false
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for TestNewTypesIntegration_Error_Tool_and_is_error_built_in. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure TestNewTypesIntegration_Error_Tool_and_is_error_built_in to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for TestNewTypesIntegration_Error_Tool_and_is_error_built_in
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=RETURN subject=returning 1 values pos=line 6, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 6, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 6, col 11
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=<nil> returnValueType=<nil> wasReturn=true err=NeuroScript Error 9: evaluating return expression 1: variable 'check_true' not found at line 6, col 11 (wrapped: variable not found)
    helpers.go:82: [ERROR] Error executing script 'TestNewTypesIntegration_Error_Tool_and_is_error_built_in': NeuroScript Error 9: evaluating return expression 1: variable 'check_true' not found at line 6, col 11 (wrapped: variable not found)
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:NeuroScript Error 9: evaluating return expression 1: variable 'check_true' not found at line 6, col 11 (wrapped: variable not found) restored_proc_name: result_type:<nil> script_name:TestNewTypesIntegration_Error_Tool_and_is_error_built_in]
    evaluation_new_types_test.go:154: script execution failed: NeuroScript Error 9: evaluating return expression 1: variable 'check_true' not found at line 6, col 11 (wrapped: variable not found)
--- FAIL: TestNewTypesIntegration (0.01s)
    --- FAIL: TestNewTypesIntegration/TypeOf_New_Types (0.00s)
    --- FAIL: TestNewTypesIntegration/Timedate_Comparison (0.00s)
    --- FAIL: TestNewTypesIntegration/Fuzzy_Logic_Operators (0.00s)
    --- FAIL: TestNewTypesIntegration/Error_Tool_and_is-error_built-in (0.00s)
=== RUN   TestResolveValuePlaceholders
=== RUN   TestResolveValuePlaceholders/Raw_string_basic_substitution
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_basic_substitution2526765383/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Test {{name}}!```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{name}}=World
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Test World!
=== RUN   TestResolveValuePlaceholders/Raw_string_multiple_substitutions
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_multiple_substitutions157305923/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```{{greeting}} {{subject}} - Status {{boolVal}}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{greeting}}=Hello
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{subject}}=there
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{boolVal}}=true
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Hello there - Status true
=== RUN   TestResolveValuePlaceholders/Raw_string_numeric_substitution
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_numeric_substitution1361300066/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```The number is {{num}}.```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{num}}=42
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) The number is 42.
=== RUN   TestResolveValuePlaceholders/Raw_string_nil_substitution
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_nil_substitution2595598986/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Value: {{nilVal}}.```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{nilVal}}=<nil>
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Value: <nil>.
=== RUN   TestResolveValuePlaceholders/Raw_string_with_surrounding_whitespace_in_placeholder
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_with_surrounding_whitespace_in_placeholder3316798213/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Data: {{ spacedVar }}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{ spacedVar }}=Spaced Value
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Data: Spaced Value
=== RUN   TestResolveValuePlaceholders/Raw_string_consecutive_placeholders
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_consecutive_placeholders1913546018/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```{{greeting}}{{subject}}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{greeting}}=Hello
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{subject}}=there
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Hellothere
=== RUN   TestResolveValuePlaceholders/Raw_string_no_placeholders
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_no_placeholders2474342991/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Just plain text.```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Just plain text.
=== RUN   TestResolveValuePlaceholders/Raw_string_empty
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_empty1658980638/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ``````
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) 
=== RUN   TestResolveValuePlaceholders/Raw_string_only_placeholder
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_only_placeholder1434864941/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```{{name}}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{name}}=World
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) World
=== RUN   TestResolveValuePlaceholders/Normal_string_with_placeholder_syntax
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersNormal_string_with_placeholder_syntax1241293125/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) "Hello {{name}}!"
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolved String Literal: %q (Logger Warning: odd number of key-value arguments provided) Hello {{name}}!
=== RUN   TestResolveValuePlaceholders/Normal_string_empty
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersNormal_string_empty4271040982/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ""
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolved String Literal: %q (Logger Warning: odd number of key-value arguments provided) 
=== RUN   TestResolveValuePlaceholders/Normal_string_resembling_raw_syntax
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersNormal_string_resembling_raw_syntax3412650849/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) "```{{name}}```"
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolved String Literal: %q (Logger Warning: odd number of key-value arguments provided) ```{{name}}```
=== RUN   TestResolveValuePlaceholders/Raw_string_missing_variable
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_missing_variable2462158237/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Hello {{missing_var}}!```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    evaluation_resolve_test.go:217: [Raw string missing variable] Got expected error wrapping [variable not found]: evaluating placeholders in raw string: variable 'missing_var' referenced in placeholder not found: variable not found
=== RUN   TestResolveValuePlaceholders/Raw_string_mixed_found_and_missing
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_mixed_found_and_missing1847271900/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```{{greeting}} {{not_here}} {{name}}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{greeting}}=Hello
    evaluation_resolve_test.go:217: [Raw string mixed found and missing] Got expected error wrapping [variable not found]: evaluating placeholders in raw string: variable 'not_here' referenced in placeholder not found: variable not found
=== RUN   TestResolveValuePlaceholders/Raw_string_malformed_placeholder_(no_closing)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_malformed_placeholder_(no_closing)3288599735/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Test {{name```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Test {{name
=== RUN   TestResolveValuePlaceholders/Raw_string_malformed_placeholder_(empty)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_malformed_placeholder_(empty)2271350856/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Test {{}}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Test {{}}
=== RUN   TestResolveValuePlaceholders/Raw_string_malformed_placeholder_(space_only)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestResolveValuePlaceholdersRaw_string_malformed_placeholder_(space_only)3917977393/001
    helpers.go:67: [DEBUG] [DEBUG EVAL] Resolving value for node type: %T (Logger Warning: odd number of key-value arguments provided) ```Test {{ }}```
    helpers.go:67: [DEBUG] [DEBUG EVAL]   Resolving Raw String Literal, evaluating placeholders...
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Raw string after substitution: %q (Logger Warning: odd number of key-value arguments provided) Test {{ }}
--- PASS: TestResolveValuePlaceholders (0.01s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_basic_substitution (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_multiple_substitutions (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_numeric_substitution (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_nil_substitution (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_with_surrounding_whitespace_in_placeholder (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_consecutive_placeholders (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_no_placeholders (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_empty (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_only_placeholder (0.00s)
    --- PASS: TestResolveValuePlaceholders/Normal_string_with_placeholder_syntax (0.00s)
    --- PASS: TestResolveValuePlaceholders/Normal_string_empty (0.00s)
    --- PASS: TestResolveValuePlaceholders/Normal_string_resembling_raw_syntax (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_missing_variable (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_mixed_found_and_missing (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_malformed_placeholder_(no_closing) (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_malformed_placeholder_(empty) (0.00s)
    --- PASS: TestResolveValuePlaceholders/Raw_string_malformed_placeholder_(space_only) (0.00s)
=== RUN   TestEvaluateExpressionASTGeneral
=== RUN   TestEvaluateExpressionASTGeneral/String_Literal_(Raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralString_Literal_(Raw)114825870/001
=== RUN   TestEvaluateExpressionASTGeneral/Variable_String_(Raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralVariable_String_(Raw)1985275868/001
=== RUN   TestEvaluateExpressionASTGeneral/Last_Call_Result_(Raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralLast_Call_Result_(Raw)806865138/001
=== RUN   TestEvaluateExpressionASTGeneral/Placeholder_to_String_(Raw_Ref_Value)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralPlaceholder_to_String_(Raw_Ref_Value)2976572211/001
=== RUN   TestEvaluateExpressionASTGeneral/Placeholder_LAST_(Raw_Ref_Value)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralPlaceholder_LAST_(Raw_Ref_Value)2241579067/001
=== RUN   TestEvaluateExpressionASTGeneral/Concat_Lit(raw)_+_Var(raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_Lit(raw)_+_Var(raw)1528871806/001
=== RUN   TestEvaluateExpressionASTGeneral/Concat_Var(raw)_+_Lit(raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_Var(raw)_+_Lit(raw)3705165767/001
=== RUN   TestEvaluateExpressionASTGeneral/Concat_Var(raw)_+_Var(raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_Var(raw)_+_Var(raw)4173491365/001
=== RUN   TestEvaluateExpressionASTGeneral/Concat_with_Number
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_with_Number1260056157/001
=== RUN   TestEvaluateExpressionASTGeneral/Concat_Eval_+_StringLit(Raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_Eval_+_StringLit(Raw)1871679185/001
    helpers.go:67: [DEBUG] [DEBUG EVAL]     Substituting placeholder match '%s' with value: %q {{name}}=World
=== RUN   TestEvaluateExpressionASTGeneral/Concat_Error_Operand
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_Error_Operand4133014634/001
=== RUN   TestEvaluateExpressionASTGeneral/Concat_Nil_Operand
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralConcat_Nil_Operand250705897/001
=== RUN   TestEvaluateExpressionASTGeneral/Add_Numbers
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralAdd_Numbers4015012419/001
=== RUN   TestEvaluateExpressionASTGeneral/Add_Num_+_NumStr
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralAdd_Num_+_NumStr2078350191/001
=== RUN   TestEvaluateExpressionASTGeneral/Subtract_Numbers
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralSubtract_Numbers2658250338/001
=== RUN   TestEvaluateExpressionASTGeneral/Multiply_Numbers
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralMultiply_Numbers2397074392/001
=== RUN   TestEvaluateExpressionASTGeneral/Divide_Numbers_(Int)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralDivide_Numbers_(Int)3871172621/001
=== RUN   TestEvaluateExpressionASTGeneral/Divide_Numbers_(Float)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralDivide_Numbers_(Float)1421087138/001
=== RUN   TestEvaluateExpressionASTGeneral/Modulo_Numbers
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralModulo_Numbers1326436491/001
=== RUN   TestEvaluateExpressionASTGeneral/Power_Numbers
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralPower_Numbers2988052095/001
=== RUN   TestEvaluateExpressionASTGeneral/Simple_List_(Raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralSimple_List_(Raw)885271166/001
=== RUN   TestEvaluateExpressionASTGeneral/Simple_Map_(Raw)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestEvaluateExpressionASTGeneralSimple_Map_(Raw)3669532697/001
--- PASS: TestEvaluateExpressionASTGeneral (0.01s)
    --- PASS: TestEvaluateExpressionASTGeneral/String_Literal_(Raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Variable_String_(Raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Last_Call_Result_(Raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Placeholder_to_String_(Raw_Ref_Value) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Placeholder_LAST_(Raw_Ref_Value) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_Lit(raw)_+_Var(raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_Var(raw)_+_Lit(raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_Var(raw)_+_Var(raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_with_Number (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_Eval_+_StringLit(Raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_Error_Operand (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Concat_Nil_Operand (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Add_Numbers (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Add_Num_+_NumStr (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Subtract_Numbers (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Multiply_Numbers (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Divide_Numbers_(Int) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Divide_Numbers_(Float) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Modulo_Numbers (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Power_Numbers (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Simple_List_(Raw) (0.00s)
    --- PASS: TestEvaluateExpressionASTGeneral/Simple_Map_(Raw) (0.00s)
=== RUN   TestLValueAutoCreation
=== RUN   TestLValueAutoCreation/base_map_auto-creation_with_string_key
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationbase_map_auto-creation_with_string_key2397443493/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_a
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=61
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_a. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"key1\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"key1\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "key1"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"key1\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"key1\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"key1\"" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: a["key1"]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"value1\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"value1\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "value1"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"value1\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"value1\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"value1\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_a. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_a to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_a
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=a["key1"] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=value1 final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_a]
=== RUN   TestLValueAutoCreation/base_list_auto-creation_with_numeric_index_0
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationbase_list_auto-creation_with_numeric_index_04051343240/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_b
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=56
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_b. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: b[0]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"value0\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"value0\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "value0"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"value0\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"value0\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"value0\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_b. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_b to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_b
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=b[0] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=value0 final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_b]
=== RUN   TestLValueAutoCreation/base_list_auto-creation_with_numeric_index_2_(pads_with_nil)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationbase_list_auto-creation_with_numeric_index_2_(pads_with_nil)2384512830/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_c
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=56
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_c. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "2"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "2"
    helpers.go:67: [DEBUG]  >> Exit Literal: 2
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "2"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "2"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Expression: "2" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: c[2]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"value2\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"value2\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "value2"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"value2\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"value2\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"value2\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_c. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_c to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_c
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=c[2] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=value2 final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_c]
=== RUN   TestLValueAutoCreation/nested_map_auto-creation_via_dot_access
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationnested_map_auto-creation_via_dot_access3006307835/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_d
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=67
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_d. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: d.level1.level2
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"valueD\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"valueD\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "valueD"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"valueD\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"valueD\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"valueD\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_d. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_d to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_d
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=d.level1.level2 pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=valueD final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_d]
=== RUN   TestLValueAutoCreation/nested_map_auto-creation_via_bracket_access
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationnested_map_auto-creation_via_bracket_access2076926068/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_e
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=73
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_e. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"level1\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"level1\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "level1"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"level1\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"level1\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"level1\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"level2\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"level2\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "level2"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"level2\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"level2\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"level2\"" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: e["level1"]["level2"]
    helpers.go:67: [DEBUG] popped 2 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"valueE\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"valueE\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "valueE"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"valueE\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"valueE\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"valueE\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_e. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_e to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_e
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=e["level1"]["level2"] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=valueE final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_e]
=== RUN   TestLValueAutoCreation/nested_list_in_map_auto-creation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationnested_list_in_map_auto-creation652858412/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_f
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=63
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_f. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: f.listKey[1]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"item1\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"item1\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "item1"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"item1\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"item1\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"item1\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_f. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_f to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_f
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=f.listKey[1] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=item1 final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_f]
=== RUN   TestLValueAutoCreation/nested_map_in_list_auto-creation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationnested_map_in_list_auto-creation440450398/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_g
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=62
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_g. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: g[0].mapKey
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"itemG\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"itemG\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "itemG"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"itemG\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"itemG\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"itemG\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_g. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_g to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_g
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=g[0].mapKey pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=itemG final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_g]
=== RUN   TestLValueAutoCreation/deeply_nested_auto-creation_map-list-map-list
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationdeeply_nested_auto-creation_map-list-map-list90831548/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_h
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=90
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_h. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"deepKey\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"deepKey\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "deepKey"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"deepKey\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"deepKey\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"deepKey\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: h.maps[0].anotherMap["deepKey"][1]
    helpers.go:67: [DEBUG] popped 3 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"finalValue\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"finalValue\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "finalValue"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"finalValue\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"finalValue\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"finalValue\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_h. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_h to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_h
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=h.maps[0].anotherMap["deepKey"][1] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=finalValue final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_h]
=== RUN   TestLValueAutoCreation/overwrite_existing_string_with_map_on_complex_assignment
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationoverwrite_existing_string_with_map_on_complex_assignment2121910620/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_k
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=90
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_k. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: k
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"i am a string\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"i am a string\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "i am a string"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"i am a string\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"i am a string\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"i am a string\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"newKey\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"newKey\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "newKey"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"newKey\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"newKey\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"newKey\"" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: k["newKey"]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"now a map\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"now a map\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "now a map"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"now a map\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"now a map\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"now a map\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 2, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_k. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_k to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_k
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=k pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=k["newKey"] pos=line 3, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=now a map final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_k]
=== RUN   TestLValueAutoCreation/overwrite_existing_number_with_list_on_complex_assignment
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationoverwrite_existing_number_with_list_on_complex_assignment482560747/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_l
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=72
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_l. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] ExitLvalue: l
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "123" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "123"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "123"
    helpers.go:67: [DEBUG]  >> Exit Literal: 123
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "123"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "123"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "123"
    helpers.go:67: [DEBUG] --- Exit Expression: "123" (Pass through)
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: l[0]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"now a list\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"now a list\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "now a list"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"now a list\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"now a list\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"now a list\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 2, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_l. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_l to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_l
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=l pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=l[0] pos=line 3, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=now a list final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_l]
=== RUN   TestLValueAutoCreation/dot_access_creates_map_then_bracket_access_on_it
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationdot_access_creates_map_then_bracket_access_on_it34037321/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_m
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=73
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_m. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"secondKey\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"secondKey\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "secondKey"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"secondKey\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"secondKey\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"secondKey\"" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: m.firstMap["secondKey"]
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"valM\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"valM\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "valM"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"valM\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"valM\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"valM\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_m. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_m to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_m
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=m.firstMap["secondKey"] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=valM final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_m]
=== RUN   TestLValueAutoCreation/bracket_access_creates_map_then_dot_access_on_it
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationbracket_access_creates_map_then_dot_access_on_it2132178250/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_n
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=73
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_n. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"firstMap\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"firstMap\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "firstMap"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"firstMap\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"firstMap\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"firstMap\"" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: n["firstMap"].secondKey
    helpers.go:67: [DEBUG] popped 1 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"valN\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"valN\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "valN"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"valN\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"valN\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"valN\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_n. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_n to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_n
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=n["firstMap"].secondKey pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=valN final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_n]
=== RUN   TestLValueAutoCreation/list_auto-creation_within_auto-created_map_within_auto-created_list
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestLValueAutoCreationlist_auto-creation_within_auto-created_map_within_auto-created_list570654668/001
    helpers.go:79: [DEBUG] ExecuteScriptString called: test_autocreate_p
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=74
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for test_autocreate_p. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "0"
    helpers.go:67: [DEBUG]  >> Exit Literal: 0
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "0"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "0"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "0"
    helpers.go:67: [DEBUG] --- Exit Expression: "0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"listInMap\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"listInMap\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "listInMap"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"listInMap\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"listInMap\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"listInMap\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Expression: "1" (Pass through)
    helpers.go:67: [DEBUG] ExitLvalue: p[0]["listInMap"][1]
    helpers.go:67: [DEBUG] popped 3 values from value stack (new size: 0)
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"complexP\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"complexP\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "complexP"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"complexP\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"complexP\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"complexP\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 1, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for test_autocreate_p. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure test_autocreate_p to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for test_autocreate_p
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=p[0]["listInMap"][1] pos=line 2, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=complexP final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] Finished ExecuteScriptString. details=map[error:<nil> restored_proc_name: result_type:core.StringValue script_name:test_autocreate_p]
--- PASS: TestLValueAutoCreation (0.02s)
    --- PASS: TestLValueAutoCreation/base_map_auto-creation_with_string_key (0.00s)
    --- PASS: TestLValueAutoCreation/base_list_auto-creation_with_numeric_index_0 (0.00s)
    --- PASS: TestLValueAutoCreation/base_list_auto-creation_with_numeric_index_2_(pads_with_nil) (0.00s)
    --- PASS: TestLValueAutoCreation/nested_map_auto-creation_via_dot_access (0.00s)
    --- PASS: TestLValueAutoCreation/nested_map_auto-creation_via_bracket_access (0.00s)
    --- PASS: TestLValueAutoCreation/nested_list_in_map_auto-creation (0.00s)
    --- PASS: TestLValueAutoCreation/nested_map_in_list_auto-creation (0.00s)
    --- PASS: TestLValueAutoCreation/deeply_nested_auto-creation_map-list-map-list (0.00s)
    --- PASS: TestLValueAutoCreation/overwrite_existing_string_with_map_on_complex_assignment (0.00s)
    --- PASS: TestLValueAutoCreation/overwrite_existing_number_with_list_on_complex_assignment (0.00s)
    --- PASS: TestLValueAutoCreation/dot_access_creates_map_then_bracket_access_on_it (0.00s)
    --- PASS: TestLValueAutoCreation/bracket_access_creates_map_then_dot_access_on_it (0.00s)
    --- PASS: TestLValueAutoCreation/list_auto-creation_within_auto-created_map_within_auto-created_list (0.00s)
=== RUN   TestInterpreter_ParameterPassingFuzz
    helpers.go:67: [DEBUG] Parsing source code (original Parse method) length=1454
    helpers.go:67: [DEBUG] Using DefaultErrorStrategy for parsing.
    helpers.go:67: [DEBUG] Parse attempt completed. lexerListenerErrors=0 parserListenerErrors=0
    helpers.go:67: [DEBUG] Parsing successful (based on listener raw errors).
    helpers.go:67: [DEBUG] --- AST Builder: Build Start ---
    helpers.go:67: [DEBUG] AST Builder: Starting ANTLR walk...
    helpers.go:67: [DEBUG] EnterProgram
    helpers.go:67: [DEBUG]    >> Enter File Header
    helpers.go:67: [DEBUG]    - Processing File Metadata Line: :: Name: Parameter Passing Test Script (Enhanced)
    helpers.go:67: [DEBUG]      Stored File Metadata: 'Name' = 'Parameter Passing Test Script (Enhanced)'
    helpers.go:67: [DEBUG]    - Processing File Metadata Line: :: Version: 1.2.0
    helpers.go:67: [DEBUG]      Stored File Metadata: 'Version' = '1.2.0'
    helpers.go:67: [DEBUG]    << Exit File Header
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for mainEntry. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"mainEntry_recvd:\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "mainEntry_recvd:"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"mainEntry_recvd:\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"mainEntry_recvd:\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"mainEntry_recvd:\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"mainEntry_recvd:\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"mainEntry_recvd:\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "strArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: strArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "strArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "strArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "intArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: intArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "intArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "intArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "boolArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: boolArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 6)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "boolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 7)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "floatArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: floatArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 8)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "floatArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 7)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 6)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 5)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.StringLiteralNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "\"mainEntry_recvd:\"+strArg+\",\"+intArg+\",\"+boolArg+\",\"+floatArg" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitEmit_statement
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Exit Call_target: "helperProc"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: helperProc
    helpers.go:67: [DEBUG]          User function call identified. Name: 'helperProc', Pos: line 9, col 8
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: helperProc, IsTool: false)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 1)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=false, Name=helperProc
    helpers.go:67: [DEBUG] --- Enter Expression: "strArg+\"_to_helper\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "strArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: strArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "strArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "strArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"_to_helper\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "_to_helper"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"_to_helper\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"_to_helper\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "strArg+\"_to_helper\""
    helpers.go:67: [DEBUG] --- Exit Expression: "strArg+\"_to_helper\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "intArg*2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "intArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: intArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "intArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "intArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "2"
    helpers.go:67: [DEBUG]  >> Exit Literal: 2
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "2"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "2"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "2"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "intArg*2"
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode * *core.NumberLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "intArg*2"
    helpers.go:67: [DEBUG] --- Exit Expression: "intArg*2" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "notboolArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "boolArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: boolArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "boolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "boolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "notboolArg"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] pushed *core.UnaryOpNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]       Constructed UnaryOpNode: not [*core.VariableNode]
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "notboolArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "notboolArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "floatArg/2.0" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "floatArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: floatArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 5)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "floatArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "floatArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "2.0"
    helpers.go:67: [DEBUG]  >> Exit Literal: 2.0
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 6)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "2.0"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "2.0"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "2.0"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "2.0"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 5)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 4)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode / *core.NumberLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 5)
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "floatArg/2.0"
    helpers.go:67: [DEBUG] --- Exit Expression: "floatArg/2.0" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "helperProc(strArg+\"_to_helper\",intArg*2,notboolArg,floatArg/2.0)"
    helpers.go:67: [DEBUG] popped 4 values from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=false, Name=helperProc
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=helperProc, Args=4
    helpers.go:67: [DEBUG] <<< ExitCall_statement
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Exit Call_target: "recursiveProc"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: recursiveProc
    helpers.go:67: [DEBUG]          User function call identified. Name: 'recursiveProc', Pos: line 11, col 8
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: recursiveProc, IsTool: false)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 1)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=false, Name=recursiveProc
    helpers.go:67: [DEBUG] --- Enter Expression: "strArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "strArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "strArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: strArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "strArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "strArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "intArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "intArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "intArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: intArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "intArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "intArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "intArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "boolArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "boolArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: boolArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "boolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "boolArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "boolArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "3" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "3"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "3"
    helpers.go:67: [DEBUG]  >> Exit Literal: 3
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "3"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "3"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "3"
    helpers.go:67: [DEBUG] --- Exit Expression: "3" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "recursiveProc(strArg,intArg,boolArg,3)"
    helpers.go:67: [DEBUG] popped 4 values from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=false, Name=recursiveProc
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=recursiveProc, Args=4
    helpers.go:67: [DEBUG] <<< ExitCall_statement
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: result
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"mainEntry_completed_with_\"+strArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"mainEntry_completed_with_\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "mainEntry_completed_with_"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"mainEntry_completed_with_\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"mainEntry_completed_with_\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"mainEntry_completed_with_\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"mainEntry_completed_with_\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"mainEntry_completed_with_\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "strArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: strArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "strArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "strArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.StringLiteralNode + *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"mainEntry_completed_with_\"+strArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "\"mainEntry_completed_with_\"+strArg" (Pass through)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "result" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "result"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Primary: "result"
    helpers.go:67: [DEBUG]     Constructed VariableNode: result
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "result"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Expression: "result" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 5, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for mainEntry. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure mainEntry to list. Total procedures: 1
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for mainEntry
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for helperProc. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"helperProc_recvd:\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "helperProc_recvd:"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"helperProc_recvd:\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"helperProc_recvd:\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"helperProc_recvd:\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"helperProc_recvd:\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"helperProc_recvd:\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "pStr"
    helpers.go:67: [DEBUG] --- Exit Primary: "pStr"
    helpers.go:67: [DEBUG]     Constructed VariableNode: pStr
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "pStr"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "pStr"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "pStr"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "pStr"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "pInt"
    helpers.go:67: [DEBUG] --- Exit Primary: "pInt"
    helpers.go:67: [DEBUG]     Constructed VariableNode: pInt
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "pInt"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "pInt"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "pInt"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "pInt"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "pBool"
    helpers.go:67: [DEBUG] --- Exit Primary: "pBool"
    helpers.go:67: [DEBUG]     Constructed VariableNode: pBool
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 6)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "pBool"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "pBool"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "pBool"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "pBool"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 7)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "pFloat"
    helpers.go:67: [DEBUG] --- Exit Primary: "pFloat"
    helpers.go:67: [DEBUG]     Constructed VariableNode: pFloat
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 8)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "pFloat"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "pFloat"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "pFloat"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "pFloat"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 7)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 6)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 5)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.StringLiteralNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat"
    helpers.go:67: [DEBUG] --- Exit Expression: "\"helperProc_recvd:\"+pStr+\",\"+pInt+\",\"+pBool+\",\"+pFloat" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitEmit_statement
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: result
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"helperProc_completed\"" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "helperProc_completed"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"helperProc_completed\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"helperProc_completed\""
    helpers.go:67: [DEBUG] --- Exit Expression: "\"helperProc_completed\"" (Pass through)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "result" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "result"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Primary: "result"
    helpers.go:67: [DEBUG]     Constructed VariableNode: result
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "result"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Expression: "result" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 3, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for helperProc. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure helperProc to list. Total procedures: 2
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for helperProc
    helpers.go:67: [DEBUG] >>> Enter Procedure_definition for recursiveProc. Parent currentSteps: 0x0, Stack depth: 0
    helpers.go:67: [DEBUG] >>> Enter PROC_BODY Block (valDepth: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"recursiveProc_recvd:\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "recursiveProc_recvd:"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 1)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"recursiveProc_recvd:\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"recursiveProc_recvd:\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"recursiveProc_recvd:\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"recursiveProc_recvd:\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"recursiveProc_recvd:\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "rStrArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rStrArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 3)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "rIntArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rIntArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "rBoolArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rBoolArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 6)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\",\""
    helpers.go:67: [DEBUG]  >> Exit Literal: ","
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 7)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\",\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\",\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\",\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\",\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Primary: "rDepth"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rDepth
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 8)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rDepth"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 7)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 6)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 5)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.StringLiteralNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.StringLiteralNode]
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.BinaryOpNode + *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Expression: "\"recursiveProc_recvd:\"+rStrArg+\",\"+rIntArg+\",\"+rBoolArg+\",\"+rDepth" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitEmit_statement
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "rDepth>1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Primary: "rDepth"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rDepth
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rDepth"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "rDepth>1"
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode > *core.NumberLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "rDepth>1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "rDepth>1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "rDepth>1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "rDepth>1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "rDepth>1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "rDepth>1"
    helpers.go:67: [DEBUG] --- Exit Expression: "rDepth>1" (Pass through)
    helpers.go:67: [DEBUG] >>> Enter IF_ELSE_BODY Block (valDepth: 1)
    helpers.go:67: [DEBUG] ExitLvalue: newDepth
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Enter Expression: "rDepth-1" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Primary: "rDepth"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rDepth
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rDepth"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "1"
    helpers.go:67: [DEBUG]  >> Exit Literal: 1
    helpers.go:67: [DEBUG] pushed *core.NumberLiteralNode onto value stack (size: 4)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "1"
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "1"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "1"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "rDepth-1"
    helpers.go:67: [DEBUG] popped *core.NumberLiteralNode from value stack (new size: 3)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode - *core.NumberLiteralNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "rDepth-1"
    helpers.go:67: [DEBUG] --- Exit Expression: "rDepth-1" (Pass through)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] --- Exit Call_target: "recursiveProc"
    helpers.go:67: [DEBUG]       -> buildCallTargetFromContext: recursiveProc
    helpers.go:67: [DEBUG]          User function call identified. Name: 'recursiveProc', Pos: line 31, col 10
    helpers.go:67: [DEBUG]       <- buildCallTargetFromContext (Name: recursiveProc, IsTool: false)
    helpers.go:67: [DEBUG] pushed *core.CallTarget onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Pushed *CallTarget to stack: IsTool=false, Name=recursiveProc
    helpers.go:67: [DEBUG] --- Enter Expression: "rStrArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "rStrArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rStrArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "rStrArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "rStrArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "rIntArg+rDepth" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "rIntArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rIntArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rIntArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Primary: "rDepth"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rDepth
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 5)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rDepth"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 3)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.VariableNode + *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 4)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "rIntArg+rDepth"
    helpers.go:67: [DEBUG] --- Exit Expression: "rIntArg+rDepth" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "notrBoolArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- Exit Primary: "rBoolArg"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rBoolArg
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 5)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rBoolArg"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 4)
    helpers.go:67: [DEBUG] pushed *core.UnaryOpNode onto value stack (size: 5)
    helpers.go:67: [DEBUG]       Constructed UnaryOpNode: not [*core.VariableNode]
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "notrBoolArg"
    helpers.go:67: [DEBUG] --- Exit Expression: "notrBoolArg" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Expression: "newDepth" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Primary: "newDepth"
    helpers.go:67: [DEBUG]     Constructed VariableNode: newDepth
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 6)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "newDepth"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "newDepth"
    helpers.go:67: [DEBUG] --- Exit Expression: "newDepth" (Pass through)
    helpers.go:67: [DEBUG] --- Exit Callable_expr: "recursiveProc(rStrArg,rIntArg+rDepth,notrBoolArg,newDepth)"
    helpers.go:67: [DEBUG] popped 4 values from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.CallTarget from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Popped *CallTarget from stack: IsTool=false, Name=recursiveProc
    helpers.go:67: [DEBUG] pushed *core.CallableExprNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]       Constructed and Pushed CallableExprNode: Target=recursiveProc, Args=4
    helpers.go:67: [DEBUG] <<< ExitCall_statement
    helpers.go:67: [DEBUG] popped *core.CallableExprNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] <<< Exit IF_ELSE_BODY Block (items: 2, valDepth: 1)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 2)
    helpers.go:67: [DEBUG] <<< ExitIf_statement
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] ExitLvalue: result
    helpers.go:67: [DEBUG] pushed *core.LValueNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Enter Expression: "\"recursiveProc_completed_depth_\"+rDepth" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "\"recursiveProc_completed_depth_\""
    helpers.go:67: [DEBUG]  >> Exit Literal: "recursiveProc_completed_depth_"
    helpers.go:67: [DEBUG] pushed *core.StringLiteralNode onto value stack (size: 2)
    helpers.go:67: [DEBUG]    << Exit Literal
    helpers.go:67: [DEBUG] --- Exit Primary: "\"recursiveProc_completed_depth_\""
    helpers.go:67: [DEBUG]     Primary is Literal, Placeholder, Call, or Parenthesized (Pass through)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "\"recursiveProc_completed_depth_\""
    helpers.go:67: [DEBUG] --- Exit Power_expr: "\"recursiveProc_completed_depth_\""
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "\"recursiveProc_completed_depth_\""
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "\"recursiveProc_completed_depth_\""
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Primary: "rDepth"
    helpers.go:67: [DEBUG]     Constructed VariableNode: rDepth
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 3)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "rDepth"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "rDepth"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 2)
    helpers.go:67: [DEBUG] popped *core.StringLiteralNode from value stack (new size: 1)
    helpers.go:67: [DEBUG]       Constructed BinaryOpNode: [*core.StringLiteralNode + *core.VariableNode]
    helpers.go:67: [DEBUG] pushed *core.BinaryOpNode onto value stack (size: 2)
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "\"recursiveProc_completed_depth_\"+rDepth"
    helpers.go:67: [DEBUG] --- Exit Expression: "\"recursiveProc_completed_depth_\"+rDepth" (Pass through)
    helpers.go:67: [DEBUG] popped *core.BinaryOpNode from value stack (new size: 1)
    helpers.go:67: [DEBUG] popped *core.LValueNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] --- Enter Expression: "result" (Pass through)
    helpers.go:67: [DEBUG] --- Enter Additive_expr: "result"
    helpers.go:67: [DEBUG] --- Enter Accessor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Primary: "result"
    helpers.go:67: [DEBUG]     Constructed VariableNode: result
    helpers.go:67: [DEBUG] pushed *core.VariableNode onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- Exit Accessor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Power_expr: "result"
    helpers.go:67: [DEBUG] --- ExitUnary_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Multiplicative_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Additive_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Relational_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Equality_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_and_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_xor_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Bitwise_or_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Logical_and_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Logical_or_expr: "result"
    helpers.go:67: [DEBUG] --- Exit Expression: "result" (Pass through)
    helpers.go:67: [DEBUG] <<< ExitReturn_statement
    helpers.go:67: [DEBUG] popped *core.VariableNode from value stack (new size: 0)
    helpers.go:67: [DEBUG] <<< Exit PROC_BODY Block (items: 4, valDepth: 0)
    helpers.go:67: [DEBUG] pushed []core.Step onto value stack (size: 1)
    helpers.go:67: [DEBUG] --- ExitProcedure_definition for recursiveProc. Value stack size before body pop: 1
    helpers.go:67: [DEBUG] popped []core.Step from value stack (new size: 0)
    helpers.go:67: [DEBUG]    Added procedure recursiveProc to list. Total procedures: 3
    helpers.go:67: [DEBUG] <<< Exited Procedure_definition for recursiveProc
    helpers.go:67: [DEBUG] ExitProgram: Finalizing program...
    helpers.go:67: [DEBUG] AST Builder: ANTLR walk finished.
    helpers.go:67: [DEBUG] --- AST Builder: Build process completed successfully. ---
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration0
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration0
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration1
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration1
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration2
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration2
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration3
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration3
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration4
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration4
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration5
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration5
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration6
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration6
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration7
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration7
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration8
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration8
=== RUN   TestInterpreter_ParameterPassingFuzz/Iteration9
=== PAUSE TestInterpreter_ParameterPassingFuzz/Iteration9
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration7
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration1
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration9
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration4
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
=== CONT  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [WARN] NewInterpreter: nil LLMClient provided. Initializing with a NoOp LLMClient.
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/home/aprice/dev/neuroscript/pkg/core
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] Added procedure definition. name=recursiveProc
    helpers.go:67: [DEBUG] Added procedure definition. name=mainEntry
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] Added procedure definition. name=helperProc
    helpers.go:67: [DEBUG] Running procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=5 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("mainEntry_recvd:" + strArg) + ",") + intArg) + ",") + boolArg) + ",") + floatArg) pos=line 7, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 7, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=helperProc pos=line 9, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] Running procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("helperProc_recvd:" + pStr) + ",") + pInt) + ",") + pBool) + ",") + pFloat) pos=line 19, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 19, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=SET subject=result pos=line 20, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=RETURN subject=returning 1 values pos=line 21, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 21, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 21, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[helperProc_completed] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=helperProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=CALL subject=recursiveProc pos=line 11, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration4
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr4] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr7] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=newDepth pos=line 29, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr6] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=CALL subject=recursiveProc pos=line 31, col 5
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration6
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration7
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] Running procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=4 mode=normal activeError=nil
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=EMIT subject=((((((("recursiveProc_recvd:" + rStrArg) + ",") + rIntArg) + ",") + rBoolArg) + ",") + rDepth) pos=line 26, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing EMIT pos=line 26, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration5
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr5] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition FALSE, no ELSE block pos=line 28, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_1] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration8
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr8] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration0
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr0] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[recursiveProc_completed_depth_2] final_lastCallResultType=core.ListValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration9
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=3 type=SET subject=result pos=line 34, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=RETURN subject=returning 1 values pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr9] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr1] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
=== NAME  TestInterpreter_ParameterPassingFuzz/Iteration2
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 35, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[recursiveProc_completed_depth_3] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=recursiveProc caller=
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=4 type=SET subject=result pos=line 13, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=5 type=RETURN subject=returning 1 values pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=1 pos=line 14, col 3
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[mainEntry_completed_with_cliStr2] returnValueType=core.ListValue wasReturn=true err=<nil>
    helpers.go:67: [DEBUG] Finished procedure name=mainEntry caller=
--- PASS: TestInterpreter_ParameterPassingFuzz (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration3 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration4 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration6 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration7 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration5 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration8 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration0 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration9 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration1 (0.01s)
    --- PASS: TestInterpreter_ParameterPassingFuzz/Iteration2 (0.01s)
=== RUN   TestInterpretStringEscaping
=== RUN   TestInterpretStringEscaping/Interpret_Backspace
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Backspace2395102516/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=textback final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Tab
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Tab1025202192/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=col1	col2 final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Newline
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Newline3538484949/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=first
        second final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Formfeed
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Formfeed3137463649/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=page1page2 final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Carriage_Return
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Carriage_Return3009369787/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=overwrite final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Vertical_Tab
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Vertical_Tab2304279553/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=vtab final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Tilde
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Tilde718002627/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=approx~equal final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Backtick
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Backtick936970548/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=code `block` final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Double_Quote
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Double_Quote1580547657/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=a "quoted" string final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Single_Quote
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Single_Quote520917856/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=it's great final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Backslash
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Backslash2025112238/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=a path C:\folder final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Unicode_BMP
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Unicode_BMP4189802440/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=currency: € final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Unicode_Surrogate_Pair
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Unicode_Surrogate_Pair631828199/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=face: 😀 final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Unicode_Unpaired_High_Surrogate
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Unicode_Unpaired_High_Surrogate1071385967/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=unpaired: � after final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Unicode_High_Surrogate_at_EOS
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Unicode_High_Surrogate_at_EOS1492235643/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=eos: � final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Unicode_High_Surrogate_followed_by_non-low_surrogate_unicode
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Unicode_High_Surrogate_followed_by_non-low_surrogate_unicode898680396/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=�A final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestInterpretStringEscaping/Interpret_Unicode_High_Surrogate_followed_by_non-unicode_escape
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestInterpretStringEscapingInterpret_Unicode_High_Surrogate_followed_by_non-unicode_escape233393106/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=val pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=�
         final_lastCallResultType=core.StringValue final_wasCleared=false
--- PASS: TestInterpretStringEscaping (0.01s)
    --- PASS: TestInterpretStringEscaping/Interpret_Backspace (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Tab (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Newline (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Formfeed (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Carriage_Return (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Vertical_Tab (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Tilde (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Backtick (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Double_Quote (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Single_Quote (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Backslash (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Unicode_BMP (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Unicode_Surrogate_Pair (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Unicode_Unpaired_High_Surrogate (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Unicode_High_Surrogate_at_EOS (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Unicode_High_Surrogate_followed_by_non-low_surrogate_unicode (0.00s)
    --- PASS: TestInterpretStringEscaping/Interpret_Unicode_High_Surrogate_followed_by_non-unicode_escape (0.00s)
=== RUN   TestExecuteStepsBlocksAndLoops
=== RUN   TestExecuteStepsBlocksAndLoops/IF_true_literal
=== RUN   TestExecuteStepsBlocksAndLoops/IF_true_literal/IF_true_literal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsIF_true_literalIF_true_literal3177240289/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=IF subject=<no specific subject> pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=x pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=Inside final_lastCallResultType=core.StringValue final_wasCleared=false
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=Inside final_lastCallResultType=core.StringValue final_wasCleared=false
=== RUN   TestExecuteStepsBlocksAndLoops/IF_block_with_RETURN
=== RUN   TestExecuteStepsBlocksAndLoops/IF_block_with_RETURN/IF_block_with_RETURN
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsIF_block_with_RETURNIF_block_with_RETURN3810370892/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=3 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=status pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=IF subject=<no specific subject> pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing IF pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]     IF condition TRUE, executing THEN block pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=x pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=RETURN subject=returning "ReturnedFromIf" pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has a single expression pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=ReturnedFromIf returnValueType=core.StringValue wasReturn=true err=<nil>
=== RUN   TestExecuteStepsBlocksAndLoops/RETURN_multiple_values
=== RUN   TestExecuteStepsBlocksAndLoops/RETURN_multiple_values/RETURN_multiple_values
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsRETURN_multiple_valuesRETURN_multiple_values2205653274/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=RETURN subject=returning 3 values pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=3 pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[hello, 10, true] returnValueType=core.ListValue wasReturn=true err=<nil>
=== RUN   TestExecuteStepsBlocksAndLoops/RETURN_value_from_variable
=== RUN   TestExecuteStepsBlocksAndLoops/RETURN_value_from_variable/RETURN_value_from_variable
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsRETURN_value_from_variableRETURN_value_from_variable1552244515/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=myVar pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=RETURN subject=returning myVar pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has a single expression pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=data returnValueType=core.StringValue wasReturn=true err=<nil>
=== RUN   TestExecuteStepsBlocksAndLoops/RETURN_multiple_values_including_variable
=== RUN   TestExecuteStepsBlocksAndLoops/RETURN_multiple_values_including_variable/RETURN_multiple_values_including_variable
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsRETURN_multiple_values_including_variableRETURN_multiple_values_including_variable3914656217/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=2 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=myVar pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=2 type=RETURN subject=returning 3 values pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing RETURN pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Return has multiple expressions count=3 pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] RETURN statement executed returnValue=[1, false, 3.14] returnValueType=core.ListValue wasReturn=true err=<nil>
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_true_literal
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_true_literal/MUST_true_literal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsMUST_true_literalMUST_true_literal1505480384/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=MUST subject=must true pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing MUST/MUSTBE type=MUST pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=true final_lastCallResultType=core.BoolValue final_wasCleared=false
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('true')
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('true')/MUST_non-empty_string_('true')
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsMUST_non-empty_string_(true)MUST_non-empty_string_(true)1929405320/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=MUST subject=must "true" pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing MUST/MUSTBE type=MUST pos=line 1, col 1
    testing_helpers.go:228: Test "MUST non-empty string ('true')": Unexpected error state. Got err: NeuroScript Error 6: internal error during MUST at line 1, col 1 (wrapped: invalid operand type), wantErr: false
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('1')
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('1')/MUST_non-empty_string_('1')
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsMUST_non-empty_string_(1)MUST_non-empty_string_(1)3354075203/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=MUST subject=must "1" pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing MUST/MUSTBE type=MUST pos=line 1, col 1
    testing_helpers.go:228: Test "MUST non-empty string ('1')": Unexpected error state. Got err: NeuroScript Error 6: internal error during MUST at line 1, col 1 (wrapped: invalid operand type), wantErr: false
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('other')
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('other')/MUST_non-empty_string_('other')
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsMUST_non-empty_string_(other)MUST_non-empty_string_(other)1375436008/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=MUST subject=must "other" pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing MUST/MUSTBE type=MUST pos=line 1, col 1
    testing_helpers.go:232: Test "MUST non-empty string ('other')": Expected error wrapping: [must condition evaluated to false], got: [NeuroScript Error 6: internal error during MUST at line 1, col 1 (wrapped: invalid operand type)]
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_last_result_(false)
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_last_result_(false)/MUST_last_result_(false)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsMUST_last_result_(false)MUST_last_result_(false)3549354345/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=MUST subject=must last pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing MUST/MUSTBE type=MUST pos=line 1, col 1
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_evaluation_error
=== RUN   TestExecuteStepsBlocksAndLoops/MUST_evaluation_error/MUST_evaluation_error
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsMUST_evaluation_errorMUST_evaluation_error1032985642/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=MUST subject=must (1 + "a") pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing MUST/MUSTBE type=MUST pos=line 1, col 1
=== RUN   TestExecuteStepsBlocksAndLoops/Tool_Call_List.Append
=== RUN   TestExecuteStepsBlocksAndLoops/Tool_Call_List.Append/Tool_Call_List.Append
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsTool_Call_List.AppendTool_Call_List.Append2064479273/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=appendedList pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=[item1, 2, true, newItem] final_lastCallResultType=core.ListValue final_wasCleared=false
=== RUN   TestExecuteStepsBlocksAndLoops/Tool_Call_List.Get_out-of-bounds_with_default
=== RUN   TestExecuteStepsBlocksAndLoops/Tool_Call_List.Get_out-of-bounds_with_default/Tool_Call_List.Get_out-of-bounds_with_default
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestExecuteStepsBlocksAndLoopsTool_Call_List.Get_out-of-bounds_with_defaultTool_Call_List.Get_out-of-bounds_with_default138573169/001
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Executing steps count=1 mode=normal activeError=nil
    helpers.go:67: [DEBUG] [DEBUG-INTERP]   Executing Step step_num=1 type=SET subject=gotItemOrDefault pos=line 1, col 1
    helpers.go:67: [DEBUG] [DEBUG-INTERP] Finished executing steps block normally final_lastCallResult=default final_lastCallResultType=core.StringValue final_wasCleared=false
--- FAIL: TestExecuteStepsBlocksAndLoops (0.01s)
    --- PASS: TestExecuteStepsBlocksAndLoops/IF_true_literal (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/IF_true_literal/IF_true_literal (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/IF_block_with_RETURN (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/IF_block_with_RETURN/IF_block_with_RETURN (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/RETURN_multiple_values (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/RETURN_multiple_values/RETURN_multiple_values (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/RETURN_value_from_variable (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/RETURN_value_from_variable/RETURN_value_from_variable (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/RETURN_multiple_values_including_variable (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/RETURN_multiple_values_including_variable/RETURN_multiple_values_including_variable (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/MUST_true_literal (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/MUST_true_literal/MUST_true_literal (0.00s)
    --- FAIL: TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('true') (0.00s)
        --- FAIL: TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('true')/MUST_non-empty_string_('true') (0.00s)
    --- FAIL: TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('1') (0.00s)
        --- FAIL: TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('1')/MUST_non-empty_string_('1') (0.00s)
    --- FAIL: TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('other') (0.00s)
        --- FAIL: TestExecuteStepsBlocksAndLoops/MUST_non-empty_string_('other')/MUST_non-empty_string_('other') (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/MUST_last_result_(false) (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/MUST_last_result_(false)/MUST_last_result_(false) (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/MUST_evaluation_error (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/MUST_evaluation_error/MUST_evaluation_error (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/Tool_Call_List.Append (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/Tool_Call_List.Append/Tool_Call_List.Append (0.00s)
    --- PASS: TestExecuteStepsBlocksAndLoops/Tool_Call_List.Get_out-of-bounds_with_default (0.00s)
        --- PASS: TestExecuteStepsBlocksAndLoops/Tool_Call_List.Get_out-of-bounds_with_default/Tool_Call_List.Get_out-of-bounds_with_default (0.00s)
=== RUN   TestNeuroScriptParser
    parser_test.go:56: Skipping file 'invalid_bracket_access.ns.txt' found in testdata directory, not in testCases map.
=== RUN   TestNeuroScriptParser/invalid_keyword_case.ns.txt
=== PAUSE TestNeuroScriptParser/invalid_keyword_case.ns.txt
=== RUN   TestNeuroScriptParser/invalid_metadata_format.ns.txt
=== PAUSE TestNeuroScriptParser/invalid_metadata_format.ns.txt
=== RUN   TestNeuroScriptParser/invalid_syntax_structure.ns.txt
=== PAUSE TestNeuroScriptParser/invalid_syntax_structure.ns.txt
=== NAME  TestNeuroScriptParser
    parser_test.go:56: Skipping file 'minimal_newline_test.ns.txt' found in testdata directory, not in testCases map.
=== RUN   TestNeuroScriptParser/valid_basic.ns.txt
=== PAUSE TestNeuroScriptParser/valid_basic.ns.txt
=== RUN   TestNeuroScriptParser/valid_control_flow.ns.txt
=== PAUSE TestNeuroScriptParser/valid_control_flow.ns.txt
=== RUN   TestNeuroScriptParser/valid_error_handler.ns.txt
=== PAUSE TestNeuroScriptParser/valid_error_handler.ns.txt
=== NAME  TestNeuroScriptParser
    parser_test.go:56: Skipping file 'valid_line_continuation.ns.txt' found in testdata directory, not in testCases map.
=== RUN   TestNeuroScriptParser/valid_metadata.ns.txt
=== PAUSE TestNeuroScriptParser/valid_metadata.ns.txt
=== RUN   TestNeuroScriptParser/valid_tool_call.ns.txt
=== PAUSE TestNeuroScriptParser/valid_tool_call.ns.txt
=== CONT  TestNeuroScriptParser/invalid_keyword_case.ns.txt
    parser_test.go:83: Parsing file: invalid_keyword_case.ns.txt (ExpectError: true)
=== CONT  TestNeuroScriptParser/valid_control_flow.ns.txt
=== NAME  TestNeuroScriptParser/invalid_keyword_case.ns.txt
    parser_test.go:105: Finished parsing invalid_keyword_case.ns.txt. Errors found: true
=== NAME  TestNeuroScriptParser/valid_control_flow.ns.txt
    parser_test.go:83: Parsing file: valid_control_flow.ns.txt (ExpectError: false)
=== CONT  TestNeuroScriptParser/valid_error_handler.ns.txt
    parser_test.go:83: Parsing file: valid_error_handler.ns.txt (ExpectError: false)
=== CONT  TestNeuroScriptParser/valid_basic.ns.txt
=== CONT  TestNeuroScriptParser/invalid_syntax_structure.ns.txt
=== CONT  TestNeuroScriptParser/valid_metadata.ns.txt
=== CONT  TestNeuroScriptParser/invalid_metadata_format.ns.txt
=== CONT  TestNeuroScriptParser/valid_tool_call.ns.txt
=== NAME  TestNeuroScriptParser/valid_metadata.ns.txt
    parser_test.go:83: Parsing file: valid_metadata.ns.txt (ExpectError: false)
=== NAME  TestNeuroScriptParser/invalid_metadata_format.ns.txt
    parser_test.go:83: Parsing file: invalid_metadata_format.ns.txt (ExpectError: false)
=== NAME  TestNeuroScriptParser/invalid_syntax_structure.ns.txt
    parser_test.go:83: Parsing file: invalid_syntax_structure.ns.txt (ExpectError: true)
=== NAME  TestNeuroScriptParser/valid_basic.ns.txt
    parser_test.go:83: Parsing file: valid_basic.ns.txt (ExpectError: false)
=== NAME  TestNeuroScriptParser/valid_tool_call.ns.txt
    parser_test.go:83: Parsing file: valid_tool_call.ns.txt (ExpectError: false)
=== NAME  TestNeuroScriptParser/invalid_metadata_format.ns.txt
    parser_test.go:105: Finished parsing invalid_metadata_format.ns.txt. Errors found: false
=== NAME  TestNeuroScriptParser/valid_error_handler.ns.txt
    parser_test.go:105: Finished parsing valid_error_handler.ns.txt. Errors found: false
=== NAME  TestNeuroScriptParser/valid_tool_call.ns.txt
    parser_test.go:105: Finished parsing valid_tool_call.ns.txt. Errors found: false
=== NAME  TestNeuroScriptParser/invalid_syntax_structure.ns.txt
    parser_test.go:105: Finished parsing invalid_syntax_structure.ns.txt. Errors found: true
=== NAME  TestNeuroScriptParser/valid_basic.ns.txt
    parser_test.go:105: Finished parsing valid_basic.ns.txt. Errors found: false
=== NAME  TestNeuroScriptParser/valid_control_flow.ns.txt
    parser_test.go:105: Finished parsing valid_control_flow.ns.txt. Errors found: false
=== NAME  TestNeuroScriptParser/valid_metadata.ns.txt
    parser_test.go:105: Finished parsing valid_metadata.ns.txt. Errors found: false
--- PASS: TestNeuroScriptParser (0.00s)
    --- PASS: TestNeuroScriptParser/invalid_keyword_case.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/invalid_metadata_format.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/valid_error_handler.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/valid_tool_call.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/invalid_syntax_structure.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/valid_basic.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/valid_control_flow.ns.txt (0.00s)
    --- PASS: TestNeuroScriptParser/valid_metadata.ns.txt (0.00s)
=== RUN   TestResolveAndSecurePath
=== RUN   TestResolveAndSecurePath/Valid_Simple_Path
=== RUN   TestResolveAndSecurePath/Valid_Subdir_Path
=== RUN   TestResolveAndSecurePath/Valid_Path_With_Dot
=== RUN   TestResolveAndSecurePath/Valid_Path_With_Internal_Dot_Dot
=== RUN   TestResolveAndSecurePath/Valid_Path_Resolving_To_Root
=== RUN   TestResolveAndSecurePath/Valid_Path_Using_Dot
=== RUN   TestResolveAndSecurePath/Valid_Complex_Traversal_(Cleans_to_Inside_Sibling)
=== RUN   TestResolveAndSecurePath/Invalid_Empty_Path
=== RUN   TestResolveAndSecurePath/Invalid_Null_Byte
=== RUN   TestResolveAndSecurePath/Invalid_Absolute_Path
=== RUN   TestResolveAndSecurePath/Invalid_Simple_Traversal_Up
=== RUN   TestResolveAndSecurePath/Invalid_Simple_Traversal_File
=== RUN   TestResolveAndSecurePath/Invalid_Complex_Traversal_(Cleans_to_Parent_Sibling)
=== RUN   TestResolveAndSecurePath/Invalid_Traversal_Leading_To_Sibling_Dir
--- PASS: TestResolveAndSecurePath (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Simple_Path (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Subdir_Path (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Path_With_Dot (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Path_With_Internal_Dot_Dot (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Path_Resolving_To_Root (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Path_Using_Dot (0.00s)
    --- PASS: TestResolveAndSecurePath/Valid_Complex_Traversal_(Cleans_to_Inside_Sibling) (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Empty_Path (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Null_Byte (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Absolute_Path (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Simple_Traversal_Up (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Simple_Traversal_File (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Complex_Traversal_(Cleans_to_Parent_Sibling) (0.00s)
    --- PASS: TestResolveAndSecurePath/Invalid_Traversal_Leading_To_Sibling_Dir (0.00s)
=== RUN   TestIsPathInSandbox
=== RUN   TestIsPathInSandbox/Valid_Simple
=== RUN   TestIsPathInSandbox/Valid_Subdir
=== RUN   TestIsPathInSandbox/Valid_Root
=== RUN   TestIsPathInSandbox/Valid_Internal_..
=== RUN   TestIsPathInSandbox/Valid_Complex_Internal_..
=== RUN   TestIsPathInSandbox/Invalid_Simple_..
=== RUN   TestIsPathInSandbox/Invalid_Traversal
=== RUN   TestIsPathInSandbox/Invalid_Complex_Traversal
=== RUN   TestIsPathInSandbox/Invalid_Absolute
=== RUN   TestIsPathInSandbox/Invalid_Empty
=== RUN   TestIsPathInSandbox/Invalid_Null_Byte
--- PASS: TestIsPathInSandbox (0.00s)
    --- PASS: TestIsPathInSandbox/Valid_Simple (0.00s)
    --- PASS: TestIsPathInSandbox/Valid_Subdir (0.00s)
    --- PASS: TestIsPathInSandbox/Valid_Root (0.00s)
    --- PASS: TestIsPathInSandbox/Valid_Internal_.. (0.00s)
    --- PASS: TestIsPathInSandbox/Valid_Complex_Internal_.. (0.00s)
    --- PASS: TestIsPathInSandbox/Invalid_Simple_.. (0.00s)
    --- PASS: TestIsPathInSandbox/Invalid_Traversal (0.00s)
    --- PASS: TestIsPathInSandbox/Invalid_Complex_Traversal (0.00s)
    --- PASS: TestIsPathInSandbox/Invalid_Absolute (0.00s)
    --- PASS: TestIsPathInSandbox/Invalid_Empty (0.00s)
    --- PASS: TestIsPathInSandbox/Invalid_Null_Byte (0.00s)
=== RUN   TestUnescapeNeuroScriptString
=== RUN   TestUnescapeNeuroScriptString/empty_string
=== RUN   TestUnescapeNeuroScriptString/no_escapes
=== RUN   TestUnescapeNeuroScriptString/newline
=== RUN   TestUnescapeNeuroScriptString/tab
=== RUN   TestUnescapeNeuroScriptString/carriage_return
=== RUN   TestUnescapeNeuroScriptString/backslash
=== RUN   TestUnescapeNeuroScriptString/double_quote
=== RUN   TestUnescapeNeuroScriptString/single_quote
=== RUN   TestUnescapeNeuroScriptString/backtick
=== RUN   TestUnescapeNeuroScriptString/tilde
=== RUN   TestUnescapeNeuroScriptString/form_feed
=== RUN   TestUnescapeNeuroScriptString/vertical_tab
=== RUN   TestUnescapeNeuroScriptString/backspace
=== RUN   TestUnescapeNeuroScriptString/multiple_basic
=== RUN   TestUnescapeNeuroScriptString/unicode_A
=== RUN   TestUnescapeNeuroScriptString/unicode_Omega
=== RUN   TestUnescapeNeuroScriptString/unicode_Heart
=== RUN   TestUnescapeNeuroScriptString/unicode_mixed
=== RUN   TestUnescapeNeuroScriptString/unicode_emoji_grinning_face
=== RUN   TestUnescapeNeuroScriptString/unicode_emoji_laughing_face
=== RUN   TestUnescapeNeuroScriptString/unicode_high_surrogate_only
=== RUN   TestUnescapeNeuroScriptString/unicode_high_surrogate_then_text
=== RUN   TestUnescapeNeuroScriptString/unicode_high_surrogate_then_incomplete_low_surrogate_1
=== RUN   TestUnescapeNeuroScriptString/unicode_high_surrogate_then_incomplete_low_surrogate_2
=== RUN   TestUnescapeNeuroScriptString/unicode_high_surrogate_then_invalid_low_surrogate_hex
=== RUN   TestUnescapeNeuroScriptString/unicode_high_surrogate_not_followed_by_\u
=== RUN   TestUnescapeNeuroScriptString/trailing_backslash
=== RUN   TestUnescapeNeuroScriptString/incomplete_unicode_short
=== RUN   TestUnescapeNeuroScriptString/incomplete_unicode_mid
=== RUN   TestUnescapeNeuroScriptString/invalid_unicode_hex
=== RUN   TestUnescapeNeuroScriptString/unknown_escape
=== RUN   TestUnescapeNeuroScriptString/unknown_escape_at_end
=== RUN   TestUnescapeNeuroScriptString/unicode_incomplete_in_surrogate_attempt
=== RUN   TestUnescapeNeuroScriptString/unicode_invalid_hex_in_surrogate_attempt
=== RUN   TestUnescapeNeuroScriptString/text_and_escapes
=== RUN   TestUnescapeNeuroScriptString/escapes_and_unicode
=== RUN   TestUnescapeNeuroScriptString/complex_emoji_sequence
=== RUN   TestUnescapeNeuroScriptString/multiple_emojis
=== RUN   TestUnescapeNeuroScriptString/emoji_then_text
=== RUN   TestUnescapeNeuroScriptString/text_then_emoji
--- PASS: TestUnescapeNeuroScriptString (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/empty_string (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/no_escapes (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/newline (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/tab (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/carriage_return (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/backslash (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/double_quote (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/single_quote (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/backtick (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/tilde (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/form_feed (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/vertical_tab (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/backspace (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/multiple_basic (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_A (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_Omega (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_Heart (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_mixed (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_emoji_grinning_face (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_emoji_laughing_face (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_high_surrogate_only (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_high_surrogate_then_text (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_high_surrogate_then_incomplete_low_surrogate_1 (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_high_surrogate_then_incomplete_low_surrogate_2 (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_high_surrogate_then_invalid_low_surrogate_hex (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_high_surrogate_not_followed_by_\u (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/trailing_backslash (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/incomplete_unicode_short (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/incomplete_unicode_mid (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/invalid_unicode_hex (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unknown_escape (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unknown_escape_at_end (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_incomplete_in_surrogate_attempt (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/unicode_invalid_hex_in_surrogate_attempt (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/text_and_escapes (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/escapes_and_unicode (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/complex_emoji_sequence (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/multiple_emojis (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/emoji_then_text (0.00s)
    --- PASS: TestUnescapeNeuroScriptString/text_then_emoji (0.00s)
=== RUN   TestSafeEscapeHTML
=== RUN   TestSafeEscapeHTML/empty
=== RUN   TestSafeEscapeHTML/no_special_chars
=== RUN   TestSafeEscapeHTML/simple_html
=== RUN   TestSafeEscapeHTML/quotes_and_ampersand
=== RUN   TestSafeEscapeHTML/single_quote
--- PASS: TestSafeEscapeHTML (0.00s)
    --- PASS: TestSafeEscapeHTML/empty (0.00s)
    --- PASS: TestSafeEscapeHTML/no_special_chars (0.00s)
    --- PASS: TestSafeEscapeHTML/simple_html (0.00s)
    --- PASS: TestSafeEscapeHTML/quotes_and_ampersand (0.00s)
    --- PASS: TestSafeEscapeHTML/single_quote (0.00s)
=== RUN   TestSafeEscapeJavaScriptString
=== RUN   TestSafeEscapeJavaScriptString/empty
=== RUN   TestSafeEscapeJavaScriptString/simple_string
=== RUN   TestSafeEscapeJavaScriptString/with_quotes
=== RUN   TestSafeEscapeJavaScriptString/with_newline
=== RUN   TestSafeEscapeJavaScriptString/with_backslash
=== RUN   TestSafeEscapeJavaScriptString/all_together
--- PASS: TestSafeEscapeJavaScriptString (0.00s)
    --- PASS: TestSafeEscapeJavaScriptString/empty (0.00s)
    --- PASS: TestSafeEscapeJavaScriptString/simple_string (0.00s)
    --- PASS: TestSafeEscapeJavaScriptString/with_quotes (0.00s)
    --- PASS: TestSafeEscapeJavaScriptString/with_newline (0.00s)
    --- PASS: TestSafeEscapeJavaScriptString/with_backslash (0.00s)
    --- PASS: TestSafeEscapeJavaScriptString/all_together (0.00s)
=== RUN   TestStripJSONStringQuotes
=== RUN   TestStripJSONStringQuotes/valid_simple
=== RUN   TestStripJSONStringQuotes/valid_with_newline
=== RUN   TestStripJSONStringQuotes/valid_with_quote
=== RUN   TestStripJSONStringQuotes/valid_with_backslash
=== RUN   TestStripJSONStringQuotes/empty_content
=== RUN   TestStripJSONStringQuotes/error_not_a_string
=== RUN   TestStripJSONStringQuotes/error_no_leading_quote
=== RUN   TestStripJSONStringQuotes/error_no_trailing_quote
=== RUN   TestStripJSONStringQuotes/error_only_one_quote
=== RUN   TestStripJSONStringQuotes/error_invalid_internal_escape
--- PASS: TestStripJSONStringQuotes (0.00s)
    --- PASS: TestStripJSONStringQuotes/valid_simple (0.00s)
    --- PASS: TestStripJSONStringQuotes/valid_with_newline (0.00s)
    --- PASS: TestStripJSONStringQuotes/valid_with_quote (0.00s)
    --- PASS: TestStripJSONStringQuotes/valid_with_backslash (0.00s)
    --- PASS: TestStripJSONStringQuotes/empty_content (0.00s)
    --- PASS: TestStripJSONStringQuotes/error_not_a_string (0.00s)
    --- PASS: TestStripJSONStringQuotes/error_no_leading_quote (0.00s)
    --- PASS: TestStripJSONStringQuotes/error_no_trailing_quote (0.00s)
    --- PASS: TestStripJSONStringQuotes/error_only_one_quote (0.00s)
    --- PASS: TestStripJSONStringQuotes/error_invalid_internal_escape (0.00s)
=== RUN   TestToolListAPIFiles
=== RUN   TestToolListAPIFiles/Correct_Args_(None)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListAPIFilesCorrect_Args_(None)1526977067/001
    helpers.go:67: [ERROR] TOOL ListAPIFiles NOT IMPLEMENTED
--- PASS: TestToolListAPIFiles (0.00s)
    --- PASS: TestToolListAPIFiles/Correct_Args_(None) (0.00s)
=== RUN   TestToolDeleteAPIFile
=== RUN   TestToolDeleteAPIFile/Correct_Args
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteAPIFileCorrect_Args1995416173/001
    helpers.go:67: [ERROR] TOOL DeleteAPIFile NOT IMPLEMENTED
--- PASS: TestToolDeleteAPIFile (0.00s)
    --- PASS: TestToolDeleteAPIFile/Correct_Args (0.00s)
=== RUN   TestToolUploadFile
=== RUN   TestToolUploadFile/Correct_Args_(Path_Only)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolUploadFileCorrect_Args_(Path_Only)3472357880/001
    helpers.go:67: [ERROR] TOOL UploadFile NOT IMPLEMENTED
--- PASS: TestToolUploadFile (0.00s)
    --- PASS: TestToolUploadFile/Correct_Args_(Path_Only) (0.00s)
=== RUN   TestToolSyncFiles
=== RUN   TestToolSyncFiles/Correct_Args_(Min_Required)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolSyncFilesCorrect_Args_(Min_Required)2757841719/001
    tools_file_api_test.go:34: Expected error wrapping [feature not implemented], got: TOOL.SyncFiles: LLM client is not a compatible GenAI client or is not initialized
--- FAIL: TestToolSyncFiles (0.00s)
    --- FAIL: TestToolSyncFiles/Correct_Args_(Min_Required) (0.00s)
=== RUN   TestToolDeleteFile
=== RUN   TestToolDeleteFile/Delete_Existing_File
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileDelete_Existing_File1008892994/001
    helpers.go:80: [INFO] Tool: DeleteFile] Validated path: /tmp/TestToolDeleteFileDelete_Existing_File1008892994/001/deleteMe.txt. Attempting deletion.
    helpers.go:80: [INFO] Tool: DeleteFile] Successfully deleted: deleteMe.txt
=== RUN   TestToolDeleteFile/Delete_Empty_Directory
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileDelete_Empty_Directory2694128856/001
    helpers.go:80: [INFO] Tool: DeleteFile] Validated path: /tmp/TestToolDeleteFileDelete_Empty_Directory2694128856/001/deleteMeDir. Attempting deletion.
    helpers.go:80: [INFO] Tool: DeleteFile] Successfully deleted: deleteMeDir
=== RUN   TestToolDeleteFile/Delete_Non-Existent_File
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileDelete_Non-Existent_File950633950/001
    helpers.go:80: [INFO] Tool: DeleteFile] Validated path: /tmp/TestToolDeleteFileDelete_Non-Existent_File950633950/001/noSuchFile.txt. Attempting deletion.
    helpers.go:80: [INFO] Tool: DeleteFile] Info: Path not found, nothing to delete: noSuchFile.txt
=== RUN   TestToolDeleteFile/Delete_Non-Empty_Directory
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileDelete_Non-Empty_Directory4252117948/001
    helpers.go:80: [INFO] Tool: DeleteFile] Validated path: /tmp/TestToolDeleteFileDelete_Non-Empty_Directory4252117948/001/dontDeleteMeDir. Attempting deletion.
    helpers.go:82: [ERROR] Tool: DeleteFile] Error: Failed to delete 'dontDeleteMeDir': remove /tmp/TestToolDeleteFileDelete_Non-Empty_Directory4252117948/001/dontDeleteMeDir: directory not empty
=== RUN   TestToolDeleteFile/Validation_Wrong_Arg_Type
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileValidation_Wrong_Arg_Type2774149943/001
=== RUN   TestToolDeleteFile/Path_Outside_Sandbox
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFilePath_Outside_Sandbox2209538449/001
    helpers.go:80: [INFO] Tool: DeleteFile] Path security error for "../someFile": NeuroScript Error 10: relative path "../someFile" resolves to "/tmp/TestToolDeleteFilePath_Outside_Sandbox2209538449/someFile" which is outside the allowed directory "/tmp/TestToolDeleteFilePath_Outside_Sandbox2209538449/001" (wrapped: path resolves outside allowed directory) (Sandbox Root: /tmp/TestToolDeleteFilePath_Outside_Sandbox2209538449/001)
=== RUN   TestToolDeleteFile/Validation_Missing_Arg
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileValidation_Missing_Arg15425701/001
=== RUN   TestToolDeleteFile/Validation_Nil_Arg
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileValidation_Nil_Arg2179539519/001
=== RUN   TestToolDeleteFile/Validation_Empty_String_Arg
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDeleteFileValidation_Empty_String_Arg437285556/001
--- PASS: TestToolDeleteFile (0.01s)
    --- PASS: TestToolDeleteFile/Delete_Existing_File (0.00s)
    --- PASS: TestToolDeleteFile/Delete_Empty_Directory (0.00s)
    --- PASS: TestToolDeleteFile/Delete_Non-Existent_File (0.00s)
    --- PASS: TestToolDeleteFile/Delete_Non-Empty_Directory (0.00s)
    --- PASS: TestToolDeleteFile/Validation_Wrong_Arg_Type (0.00s)
    --- PASS: TestToolDeleteFile/Path_Outside_Sandbox (0.00s)
    --- PASS: TestToolDeleteFile/Validation_Missing_Arg (0.00s)
    --- PASS: TestToolDeleteFile/Validation_Nil_Arg (0.00s)
    --- PASS: TestToolDeleteFile/Validation_Empty_String_Arg (0.00s)
=== RUN   TestToolListDirectoryValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListDirectoryValidation3698745820/001
=== RUN   TestToolListDirectoryValidation/Correct_Args_(Path_Only)
=== RUN   TestToolListDirectoryValidation/Correct_Args_(Path_and_Recursive)
=== RUN   TestToolListDirectoryValidation/Correct_Args_(Path_and_Nil_Recursive)
=== RUN   TestToolListDirectoryValidation/Wrong_Arg_Count
=== RUN   TestToolListDirectoryValidation/Wrong_Path_Type
=== RUN   TestToolListDirectoryValidation/Wrong_Recursive_Type
--- PASS: TestToolListDirectoryValidation (0.00s)
    --- PASS: TestToolListDirectoryValidation/Correct_Args_(Path_Only) (0.00s)
    --- PASS: TestToolListDirectoryValidation/Correct_Args_(Path_and_Recursive) (0.00s)
    --- PASS: TestToolListDirectoryValidation/Correct_Args_(Path_and_Nil_Recursive) (0.00s)
    --- PASS: TestToolListDirectoryValidation/Wrong_Arg_Count (0.00s)
    --- PASS: TestToolListDirectoryValidation/Wrong_Path_Type (0.00s)
    --- PASS: TestToolListDirectoryValidation/Wrong_Recursive_Type (0.00s)
=== RUN   TestToolListDirectoryFunctional
=== RUN   TestToolListDirectoryFunctional/List_Root_NonRecursive
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListDirectoryFunctionalList_Root_NonRecursive3726694432/001
=== RUN   TestToolListDirectoryFunctional/List_Root_Recursive
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListDirectoryFunctionalList_Root_Recursive2607763949/001
=== RUN   TestToolListDirectoryFunctional/Error_PathIsFile
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListDirectoryFunctionalError_PathIsFile3500178346/001
--- PASS: TestToolListDirectoryFunctional (0.00s)
    --- PASS: TestToolListDirectoryFunctional/List_Root_NonRecursive (0.00s)
    --- PASS: TestToolListDirectoryFunctional/List_Root_Recursive (0.00s)
    --- PASS: TestToolListDirectoryFunctional/Error_PathIsFile (0.00s)
=== RUN   TestToolMkdirValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMkdirValidation3325708422/001
=== RUN   TestToolMkdirValidation/Correct_Args
=== RUN   TestToolMkdirValidation/Wrong_Arg_Count
=== RUN   TestToolMkdirValidation/Wrong_Arg_Type
=== RUN   TestToolMkdirValidation/Empty_Path
=== RUN   TestToolMkdirValidation/Current_Dir_Path
--- PASS: TestToolMkdirValidation (0.00s)
    --- PASS: TestToolMkdirValidation/Correct_Args (0.00s)
    --- PASS: TestToolMkdirValidation/Wrong_Arg_Count (0.00s)
    --- PASS: TestToolMkdirValidation/Wrong_Arg_Type (0.00s)
    --- PASS: TestToolMkdirValidation/Empty_Path (0.00s)
    --- PASS: TestToolMkdirValidation/Current_Dir_Path (0.00s)
=== RUN   TestToolMkdirFunctional
=== RUN   TestToolMkdirFunctional/Create_Single_Dir
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMkdirFunctionalCreate_Single_Dir2936836893/001
=== RUN   TestToolMkdirFunctional/Create_Nested_Dir
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMkdirFunctionalCreate_Nested_Dir3437524054/001
=== RUN   TestToolMkdirFunctional/Error_PathIsFile
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMkdirFunctionalError_PathIsFile384554672/001
=== RUN   TestToolMkdirFunctional/Success_DirExists
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMkdirFunctionalSuccess_DirExists4262492849/001
--- PASS: TestToolMkdirFunctional (0.00s)
    --- PASS: TestToolMkdirFunctional/Create_Single_Dir (0.00s)
    --- PASS: TestToolMkdirFunctional/Create_Nested_Dir (0.00s)
    --- PASS: TestToolMkdirFunctional/Error_PathIsFile (0.00s)
    --- PASS: TestToolMkdirFunctional/Success_DirExists (0.00s)
=== RUN   TestToolMoveFileValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMoveFileValidation3096379835/001
=== RUN   TestToolMoveFileValidation/Wrong_Arg_Count_(None)
=== RUN   TestToolMoveFileValidation/Wrong_Arg_Count_(One)
=== RUN   TestToolMoveFileValidation/Wrong_Arg_Count_(Three)
=== RUN   TestToolMoveFileValidation/Nil_First_Arg
=== RUN   TestToolMoveFileValidation/Nil_Second_Arg
=== RUN   TestToolMoveFileValidation/Wrong_First_Arg_Type
=== RUN   TestToolMoveFileValidation/Wrong_Second_Arg_Type
--- PASS: TestToolMoveFileValidation (0.00s)
    --- PASS: TestToolMoveFileValidation/Wrong_Arg_Count_(None) (0.00s)
    --- PASS: TestToolMoveFileValidation/Wrong_Arg_Count_(One) (0.00s)
    --- PASS: TestToolMoveFileValidation/Wrong_Arg_Count_(Three) (0.00s)
    --- PASS: TestToolMoveFileValidation/Nil_First_Arg (0.00s)
    --- PASS: TestToolMoveFileValidation/Nil_Second_Arg (0.00s)
    --- PASS: TestToolMoveFileValidation/Wrong_First_Arg_Type (0.00s)
    --- PASS: TestToolMoveFileValidation/Wrong_Second_Arg_Type (0.00s)
=== RUN   TestToolMoveFileFunctional
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMoveFileFunctional1899186965/002
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMoveFileFunctional1899186965/001
=== RUN   TestToolMoveFileFunctional/Success:_Correct_Args_(from_validation)
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Validated paths: Source 'source.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/source.txt'), Dest 'destination.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/destination.txt')
    helpers.go:80: [INFO] Tool: MoveFile] Attempting rename/move: '/tmp/TestToolMoveFileFunctional1899186965/001/source.txt' -> '/tmp/TestToolMoveFileFunctional1899186965/001/destination.txt'
    helpers.go:80: [INFO] Tool: MoveFile] Successfully moved/renamed 'source.txt' to 'destination.txt'
=== RUN   TestToolMoveFileFunctional/Success:_Rename_file
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Validated paths: Source 'old.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/old.txt'), Dest 'new.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/new.txt')
    helpers.go:80: [INFO] Tool: MoveFile] Attempting rename/move: '/tmp/TestToolMoveFileFunctional1899186965/001/old.txt' -> '/tmp/TestToolMoveFileFunctional1899186965/001/new.txt'
    helpers.go:80: [INFO] Tool: MoveFile] Successfully moved/renamed 'old.txt' to 'new.txt'
=== RUN   TestToolMoveFileFunctional/Success:_Move_file_into_existing_subdir
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Validated paths: Source 'move_me.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/move_me.txt'), Dest 'subdir/moved.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/subdir/moved.txt')
    helpers.go:80: [INFO] Tool: MoveFile] Attempting rename/move: '/tmp/TestToolMoveFileFunctional1899186965/001/move_me.txt' -> '/tmp/TestToolMoveFileFunctional1899186965/001/subdir/moved.txt'
    helpers.go:80: [INFO] Tool: MoveFile] Successfully moved/renamed 'move_me.txt' to 'subdir/moved.txt'
=== RUN   TestToolMoveFileFunctional/Fail:_Source_does_not_exist
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Validated paths: Source 'nonexistent_source.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/nonexistent_source.txt'), Dest 'any_dest.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/any_dest.txt')
    helpers.go:81: [WARN] Tool: MoveFile] Source check failed: MoveFile: source path 'nonexistent_source.txt' does not exist: stat /tmp/TestToolMoveFileFunctional1899186965/001/nonexistent_source.txt: no such file or directory
=== RUN   TestToolMoveFileFunctional/Fail:_Destination_exists
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Validated paths: Source 'src_exists.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/src_exists.txt'), Dest 'dest_exists.txt' (abs: '/tmp/TestToolMoveFileFunctional1899186965/001/dest_exists.txt')
    helpers.go:81: [WARN] Tool: MoveFile] Error: MoveFile: destination path 'dest_exists.txt' already exists (resolved: /tmp/TestToolMoveFileFunctional1899186965/001/dest_exists.txt)
=== RUN   TestToolMoveFileFunctional/Fail:_Path_outside_sandbox_(Source)
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Invalid source path '../outside_src.txt': NeuroScript Error 10: relative path "../outside_src.txt" resolves to "/tmp/TestToolMoveFileFunctional1899186965/outside_src.txt" which is outside the allowed directory "/tmp/TestToolMoveFileFunctional1899186965/001" (wrapped: path resolves outside allowed directory)
=== RUN   TestToolMoveFileFunctional/Fail:_Path_outside_sandbox_(Destination)
=== NAME  TestToolMoveFileFunctional
    helpers.go:80: [INFO] Tool: MoveFile] Invalid destination path '../outside_dest.txt': NeuroScript Error 10: relative path "../outside_dest.txt" resolves to "/tmp/TestToolMoveFileFunctional1899186965/outside_dest.txt" which is outside the allowed directory "/tmp/TestToolMoveFileFunctional1899186965/001" (wrapped: path resolves outside allowed directory)
=== RUN   TestToolMoveFileFunctional/Fail:_Empty_Source_Path
=== RUN   TestToolMoveFileFunctional/Fail:_Empty_Destination_Path
--- PASS: TestToolMoveFileFunctional (0.00s)
    --- PASS: TestToolMoveFileFunctional/Success:_Correct_Args_(from_validation) (0.00s)
    --- PASS: TestToolMoveFileFunctional/Success:_Rename_file (0.00s)
    --- PASS: TestToolMoveFileFunctional/Success:_Move_file_into_existing_subdir (0.00s)
    --- PASS: TestToolMoveFileFunctional/Fail:_Source_does_not_exist (0.00s)
    --- PASS: TestToolMoveFileFunctional/Fail:_Destination_exists (0.00s)
    --- PASS: TestToolMoveFileFunctional/Fail:_Path_outside_sandbox_(Source) (0.00s)
    --- PASS: TestToolMoveFileFunctional/Fail:_Path_outside_sandbox_(Destination) (0.00s)
    --- PASS: TestToolMoveFileFunctional/Fail:_Empty_Source_Path (0.00s)
    --- PASS: TestToolMoveFileFunctional/Fail:_Empty_Destination_Path (0.00s)
=== RUN   TestToolReadFile
=== RUN   TestToolReadFile/Read_Existing_File
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolReadFileRead_Existing_File1457579645/001
    helpers.go:67: [DEBUG] Tool: ReadFile attempting to read validated_path=/tmp/TestToolReadFileRead_Existing_File1457579645/001/readTest.txt original_relative_path=readTest.txt sandbox_root=/tmp/TestToolReadFileRead_Existing_File1457579645/001
    helpers.go:67: [DEBUG] Tool: ReadFile successful file_path=readTest.txt bytes_read=12
=== RUN   TestToolReadFile/Read_Non-Existent_File
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolReadFileRead_Non-Existent_File447272777/001
    helpers.go:67: [DEBUG] Tool: ReadFile attempting to read validated_path=/tmp/TestToolReadFileRead_Non-Existent_File447272777/001/nonexistent.txt original_relative_path=nonexistent.txt sandbox_root=/tmp/TestToolReadFileRead_Non-Existent_File447272777/001
    helpers.go:67: [DEBUG] ReadFile: file not found 'nonexistent.txt'
=== RUN   TestToolReadFile/Validation_Empty_Filepath_Arg
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolReadFileValidation_Empty_Filepath_Arg3731674374/001
=== RUN   TestToolReadFile/Path_Outside_Sandbox
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolReadFilePath_Outside_Sandbox2045587072/001
    helpers.go:67: [WARN] Tool: ReadFile path validation failed relative_path=../outside.txt sandbox_root=/tmp/TestToolReadFilePath_Outside_Sandbox2045587072/001 error=NeuroScript Error 10: relative path "../outside.txt" resolves to "/tmp/TestToolReadFilePath_Outside_Sandbox2045587072/outside.txt" which is outside the allowed directory "/tmp/TestToolReadFilePath_Outside_Sandbox2045587072/001" (wrapped: path resolves outside allowed directory)
--- PASS: TestToolReadFile (0.00s)
    --- PASS: TestToolReadFile/Read_Existing_File (0.00s)
    --- PASS: TestToolReadFile/Read_Non-Existent_File (0.00s)
    --- PASS: TestToolReadFile/Validation_Empty_Filepath_Arg (0.00s)
    --- PASS: TestToolReadFile/Path_Outside_Sandbox (0.00s)
=== RUN   TestToolStat
=== RUN   TestToolStat/Stat_Existing_File
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolStatStat_Existing_File3944721137/001
    helpers.go:67: [DEBUG] Tool: StatPath attempting to stat validated path validated_path=/tmp/TestToolStatStat_Existing_File3944721137/001/test_file.txt original_path=test_file.txt
    helpers.go:67: [DEBUG] Tool: StatPath] Stat successful path=test_file.txt
=== RUN   TestToolStat/Stat_Existing_Directory
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolStatStat_Existing_Directory1502587894/001
    helpers.go:67: [DEBUG] Tool: StatPath attempting to stat validated path validated_path=/tmp/TestToolStatStat_Existing_Directory1502587894/001/test_subdir original_path=test_subdir
    helpers.go:67: [DEBUG] Tool: StatPath] Stat successful path=test_subdir
=== RUN   TestToolStat/Stat_Non-existent_File
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolStatStat_Non-existent_File1390342765/001
    helpers.go:67: [DEBUG] Tool: StatPath attempting to stat validated path validated_path=/tmp/TestToolStatStat_Non-existent_File1390342765/001/nonexistent.txt original_path=nonexistent.txt
    helpers.go:67: [DEBUG] Tool: StatPath] %s (Logger Warning: odd number of key-value arguments provided) StatPath: path not found 'nonexistent.txt'
=== RUN   TestToolStat/Stat_Path_Outside_Sandbox
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolStatStat_Path_Outside_Sandbox2650957175/001
    helpers.go:67: [DEBUG] Tool: StatPath] Path validation failed error=NeuroScript Error 10: relative path "../outside.txt" resolves to "/tmp/TestToolStatStat_Path_Outside_Sandbox2650957175/outside.txt" which is outside the allowed directory "/tmp/TestToolStatStat_Path_Outside_Sandbox2650957175/001" (wrapped: path resolves outside allowed directory) path=../outside.txt
=== RUN   TestToolStat/Stat_Empty_Path
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolStatStat_Empty_Path2427171408/001
--- PASS: TestToolStat (0.00s)
    --- PASS: TestToolStat/Stat_Existing_File (0.00s)
    --- PASS: TestToolStat/Stat_Existing_Directory (0.00s)
    --- PASS: TestToolStat/Stat_Non-existent_File (0.00s)
    --- PASS: TestToolStat/Stat_Path_Outside_Sandbox (0.00s)
    --- PASS: TestToolStat/Stat_Empty_Path (0.00s)
=== RUN   TestToolWalkDir
=== RUN   TestToolWalkDir/Walk_from_root
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWalkDirWalk_from_root318885547/001
    helpers.go:79: [DEBUG] Tool: WalkDir] Validated base path: /tmp/TestToolWalkDirWalk_from_root318885547/001 (Original Relative: ".", Sandbox: "/tmp/TestToolWalkDirWalk_from_root318885547/001")
    helpers.go:79: [DEBUG] Tool: WalkDir] Walk successful%!(EXTRA string=path, string=., string=entries_found, int=4)
=== RUN   TestToolWalkDir/Walk_from_subdir1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWalkDirWalk_from_subdir12154524049/001
    helpers.go:79: [DEBUG] Tool: WalkDir] Validated base path: /tmp/TestToolWalkDirWalk_from_subdir12154524049/001/dir1 (Original Relative: "dir1", Sandbox: "/tmp/TestToolWalkDirWalk_from_subdir12154524049/001")
    helpers.go:79: [DEBUG] Tool: WalkDir] Walk successful%!(EXTRA string=path, string=dir1, string=entries_found, int=3)
=== RUN   TestToolWalkDir/Walk_non-existent_path
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWalkDirWalk_non-existent_path990878674/001
    helpers.go:79: [DEBUG] Tool: WalkDir] Validated base path: /tmp/TestToolWalkDirWalk_non-existent_path990878674/001/nonexistent (Original Relative: "nonexistent", Sandbox: "/tmp/TestToolWalkDirWalk_non-existent_path990878674/001")
    helpers.go:67: [DEBUG] Tool: WalkDir] %s (Logger Warning: odd number of key-value arguments provided) WalkDir: start path not found 'nonexistent'
--- PASS: TestToolWalkDir (0.00s)
    --- PASS: TestToolWalkDir/Walk_from_root (0.00s)
    --- PASS: TestToolWalkDir/Walk_from_subdir1 (0.00s)
    --- PASS: TestToolWalkDir/Walk_non-existent_path (0.00s)
=== RUN   TestToolWriteFileValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWriteFileValidation4011220910/001
=== RUN   TestToolWriteFileValidation/Write_-_Correct_args
=== RUN   TestToolWriteFileValidation/Write_-_Wrong_content_type
=== RUN   TestToolWriteFileValidation/Write_-_Wrong_arg_count_(too_few)
=== RUN   TestToolWriteFileValidation/Write_-_Path_outside_sandbox
=== NAME  TestToolWriteFileValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWriteFileValidation4011220910/002
=== RUN   TestToolWriteFileValidation/Append_-_Correct_args
=== RUN   TestToolWriteFileValidation/Append_-_Wrong_arg_count
=== RUN   TestToolWriteFileValidation/Append_-_Path_outside_sandbox
--- PASS: TestToolWriteFileValidation (0.00s)
    --- PASS: TestToolWriteFileValidation/Write_-_Correct_args (0.00s)
    --- PASS: TestToolWriteFileValidation/Write_-_Wrong_content_type (0.00s)
    --- PASS: TestToolWriteFileValidation/Write_-_Wrong_arg_count_(too_few) (0.00s)
    --- PASS: TestToolWriteFileValidation/Write_-_Path_outside_sandbox (0.00s)
    --- PASS: TestToolWriteFileValidation/Append_-_Correct_args (0.00s)
    --- PASS: TestToolWriteFileValidation/Append_-_Wrong_arg_count (0.00s)
    --- PASS: TestToolWriteFileValidation/Append_-_Path_outside_sandbox (0.00s)
=== RUN   TestToolWriteFileFunctional
=== RUN   TestToolWriteFileFunctional/Write_to_new_file
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWriteFileFunctionalWrite_to_new_file1014323390/001
=== RUN   TestToolWriteFileFunctional/Overwrite_existing_file
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWriteFileFunctionalOverwrite_existing_file2141801017/001
=== RUN   TestToolWriteFileFunctional/Append_to_existing_file
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWriteFileFunctionalAppend_to_existing_file3807481478/001
=== RUN   TestToolWriteFileFunctional/Append_to_non-existent_file
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolWriteFileFunctionalAppend_to_non-existent_file3432605099/001
--- PASS: TestToolWriteFileFunctional (0.00s)
    --- PASS: TestToolWriteFileFunctional/Write_to_new_file (0.00s)
    --- PASS: TestToolWriteFileFunctional/Overwrite_existing_file (0.00s)
    --- PASS: TestToolWriteFileFunctional/Append_to_existing_file (0.00s)
    --- PASS: TestToolWriteFileFunctional/Append_to_non-existent_file (0.00s)
=== RUN   TestParseGitStatusOutput
=== RUN   TestParseGitStatusOutput/Clean_Repository
=== RUN   TestParseGitStatusOutput/Clean_Repository_(No_Remote)
=== RUN   TestParseGitStatusOutput/Modified_File_(Worktree)
=== RUN   TestParseGitStatusOutput/Staged_Add_&_Untracked_&_Ahead
=== RUN   TestParseGitStatusOutput/Staged_Modify,_Unstaged_Delete,_Untracked,_Behind
=== RUN   TestParseGitStatusOutput/Renamed_(Staged)
=== RUN   TestParseGitStatusOutput/Unborn_Branch
=== RUN   TestParseGitStatusOutput/Detached_HEAD
=== RUN   TestParseGitStatusOutput/Path_with_Spaces_(Quoted)
=== RUN   TestParseGitStatusOutput/Empty_Input_String
=== RUN   TestParseGitStatusOutput/Malformed_Branch_Line
=== RUN   TestParseGitStatusOutput/Only_Branch_Line_(Ahead)
--- PASS: TestParseGitStatusOutput (0.00s)
    --- PASS: TestParseGitStatusOutput/Clean_Repository (0.00s)
    --- PASS: TestParseGitStatusOutput/Clean_Repository_(No_Remote) (0.00s)
    --- PASS: TestParseGitStatusOutput/Modified_File_(Worktree) (0.00s)
    --- PASS: TestParseGitStatusOutput/Staged_Add_&_Untracked_&_Ahead (0.00s)
    --- PASS: TestParseGitStatusOutput/Staged_Modify,_Unstaged_Delete,_Untracked,_Behind (0.00s)
    --- PASS: TestParseGitStatusOutput/Renamed_(Staged) (0.00s)
    --- PASS: TestParseGitStatusOutput/Unborn_Branch (0.00s)
    --- PASS: TestParseGitStatusOutput/Detached_HEAD (0.00s)
    --- PASS: TestParseGitStatusOutput/Path_with_Spaces_(Quoted) (0.00s)
    --- PASS: TestParseGitStatusOutput/Empty_Input_String (0.00s)
    --- PASS: TestParseGitStatusOutput/Malformed_Branch_Line (0.00s)
    --- PASS: TestParseGitStatusOutput/Only_Branch_Line_(Ahead) (0.00s)
=== RUN   TestToolGitBranchValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitBranchValidation1192620731/001
=== RUN   TestToolGitBranchValidation/Correct_Args_(Create)
=== NAME  TestToolGitBranchValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitBranchValidation1192620731/002
=== RUN   TestToolGitBranchValidation/Wrong_Arg_Type_(Name)
--- PASS: TestToolGitBranchValidation (0.03s)
    --- PASS: TestToolGitBranchValidation/Correct_Args_(Create) (0.00s)
    --- PASS: TestToolGitBranchValidation/Wrong_Arg_Type_(Name) (0.00s)
=== RUN   TestToolGitCheckoutValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitCheckoutValidation3957697104/001
=== RUN   TestToolGitCheckoutValidation/Correct_Args_(Checkout)
=== NAME  TestToolGitCheckoutValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitCheckoutValidation3957697104/002
=== RUN   TestToolGitCheckoutValidation/Correct_Args_(Create_and_Checkout)
--- PASS: TestToolGitCheckoutValidation (0.03s)
    --- PASS: TestToolGitCheckoutValidation/Correct_Args_(Checkout) (0.00s)
    --- PASS: TestToolGitCheckoutValidation/Correct_Args_(Create_and_Checkout) (0.00s)
=== RUN   TestToolGitRmValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitRmValidation3994615639/001
=== RUN   TestToolGitRmValidation/Correct_Args_(Single_Path_String)
=== NAME  TestToolGitRmValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitRmValidation3994615639/002
=== RUN   TestToolGitRmValidation/Wrong_Arg_Type_(Path)
--- PASS: TestToolGitRmValidation (0.04s)
    --- PASS: TestToolGitRmValidation/Correct_Args_(Single_Path_String) (0.00s)
    --- PASS: TestToolGitRmValidation/Wrong_Arg_Type_(Path) (0.00s)
=== RUN   TestToolGitMergeValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitMergeValidation1173155361/001
=== RUN   TestToolGitMergeValidation/Correct_Args
=== NAME  TestToolGitMergeValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitMergeValidation1173155361/002
=== RUN   TestToolGitMergeValidation/Wrong_Arg_Type_(Branch)
--- PASS: TestToolGitMergeValidation (0.05s)
    --- PASS: TestToolGitMergeValidation/Correct_Args (0.00s)
    --- PASS: TestToolGitMergeValidation/Wrong_Arg_Type_(Branch) (0.00s)
=== RUN   TestToolGitPullValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitPullValidation483874570/001
=== RUN   TestToolGitPullValidation/Wrong_Arg_Type_(Remote_Name)
--- PASS: TestToolGitPullValidation (0.02s)
    --- PASS: TestToolGitPullValidation/Wrong_Arg_Type_(Remote_Name) (0.00s)
=== RUN   TestToolGitPushValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitPushValidation691776676/001
=== RUN   TestToolGitPushValidation/Wrong_Arg_Type_(Branch_Name)
--- PASS: TestToolGitPushValidation (0.01s)
    --- PASS: TestToolGitPushValidation/Wrong_Arg_Type_(Branch_Name) (0.00s)
=== RUN   TestToolGitDiffValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitDiffValidation3381133129/001
=== RUN   TestToolGitDiffValidation/Correct_Args_(Cached_Only)
=== NAME  TestToolGitDiffValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGitDiffValidation3381133129/002
=== RUN   TestToolGitDiffValidation/Wrong_Arg_Type
--- PASS: TestToolGitDiffValidation (0.03s)
    --- PASS: TestToolGitDiffValidation/Correct_Args_(Cached_Only) (0.00s)
    --- PASS: TestToolGitDiffValidation/Wrong_Arg_Type (0.00s)
=== RUN   TestGoDiagnosticTools
=== RUN   TestGoDiagnosticTools/GoVetInvocation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestGoDiagnosticToolsGoVetInvocation2946749286/001
    tools_go_diagnostics_test.go:37: Test interpreter created with sandbox: /tmp/TestGoDiagnosticToolsGoVetInvocation2946749286/001
    helpers.go:67: [DEBUG] [GO-HELPER] Executing command command=go args=[vet ./...] directory=/tmp/TestGoDiagnosticToolsGoVetInvocation2946749286/001
    helpers.go:67: [WARN] [GO-HELPER] Command failed command=go args=[vet ./...] dir=/tmp/TestGoDiagnosticToolsGoVetInvocation2946749286/001 exit_code=1 stderr=pattern ./...: directory prefix . does not contain main module or its selected dependencies
        
    tools_go_diagnostics_test.go:54: GoVet result: map[exit_code:1 stderr:pattern ./...: directory prefix . does not contain main module or its selected dependencies
         stdout: success:false]
=== RUN   TestGoDiagnosticTools/StaticcheckInvocation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestGoDiagnosticToolsStaticcheckInvocation3854407511/001
    tools_go_diagnostics_test.go:62: Test interpreter created with sandbox: /tmp/TestGoDiagnosticToolsStaticcheckInvocation3854407511/001
    helpers.go:67: [DEBUG] ResolvePath: Received relative path. input=. joined_abs=/tmp/TestGoDiagnosticToolsStaticcheckInvocation3854407511/001
    helpers.go:67: [DEBUG] Path resolved successfully within sandbox. input=. output=/tmp/TestGoDiagnosticToolsStaticcheckInvocation3854407511/001
    helpers.go:67: [DEBUG] [Shell.Execute] Preparing command command=staticcheck args=[./...] directory=/tmp/TestGoDiagnosticToolsStaticcheckInvocation3854407511/001
    helpers.go:67: [WARN] [Shell.Execute] Command failed command=staticcheck exit_code=1 stderr=
    tools_go_diagnostics_test.go:79: Staticcheck result: map[exit_code:1 stderr: stdout:-: pattern ./...: directory prefix . does not contain main module or its selected dependencies (compile)
         success:false]
--- PASS: TestGoDiagnosticTools (0.35s)
    --- PASS: TestGoDiagnosticTools/GoVetInvocation (0.06s)
    --- PASS: TestGoDiagnosticTools/StaticcheckInvocation (0.29s)
=== RUN   TestToolGoGetModuleInfo
=== RUN   TestToolGoGetModuleInfo/From_root_dir_(.)
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoGetModuleInfoFrom_root_dir_(.)2709543882/001
    helpers.go:67: [DEBUG] %s Called with relative directory: %q [TOOL-GoGetModuleInfo]=.
    helpers.go:67: [DEBUG] %s Resolved start directory to: %s [TOOL-GoGetModuleInfo]=/tmp/TestToolGoGetModuleInfoFrom_root_dir_(.)2709543882/001
    helpers.go:67: [DEBUG] %s Starting search for go.mod from: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_root_dir_(.)2709543882/001
    helpers.go:67: [DEBUG] %s Absolute starting directory: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_root_dir_(.)2709543882/001
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_root_dir_(.)2709543882/001/go.mod
    helpers.go:67: [DEBUG] %s Found go.mod at: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_root_dir_(.)2709543882/001/go.mod
    helpers.go:67: [DEBUG] %s Successfully parsed go.mod. Module: %s [FindGoMod]=example.com/modinfo_test
    helpers.go:67: [DEBUG] %s Successfully retrieved module info for %q [TOOL-GoGetModuleInfo]=example.com/modinfo_test
=== RUN   TestToolGoGetModuleInfo/From_subdir
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001
    helpers.go:67: [DEBUG] %s Called with relative directory: %q [TOOL-GoGetModuleInfo]=subdir
    helpers.go:67: [DEBUG] %s Resolved start directory to: %s [TOOL-GoGetModuleInfo]=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001/subdir
    helpers.go:67: [DEBUG] %s Starting search for go.mod from: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001/subdir
    helpers.go:67: [DEBUG] %s Absolute starting directory: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001/subdir
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001/subdir/go.mod
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001/go.mod
    helpers.go:67: [DEBUG] %s Found go.mod at: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoFrom_subdir3457201825/001/go.mod
    helpers.go:67: [DEBUG] %s Successfully parsed go.mod. Module: %s [FindGoMod]=example.com/modinfo_test
    helpers.go:67: [DEBUG] %s Successfully retrieved module info for %q [TOOL-GoGetModuleInfo]=example.com/modinfo_test
=== RUN   TestToolGoGetModuleInfo/Directory_outside_sandbox
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoGetModuleInfoDirectory_outside_sandbox3511185679/001
    helpers.go:67: [DEBUG] %s Called with relative directory: %q [TOOL-GoGetModuleInfo]=../outside
    helpers.go:67: [ERROR] %s Path security error for start directory %q: %v (Logger Warning: odd number of key-value arguments provided) [TOOL-GoGetModuleInfo] ../outside NeuroScript Error 10: relative path "../outside" resolves to "/tmp/TestToolGoGetModuleInfoDirectory_outside_sandbox3511185679/outside" which is outside the allowed directory "/tmp/TestToolGoGetModuleInfoDirectory_outside_sandbox3511185679/001" (wrapped: path resolves outside allowed directory)
=== RUN   TestToolGoGetModuleInfo/Go.mod_not_found
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoGetModuleInfoGo.mod_not_found2744052375/001
    helpers.go:67: [DEBUG] %s Called with relative directory: %q [TOOL-GoGetModuleInfo]=.
    helpers.go:67: [DEBUG] %s Resolved start directory to: %s [TOOL-GoGetModuleInfo]=/tmp/TestToolGoGetModuleInfoGo.mod_not_found2744052375/001
    helpers.go:67: [DEBUG] %s Starting search for go.mod from: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoGo.mod_not_found2744052375/001
    helpers.go:67: [DEBUG] %s Absolute starting directory: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoGo.mod_not_found2744052375/001
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoGo.mod_not_found2744052375/001/go.mod
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/tmp/TestToolGoGetModuleInfoGo.mod_not_found2744052375/go.mod
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/tmp/go.mod
    helpers.go:67: [DEBUG] %s Checking: %s [FindGoMod]=/go.mod
    helpers.go:67: [DEBUG] %s Reached filesystem root, go.mod not found. (Logger Warning: odd number of key-value arguments provided) [FindGoMod]
    helpers.go:67: [WARN] %s No go.mod found starting from %q. [TOOL-GoGetModuleInfo]=.
=== RUN   TestToolGoGetModuleInfo/Wrong_arg_type
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoGetModuleInfoWrong_arg_type3982887672/001
--- PASS: TestToolGoGetModuleInfo (0.00s)
    --- PASS: TestToolGoGetModuleInfo/From_root_dir_(.) (0.00s)
    --- PASS: TestToolGoGetModuleInfo/From_subdir (0.00s)
    --- PASS: TestToolGoGetModuleInfo/Directory_outside_sandbox (0.00s)
    --- PASS: TestToolGoGetModuleInfo/Go.mod_not_found (0.00s)
    --- PASS: TestToolGoGetModuleInfo/Wrong_arg_type (0.00s)
=== RUN   TestToolGoFmt
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoFmt1849292991/001
=== RUN   TestToolGoFmt/Format_valid_code
=== RUN   TestToolGoFmt/Format_already_formatted_code
=== RUN   TestToolGoFmt/Format_invalid_code
=== RUN   TestToolGoFmt/Wrong_arg_type
--- PASS: TestToolGoFmt (0.00s)
    --- PASS: TestToolGoFmt/Format_valid_code (0.00s)
    --- PASS: TestToolGoFmt/Format_already_formatted_code (0.00s)
    --- PASS: TestToolGoFmt/Format_invalid_code (0.00s)
    --- PASS: TestToolGoFmt/Wrong_arg_type (0.00s)
=== RUN   TestToolGoImports
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolGoImports1214861498/001
=== RUN   TestToolGoImports/Add_missing_import
=== RUN   TestToolGoImports/Remove_unused_import
=== RUN   TestToolGoImports/Invalid_source
=== RUN   TestToolGoImports/Wrong_arg_type
--- PASS: TestToolGoImports (0.10s)
    --- PASS: TestToolGoImports/Add_missing_import (0.05s)
    --- PASS: TestToolGoImports/Remove_unused_import (0.05s)
    --- PASS: TestToolGoImports/Invalid_source (0.00s)
    --- PASS: TestToolGoImports/Wrong_arg_type (0.00s)
=== RUN   TestToolIOInputValidation
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolIOInputValidation3268520944/001
=== RUN   TestToolIOInputValidation/Valid_prompt_(string)
Enter name: === NAME  TestToolIOInputValidation
    helpers.go:67: [WARN] Tool: Input read error error=EOF
=== RUN   TestToolIOInputValidation/No_arguments_(optional_prompt)
=== NAME  TestToolIOInputValidation
    helpers.go:67: [WARN] Tool: Input read error error=EOF
=== RUN   TestToolIOInputValidation/Valid_argument_type_(nil_for_optional)
=== NAME  TestToolIOInputValidation
    helpers.go:67: [WARN] Tool: Input read error error=EOF
=== RUN   TestToolIOInputValidation/Incorrect_argument_type_(number)
=== RUN   TestToolIOInputValidation/Incorrect_argument_type_(bool)
--- PASS: TestToolIOInputValidation (0.00s)
    --- PASS: TestToolIOInputValidation/Valid_prompt_(string) (0.00s)
    --- PASS: TestToolIOInputValidation/No_arguments_(optional_prompt) (0.00s)
    --- PASS: TestToolIOInputValidation/Valid_argument_type_(nil_for_optional) (0.00s)
    --- PASS: TestToolIOInputValidation/Incorrect_argument_type_(number) (0.00s)
    --- PASS: TestToolIOInputValidation/Incorrect_argument_type_(bool) (0.00s)
=== RUN   TestToolListLength
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListLength190499417/001
=== RUN   TestToolListLength/Simple
=== RUN   TestToolListLength/Wrong_Type
--- PASS: TestToolListLength (0.00s)
    --- PASS: TestToolListLength/Simple (0.00s)
    --- PASS: TestToolListLength/Wrong_Type (0.00s)
=== RUN   TestToolListAppendPrepend
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListAppendPrepend1557571692/001
=== RUN   TestToolListAppendPrepend/Append_Simple
=== RUN   TestToolListAppendPrepend/Append_To_Empty
=== RUN   TestToolListAppendPrepend/Append_Wrong_Type
=== RUN   TestToolListAppendPrepend/Prepend_Simple
=== RUN   TestToolListAppendPrepend/Prepend_To_Empty
--- PASS: TestToolListAppendPrepend (0.00s)
    --- PASS: TestToolListAppendPrepend/Append_Simple (0.00s)
    --- PASS: TestToolListAppendPrepend/Append_To_Empty (0.00s)
    --- PASS: TestToolListAppendPrepend/Append_Wrong_Type (0.00s)
    --- PASS: TestToolListAppendPrepend/Prepend_Simple (0.00s)
    --- PASS: TestToolListAppendPrepend/Prepend_To_Empty (0.00s)
=== RUN   TestToolListGet
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListGet3706141549/001
=== RUN   TestToolListGet/Get_First
=== RUN   TestToolListGet/Get_Middle
=== RUN   TestToolListGet/Get_Last
=== RUN   TestToolListGet/Get_Nil_Element
=== RUN   TestToolListGet/OOB_High_No_Default
=== RUN   TestToolListGet/OOB_Low_No_Default
=== RUN   TestToolListGet/Empty_No_Default
=== RUN   TestToolListGet/OOB_High_With_Default
=== RUN   TestToolListGet/Wrong_Index_Type
=== RUN   TestToolListGet/Wrong_List_Type
--- PASS: TestToolListGet (0.00s)
    --- PASS: TestToolListGet/Get_First (0.00s)
    --- PASS: TestToolListGet/Get_Middle (0.00s)
    --- PASS: TestToolListGet/Get_Last (0.00s)
    --- PASS: TestToolListGet/Get_Nil_Element (0.00s)
    --- PASS: TestToolListGet/OOB_High_No_Default (0.00s)
    --- PASS: TestToolListGet/OOB_Low_No_Default (0.00s)
    --- PASS: TestToolListGet/Empty_No_Default (0.00s)
    --- PASS: TestToolListGet/OOB_High_With_Default (0.00s)
    --- PASS: TestToolListGet/Wrong_Index_Type (0.00s)
    --- PASS: TestToolListGet/Wrong_List_Type (0.00s)
=== RUN   TestToolListSlice
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListSlice3621716633/001
=== RUN   TestToolListSlice/Slice_Middle
=== RUN   TestToolListSlice/Slice_Clamp_High_End
=== RUN   TestToolListSlice/Slice_Clamp_Both
=== RUN   TestToolListSlice/Slice_Empty_List
=== RUN   TestToolListSlice/Wrong_List_Type
=== RUN   TestToolListSlice/Wrong_Start_Type
--- PASS: TestToolListSlice (0.00s)
    --- PASS: TestToolListSlice/Slice_Middle (0.00s)
    --- PASS: TestToolListSlice/Slice_Clamp_High_End (0.00s)
    --- PASS: TestToolListSlice/Slice_Clamp_Both (0.00s)
    --- PASS: TestToolListSlice/Slice_Empty_List (0.00s)
    --- PASS: TestToolListSlice/Wrong_List_Type (0.00s)
    --- PASS: TestToolListSlice/Wrong_Start_Type (0.00s)
=== RUN   TestToolListContains
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListContains3195039126/001
=== RUN   TestToolListContains/Contains_String
=== RUN   TestToolListContains/Contains_Float
=== RUN   TestToolListContains/Contains_Sub-List
=== RUN   TestToolListContains/Not_Contains_String
=== RUN   TestToolListContains/Empty_List
=== RUN   TestToolListContains/Wrong_List_Type
--- PASS: TestToolListContains (0.00s)
    --- PASS: TestToolListContains/Contains_String (0.00s)
    --- PASS: TestToolListContains/Contains_Float (0.00s)
    --- PASS: TestToolListContains/Contains_Sub-List (0.00s)
    --- PASS: TestToolListContains/Not_Contains_String (0.00s)
    --- PASS: TestToolListContains/Empty_List (0.00s)
    --- PASS: TestToolListContains/Wrong_List_Type (0.00s)
=== RUN   TestToolListReverse
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListReverse3169448819/001
=== RUN   TestToolListReverse/Reverse_Simple
=== RUN   TestToolListReverse/Reverse_Single
=== RUN   TestToolListReverse/Reverse_Empty
=== RUN   TestToolListReverse/Wrong_Type
--- PASS: TestToolListReverse (0.00s)
    --- PASS: TestToolListReverse/Reverse_Simple (0.00s)
    --- PASS: TestToolListReverse/Reverse_Single (0.00s)
    --- PASS: TestToolListReverse/Reverse_Empty (0.00s)
    --- PASS: TestToolListReverse/Wrong_Type (0.00s)
=== RUN   TestToolListSort
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListSort673743053/001
=== RUN   TestToolListSort/Sort_Strings
=== RUN   TestToolListSort/Sort_Floats
=== RUN   TestToolListSort/Sort_Mixed_Numbers
=== RUN   TestToolListSort/Sort_Empty
=== RUN   TestToolListSort/Sort_Mixed_String/Num
=== RUN   TestToolListSort/Sort_List_With_Nil_Element
=== RUN   TestToolListSort/Sort_Strings_Looking_Like_Numbers
=== RUN   TestToolListSort/Wrong_Type
--- PASS: TestToolListSort (0.00s)
    --- PASS: TestToolListSort/Sort_Strings (0.00s)
    --- PASS: TestToolListSort/Sort_Floats (0.00s)
    --- PASS: TestToolListSort/Sort_Mixed_Numbers (0.00s)
    --- PASS: TestToolListSort/Sort_Empty (0.00s)
    --- PASS: TestToolListSort/Sort_Mixed_String/Num (0.00s)
    --- PASS: TestToolListSort/Sort_List_With_Nil_Element (0.00s)
    --- PASS: TestToolListSort/Sort_Strings_Looking_Like_Numbers (0.00s)
    --- PASS: TestToolListSort/Wrong_Type (0.00s)
=== RUN   TestToolListIsEmpty
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListIsEmpty866621552/001
=== RUN   TestToolListIsEmpty/Is_Empty_True
=== RUN   TestToolListIsEmpty/Is_Empty_False
=== RUN   TestToolListIsEmpty/Wrong_Type
--- PASS: TestToolListIsEmpty (0.00s)
    --- PASS: TestToolListIsEmpty/Is_Empty_True (0.00s)
    --- PASS: TestToolListIsEmpty/Is_Empty_False (0.00s)
    --- PASS: TestToolListIsEmpty/Wrong_Type (0.00s)
=== RUN   TestToolListHead
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListHead2251834124/001
=== RUN   TestToolListHead/Head_Simple
=== RUN   TestToolListHead/Head_First_is_Nil
=== RUN   TestToolListHead/Head_Empty
=== RUN   TestToolListHead/Wrong_Type
--- PASS: TestToolListHead (0.00s)
    --- PASS: TestToolListHead/Head_Simple (0.00s)
    --- PASS: TestToolListHead/Head_First_is_Nil (0.00s)
    --- PASS: TestToolListHead/Head_Empty (0.00s)
    --- PASS: TestToolListHead/Wrong_Type (0.00s)
=== RUN   TestToolListRest
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListRest3537484275/001
=== RUN   TestToolListRest/Rest_Simple
=== RUN   TestToolListRest/Rest_Single
=== RUN   TestToolListRest/Rest_Empty
=== RUN   TestToolListRest/Wrong_Type
--- PASS: TestToolListRest (0.00s)
    --- PASS: TestToolListRest/Rest_Simple (0.00s)
    --- PASS: TestToolListRest/Rest_Single (0.00s)
    --- PASS: TestToolListRest/Rest_Empty (0.00s)
    --- PASS: TestToolListRest/Wrong_Type (0.00s)
=== RUN   TestToolListTail
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolListTail1887289218/001
=== RUN   TestToolListTail/Tail_Last_2
=== RUN   TestToolListTail/Tail_Last_5_(All)
=== RUN   TestToolListTail/Tail_Count_0
=== RUN   TestToolListTail/Tail_Empty_List
=== RUN   TestToolListTail/Wrong_Count_Type
=== RUN   TestToolListTail/Wrong_List_Type
--- PASS: TestToolListTail (0.00s)
    --- PASS: TestToolListTail/Tail_Last_2 (0.00s)
    --- PASS: TestToolListTail/Tail_Last_5_(All) (0.00s)
    --- PASS: TestToolListTail/Tail_Count_0 (0.00s)
    --- PASS: TestToolListTail/Tail_Empty_List (0.00s)
    --- PASS: TestToolListTail/Wrong_Count_Type (0.00s)
    --- PASS: TestToolListTail/Wrong_List_Type (0.00s)
=== RUN   TestToolAdd
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolAdd1565248030/001
=== RUN   TestToolAdd/Add_Integers
=== NAME  TestToolAdd
    helpers.go:67: [DEBUG] Tool: Add] Calculated %v + %v = %v (Logger Warning: odd number of key-value arguments provided) 5 3 8
=== RUN   TestToolAdd/Add_Floats
=== NAME  TestToolAdd
    helpers.go:67: [DEBUG] Tool: Add] Calculated %v + %v = %v (Logger Warning: odd number of key-value arguments provided) 2.5 1.5 4
=== RUN   TestToolAdd/Type_Mismatch
--- PASS: TestToolAdd (0.00s)
    --- PASS: TestToolAdd/Add_Integers (0.00s)
    --- PASS: TestToolAdd/Add_Floats (0.00s)
    --- PASS: TestToolAdd/Type_Mismatch (0.00s)
=== RUN   TestToolSubtract
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolSubtract1595838628/001
=== RUN   TestToolSubtract/Subtract_Integers
=== NAME  TestToolSubtract
    helpers.go:67: [DEBUG] Tool: Subtract] Calculated %v - %v = %v (Logger Warning: odd number of key-value arguments provided) 5 3 2
=== RUN   TestToolSubtract/Subtract_Floats
=== NAME  TestToolSubtract
    helpers.go:67: [DEBUG] Tool: Subtract] Calculated %v - %v = %v (Logger Warning: odd number of key-value arguments provided) 2.5 1.5 1
=== RUN   TestToolSubtract/Type_Mismatch
--- PASS: TestToolSubtract (0.00s)
    --- PASS: TestToolSubtract/Subtract_Integers (0.00s)
    --- PASS: TestToolSubtract/Subtract_Floats (0.00s)
    --- PASS: TestToolSubtract/Type_Mismatch (0.00s)
=== RUN   TestToolDivide
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolDivide4191491652/001
=== RUN   TestToolDivide/Divide_Integers
=== NAME  TestToolDivide
    helpers.go:67: [DEBUG] Tool: Divide] Calculated %v / %v = %v (Logger Warning: odd number of key-value arguments provided) 10 2 5
=== RUN   TestToolDivide/Divide_Floats
=== NAME  TestToolDivide
    helpers.go:67: [DEBUG] Tool: Divide] Calculated %v / %v = %v (Logger Warning: odd number of key-value arguments provided) 5 2 2.5
=== RUN   TestToolDivide/Divide_by_Zero
--- PASS: TestToolDivide (0.00s)
    --- PASS: TestToolDivide/Divide_Integers (0.00s)
    --- PASS: TestToolDivide/Divide_Floats (0.00s)
    --- PASS: TestToolDivide/Divide_by_Zero (0.00s)
=== RUN   TestToolModulo
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolModulo2725144802/001
=== RUN   TestToolModulo/Modulo_Integers
=== NAME  TestToolModulo
    helpers.go:67: [DEBUG] Tool: Modulo] Calculated %v %% %v = %v (Logger Warning: odd number of key-value arguments provided) 10 3 1
=== RUN   TestToolModulo/Modulo_by_Zero
=== RUN   TestToolModulo/Type_Mismatch
--- PASS: TestToolModulo (0.00s)
    --- PASS: TestToolModulo/Modulo_Integers (0.00s)
    --- PASS: TestToolModulo/Modulo_by_Zero (0.00s)
    --- PASS: TestToolModulo/Type_Mismatch (0.00s)
=== RUN   TestToolMetaListTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMetaListTools4274907848/001
--- PASS: TestToolMetaListTools (0.00s)
=== RUN   TestToolMetaToolsHelp
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolMetaToolsHelp3437973705/001
=== RUN   TestToolMetaToolsHelp/No_filter_(all_tools)
=== RUN   TestToolMetaToolsHelp/Filter_for_Meta_tools
=== RUN   TestToolMetaToolsHelp/Filter_for_FS_tools
=== RUN   TestToolMetaToolsHelp/Filter_with_no_results
--- PASS: TestToolMetaToolsHelp (0.00s)
    --- PASS: TestToolMetaToolsHelp/No_filter_(all_tools) (0.00s)
    --- PASS: TestToolMetaToolsHelp/Filter_for_Meta_tools (0.00s)
    --- PASS: TestToolMetaToolsHelp/Filter_for_FS_tools (0.00s)
    --- PASS: TestToolMetaToolsHelp/Filter_with_no_results (0.00s)
=== RUN   TestToolExecuteCommand
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolExecuteCommand1329929061/001
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolExecuteCommand1329929061/002
=== RUN   TestToolExecuteCommand/Simple_Echo
=== NAME  TestToolExecuteCommand
    helpers.go:67: [DEBUG] ResolvePath: Received relative path. input=. joined_abs=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] Path resolved successfully within sandbox. input=. output=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] [Shell.Execute] Preparing command command=echo args=[hello] directory=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] [Shell.Execute] Command successful command=echo exit_code=0
=== RUN   TestToolExecuteCommand/Command_False_Failure
=== NAME  TestToolExecuteCommand
    helpers.go:67: [DEBUG] ResolvePath: Received relative path. input=. joined_abs=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] Path resolved successfully within sandbox. input=. output=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] [Shell.Execute] Preparing command command=false args=[] directory=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [WARN] [Shell.Execute] Command failed command=false exit_code=1 stderr=
=== RUN   TestToolExecuteCommand/Command_Not_Found
=== NAME  TestToolExecuteCommand
    helpers.go:67: [DEBUG] ResolvePath: Received relative path. input=. joined_abs=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] Path resolved successfully within sandbox. input=. output=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] [Shell.Execute] Preparing command command=nonexistent_command_ajsdflk args=[] directory=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [WARN] [Shell.Execute] Command failed command=nonexistent_command_ajsdflk exit_code=-1 stderr=[NeuroScript Execution Error: exec: "nonexistent_command_ajsdflk": executable file not found in $PATH]
=== RUN   TestToolExecuteCommand/Run_in_specified_dir_(pwd)
=== NAME  TestToolExecuteCommand
    helpers.go:67: [DEBUG] ResolvePath: Received relative path. input=. joined_abs=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] Path resolved successfully within sandbox. input=. output=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] [Shell.Execute] Preparing command command=pwd args=[] directory=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [DEBUG] [Shell.Execute] Command successful command=pwd exit_code=0
=== RUN   TestToolExecuteCommand/Directory_outside_sandbox
=== NAME  TestToolExecuteCommand
    helpers.go:67: [DEBUG] ResolvePath: Received relative path. input=../escaped joined_abs=/tmp/TestToolExecuteCommand1329929061/escaped
    helpers.go:67: [WARN] Path traversal attempt detected! requested_path=../escaped resolved_path=/tmp/TestToolExecuteCommand1329929061/escaped sandbox_root=/tmp/TestToolExecuteCommand1329929061/002
    helpers.go:67: [ERROR] Shell.Execute: invalid execution directory "../escaped": path resolves outside allowed directory: path '../escaped' resolves outside sandbox '/tmp/TestToolExecuteCommand1329929061/002'
=== RUN   TestToolExecuteCommand/Invalid_Command_Arg_Type
=== RUN   TestToolExecuteCommand/Invalid_Args_list_Type
=== RUN   TestToolExecuteCommand/Invalid_Dir_Type
--- PASS: TestToolExecuteCommand (0.05s)
    --- PASS: TestToolExecuteCommand/Simple_Echo (0.00s)
    --- PASS: TestToolExecuteCommand/Command_False_Failure (0.00s)
    --- PASS: TestToolExecuteCommand/Command_Not_Found (0.05s)
    --- PASS: TestToolExecuteCommand/Run_in_specified_dir_(pwd) (0.00s)
    --- PASS: TestToolExecuteCommand/Directory_outside_sandbox (0.00s)
    --- PASS: TestToolExecuteCommand/Invalid_Command_Arg_Type (0.00s)
    --- PASS: TestToolExecuteCommand/Invalid_Args_list_Type (0.00s)
    --- PASS: TestToolExecuteCommand/Invalid_Dir_Type (0.00s)
=== RUN   TestToolStringLength
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolStringLength3158537358/001
=== RUN   TestToolStringLength/Simple
=== NAME  TestToolStringLength
    helpers.go:67: [DEBUG] Tool: String.Length input=hello length=5
=== RUN   TestToolStringLength/Empty
=== NAME  TestToolStringLength
    helpers.go:67: [DEBUG] Tool: String.Length input= length=0
=== RUN   TestToolStringLength/UTF8
=== NAME  TestToolStringLength
    helpers.go:67: [DEBUG] Tool: String.Length input=你好 length=2
=== RUN   TestToolStringLength/Validation_Wrong_Type
--- PASS: TestToolStringLength (0.00s)
    --- PASS: TestToolStringLength/Simple (0.00s)
    --- PASS: TestToolStringLength/Empty (0.00s)
    --- PASS: TestToolStringLength/UTF8 (0.00s)
    --- PASS: TestToolStringLength/Validation_Wrong_Type (0.00s)
=== RUN   TestToolSubstring
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolSubstring2273188001/001
=== RUN   TestToolSubstring/Simple_Substring
=== NAME  TestToolSubstring
    helpers.go:67: [DEBUG] Tool: String.Substring input=abcdef start=1 length=3 result=bcd
=== RUN   TestToolSubstring/Substring_To_End
=== NAME  TestToolSubstring
    helpers.go:67: [DEBUG] Tool: String.Substring input=abcdef start=3 length=3 result=def
=== RUN   TestToolSubstring/Substring_Negative_Length
=== RUN   TestToolSubstring/Substring_Negative_Start
=== RUN   TestToolSubstring/Substring_UTF8
=== NAME  TestToolSubstring
    helpers.go:67: [DEBUG] Tool: String.Substring input=你好世界 start=1 length=2 result=好世
=== RUN   TestToolSubstring/Validation_Non-string_Input
=== RUN   TestToolSubstring/Validation_Non-int_Start
--- PASS: TestToolSubstring (0.00s)
    --- PASS: TestToolSubstring/Simple_Substring (0.00s)
    --- PASS: TestToolSubstring/Substring_To_End (0.00s)
    --- PASS: TestToolSubstring/Substring_Negative_Length (0.00s)
    --- PASS: TestToolSubstring/Substring_Negative_Start (0.00s)
    --- PASS: TestToolSubstring/Substring_UTF8 (0.00s)
    --- PASS: TestToolSubstring/Validation_Non-string_Input (0.00s)
    --- PASS: TestToolSubstring/Validation_Non-int_Start (0.00s)
=== RUN   TestToolToUpperLower
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolToUpperLower4083246183/001
=== RUN   TestToolToUpperLower/ToUpper_Simple
=== NAME  TestToolToUpperLower
    helpers.go:67: [DEBUG] Tool: String.ToUpper input=hello result=HELLO
=== RUN   TestToolToUpperLower/ToUpper_Empty
=== NAME  TestToolToUpperLower
    helpers.go:67: [DEBUG] Tool: String.ToUpper input= result=
=== RUN   TestToolToUpperLower/ToUpper_Validation_Wrong_Type
=== RUN   TestToolToUpperLower/ToLower_Simple
=== NAME  TestToolToUpperLower
    helpers.go:67: [DEBUG] Tool: String.ToLower input=HELLO result=hello
=== RUN   TestToolToUpperLower/ToLower_Validation_Wrong_Type
--- PASS: TestToolToUpperLower (0.00s)
    --- PASS: TestToolToUpperLower/ToUpper_Simple (0.00s)
    --- PASS: TestToolToUpperLower/ToUpper_Empty (0.00s)
    --- PASS: TestToolToUpperLower/ToUpper_Validation_Wrong_Type (0.00s)
    --- PASS: TestToolToUpperLower/ToLower_Simple (0.00s)
    --- PASS: TestToolToUpperLower/ToLower_Validation_Wrong_Type (0.00s)
=== RUN   TestToolTrimSpace
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolTrimSpace3643735112/001
=== RUN   TestToolTrimSpace/Trim_Both
=== NAME  TestToolTrimSpace
    helpers.go:67: [DEBUG] Tool: String.TrimSpace input=  hello   result=hello
=== RUN   TestToolTrimSpace/Trim_Internal_Space
=== NAME  TestToolTrimSpace
    helpers.go:67: [DEBUG] Tool: String.TrimSpace input= hello world  result=hello world
=== RUN   TestToolTrimSpace/Validation_Wrong_Type
--- PASS: TestToolTrimSpace (0.00s)
    --- PASS: TestToolTrimSpace/Trim_Both (0.00s)
    --- PASS: TestToolTrimSpace/Trim_Internal_Space (0.00s)
    --- PASS: TestToolTrimSpace/Validation_Wrong_Type (0.00s)
=== RUN   TestToolReplaceAll
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolReplaceAll3442980318/001
=== RUN   TestToolReplaceAll/Simple_Replace
=== NAME  TestToolReplaceAll
    helpers.go:67: [DEBUG] Tool: String.Replace input=hello world old=l new=X count=-1 result=heXXo worXd
=== RUN   TestToolReplaceAll/Replace_With_Count_1
=== NAME  TestToolReplaceAll
    helpers.go:67: [DEBUG] Tool: String.Replace input=hello world old=l new=X count=1 result=heXlo world
=== RUN   TestToolReplaceAll/Validation_Non-string_Input
=== RUN   TestToolReplaceAll/Validation_Non-int_Count
--- PASS: TestToolReplaceAll (0.00s)
    --- PASS: TestToolReplaceAll/Simple_Replace (0.00s)
    --- PASS: TestToolReplaceAll/Replace_With_Count_1 (0.00s)
    --- PASS: TestToolReplaceAll/Validation_Non-string_Input (0.00s)
    --- PASS: TestToolReplaceAll/Validation_Non-int_Count (0.00s)
=== RUN   TestToolContainsPrefixSuffix
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolContainsPrefixSuffix3323115828/001
=== RUN   TestToolContainsPrefixSuffix/Contains_True
=== NAME  TestToolContainsPrefixSuffix
    helpers.go:67: [DEBUG] Tool: String.Contains input=hello world substring=world result=true
=== RUN   TestToolContainsPrefixSuffix/Contains_False
=== NAME  TestToolContainsPrefixSuffix
    helpers.go:67: [DEBUG] Tool: String.Contains input=hello world substring=bye result=false
=== RUN   TestToolContainsPrefixSuffix/Contains_Wrong_Type
=== RUN   TestToolContainsPrefixSuffix/HasPrefix_True
=== NAME  TestToolContainsPrefixSuffix
    helpers.go:67: [DEBUG] Tool: String.HasPrefix input=hello world prefix=hello result=true
=== RUN   TestToolContainsPrefixSuffix/HasPrefix_False
=== NAME  TestToolContainsPrefixSuffix
    helpers.go:67: [DEBUG] Tool: String.HasPrefix input=hello world prefix=world result=false
=== RUN   TestToolContainsPrefixSuffix/HasPrefix_Wrong_Type
=== RUN   TestToolContainsPrefixSuffix/HasSuffix_True
=== NAME  TestToolContainsPrefixSuffix
    helpers.go:67: [DEBUG] Tool: String.HasSuffix input=hello world suffix=world result=true
=== RUN   TestToolContainsPrefixSuffix/HasSuffix_False
=== NAME  TestToolContainsPrefixSuffix
    helpers.go:67: [DEBUG] Tool: String.HasSuffix input=hello world suffix=hello result=false
=== RUN   TestToolContainsPrefixSuffix/HasSuffix_Wrong_Type
--- PASS: TestToolContainsPrefixSuffix (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/Contains_True (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/Contains_False (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/Contains_Wrong_Type (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/HasPrefix_True (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/HasPrefix_False (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/HasPrefix_Wrong_Type (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/HasSuffix_True (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/HasSuffix_False (0.00s)
    --- PASS: TestToolContainsPrefixSuffix/HasSuffix_Wrong_Type (0.00s)
=== RUN   TestToolSplitString
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolSplitString2369376844/001
=== RUN   TestToolSplitString/Simple_Split
=== NAME  TestToolSplitString
    helpers.go:67: [DEBUG] Tool: String.Split input_length=5 separator=, parts_count=3
=== RUN   TestToolSplitString/Empty_Delimiter
=== NAME  TestToolSplitString
    helpers.go:67: [DEBUG] Tool: String.Split input_length=3 separator= parts_count=3
=== RUN   TestToolSplitString/Validation_Non-string_Input
=== RUN   TestToolSplitString/Validation_Non-string_Delimiter
--- PASS: TestToolSplitString (0.00s)
    --- PASS: TestToolSplitString/Simple_Split (0.00s)
    --- PASS: TestToolSplitString/Empty_Delimiter (0.00s)
    --- PASS: TestToolSplitString/Validation_Non-string_Input (0.00s)
    --- PASS: TestToolSplitString/Validation_Non-string_Delimiter (0.00s)
=== RUN   TestToolSplitWords
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolSplitWords3627615887/001
=== RUN   TestToolSplitWords/Simple_Words
=== NAME  TestToolSplitWords
    helpers.go:67: [DEBUG] Tool: String.SplitWords input_length=11 parts_count=2
=== RUN   TestToolSplitWords/Multiple_Spaces
=== NAME  TestToolSplitWords
    helpers.go:67: [DEBUG] Tool: String.SplitWords input_length=23 parts_count=3
=== RUN   TestToolSplitWords/Empty_String
=== NAME  TestToolSplitWords
    helpers.go:67: [DEBUG] Tool: String.SplitWords input_length=0 parts_count=0
=== RUN   TestToolSplitWords/Validation_Non-string_Input
--- PASS: TestToolSplitWords (0.00s)
    --- PASS: TestToolSplitWords/Simple_Words (0.00s)
    --- PASS: TestToolSplitWords/Multiple_Spaces (0.00s)
    --- PASS: TestToolSplitWords/Empty_String (0.00s)
    --- PASS: TestToolSplitWords/Validation_Non-string_Input (0.00s)
=== RUN   TestToolJoinStrings
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolJoinStrings651992397/001
=== RUN   TestToolJoinStrings/Join_Simple
=== NAME  TestToolJoinStrings
    helpers.go:67: [DEBUG] Tool: String.Join input_count=3 separator=, result_length=5
=== RUN   TestToolJoinStrings/Join_Empty_Slice
=== NAME  TestToolJoinStrings
    helpers.go:67: [DEBUG] Tool: String.Join input_count=0 separator=, result_length=0
=== RUN   TestToolJoinStrings/Validation_Non-slice_First_Arg
=== RUN   TestToolJoinStrings/Validation_Non-string_Separator
=== RUN   TestToolJoinStrings/Validation_Non-string_elements_in_slice
--- PASS: TestToolJoinStrings (0.00s)
    --- PASS: TestToolJoinStrings/Join_Simple (0.00s)
    --- PASS: TestToolJoinStrings/Join_Empty_Slice (0.00s)
    --- PASS: TestToolJoinStrings/Validation_Non-slice_First_Arg (0.00s)
    --- PASS: TestToolJoinStrings/Validation_Non-string_Separator (0.00s)
    --- PASS: TestToolJoinStrings/Validation_Non-string_elements_in_slice (0.00s)
=== RUN   TestToolLineCountString
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestToolLineCountString1200074056/001
=== RUN   TestToolLineCountString/Empty_String
=== NAME  TestToolLineCountString
    helpers.go:67: [DEBUG] Tool: String.LineCount content= line_count=0
=== RUN   TestToolLineCountString/Single_Line_No_NL
=== NAME  TestToolLineCountString
    helpers.go:67: [DEBUG] Tool: String.LineCount content_len=5 line_count=1
=== RUN   TestToolLineCountString/Single_Line_With_NL
=== NAME  TestToolLineCountString
    helpers.go:67: [DEBUG] Tool: String.LineCount content_len=6 line_count=1
=== RUN   TestToolLineCountString/Two_Lines_No_Trailing_NL
=== NAME  TestToolLineCountString
    helpers.go:67: [DEBUG] Tool: String.LineCount content_len=11 line_count=2
=== RUN   TestToolLineCountString/Multiple_Blank_Lines
=== NAME  TestToolLineCountString
    helpers.go:67: [DEBUG] Tool: String.LineCount content_len=3 line_count=3
=== RUN   TestToolLineCountString/CRLF_Line_Endings
=== NAME  TestToolLineCountString
    helpers.go:67: [DEBUG] Tool: String.LineCount content_len=14 line_count=2
=== RUN   TestToolLineCountString/Validation_Wrong_Arg_Type
--- PASS: TestToolLineCountString (0.00s)
    --- PASS: TestToolLineCountString/Empty_String (0.00s)
    --- PASS: TestToolLineCountString/Single_Line_No_NL (0.00s)
    --- PASS: TestToolLineCountString/Single_Line_With_NL (0.00s)
    --- PASS: TestToolLineCountString/Two_Lines_No_Trailing_NL (0.00s)
    --- PASS: TestToolLineCountString/Multiple_Blank_Lines (0.00s)
    --- PASS: TestToolLineCountString/CRLF_Line_Endings (0.00s)
    --- PASS: TestToolLineCountString/Validation_Wrong_Arg_Type (0.00s)
=== RUN   TestAnalyzeNSSyntaxInternal
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:80: [INFO] NeuroScript Grammar Version: test-grammar-v0.9.9
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestAnalyzeNSSyntaxInternal3526177552/001
=== RUN   TestAnalyzeNSSyntaxInternal/valid_script_-_no_errors
=== NAME  TestAnalyzeNSSyntaxInternal
    helpers.go:67: [DEBUG] Parsing for LSP sourceName=nsSyntaxAnalysisToolInput length=45
    helpers.go:67: [DEBUG] LSP Parse successful (no syntax errors). sourceName=nsSyntaxAnalysisToolInput
=== RUN   TestAnalyzeNSSyntaxInternal/script_with_one_syntax_error_-_incomplete_set
=== NAME  TestAnalyzeNSSyntaxInternal
    helpers.go:67: [DEBUG] Parsing for LSP sourceName=nsSyntaxAnalysisToolInput length=34
    helpers.go:67: [ERROR] Syntax Error Reported by Listener source=nsSyntaxAnalysisToolInput line=2 column=10 message=mismatched input '\n' expecting {'acos', 'asin', 'atan', 'cos', 'eval', 'false', 'last', 'ln', 'log', 'nil', 'no', 'not', 'sin', 'some', 'tan', 'tool', 'true', 'typeof', STRING_LIT, TRIPLE_BACKTICK_STRING, NUMBER_LIT, IDENTIFIER, '-', '~', '(', '[', '{', '{{'} token=
    helpers.go:67: [DEBUG] Syntax errors found during LSP parse sourceName=nsSyntaxAnalysisToolInput count=1
=== RUN   TestAnalyzeNSSyntaxInternal/script_with_multiple_syntax_errors_-_incomplete_set_and_call
=== NAME  TestAnalyzeNSSyntaxInternal
    helpers.go:67: [DEBUG] Parsing for LSP sourceName=nsSyntaxAnalysisToolInput length=42
    helpers.go:67: [ERROR] Syntax Error Reported by Listener source=nsSyntaxAnalysisToolInput line=2 column=10 message=mismatched input '\n' expecting {'acos', 'asin', 'atan', 'cos', 'eval', 'false', 'last', 'ln', 'log', 'nil', 'no', 'not', 'sin', 'some', 'tan', 'tool', 'true', 'typeof', STRING_LIT, TRIPLE_BACKTICK_STRING, NUMBER_LIT, IDENTIFIER, '-', '~', '(', '[', '{', '{{'} token=
    helpers.go:67: [ERROR] Syntax Error Reported by Listener source=nsSyntaxAnalysisToolInput line=3 column=7 message=mismatched input '\n' expecting {'acos', 'asin', 'atan', 'cos', 'ln', 'log', 'sin', 'tan', 'tool', IDENTIFIER} token=
    helpers.go:67: [DEBUG] Syntax errors found during LSP parse sourceName=nsSyntaxAnalysisToolInput count=2
=== RUN   TestAnalyzeNSSyntaxInternal/empty_script
=== NAME  TestAnalyzeNSSyntaxInternal
    helpers.go:67: [DEBUG] Parsing for LSP sourceName=nsSyntaxAnalysisToolInput length=0
    helpers.go:67: [DEBUG] LSP Parse successful (no syntax errors). sourceName=nsSyntaxAnalysisToolInput
=== RUN   TestAnalyzeNSSyntaxInternal/nil_interpreter_passed_to_tool_function
=== RUN   TestAnalyzeNSSyntaxInternal/more_than_max_errors_-_input_yields_1_parser_error_for_standalone_set
=== NAME  TestAnalyzeNSSyntaxInternal
    helpers.go:67: [DEBUG] Parsing for LSP sourceName=nsSyntaxAnalysisToolInput length=225
    helpers.go:67: [ERROR] Syntax Error Reported by Listener source=nsSyntaxAnalysisToolInput line=1 column=0 message=mismatched input 'set' expecting {<EOF>, 'func', 'on'} token=set
    helpers.go:67: [DEBUG] Syntax errors found during LSP parse sourceName=nsSyntaxAnalysisToolInput count=1
=== RUN   TestAnalyzeNSSyntaxInternal/invalid_keyword_as_variable_name
=== NAME  TestAnalyzeNSSyntaxInternal
    helpers.go:67: [DEBUG] Parsing for LSP sourceName=nsSyntaxAnalysisToolInput length=37
    helpers.go:67: [ERROR] Syntax Error Reported by Listener source=nsSyntaxAnalysisToolInput line=2 column=6 message=mismatched input 'if' expecting IDENTIFIER token=if
    helpers.go:67: [DEBUG] Syntax errors found during LSP parse sourceName=nsSyntaxAnalysisToolInput count=1
--- PASS: TestAnalyzeNSSyntaxInternal (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/valid_script_-_no_errors (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/script_with_one_syntax_error_-_incomplete_set (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/script_with_multiple_syntax_errors_-_incomplete_set_and_call (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/empty_script (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/nil_interpreter_passed_to_tool_function (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/more_than_max_errors_-_input_yields_1_parser_error_for_standalone_set (0.00s)
    --- PASS: TestAnalyzeNSSyntaxInternal/invalid_keyword_as_variable_name (0.00s)
=== RUN   TestTreeLoadJSONAndToJSON
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/001
=== RUN   TestTreeLoadJSONAndToJSON/LoadJSON_Simple_Object
=== NAME  TestTreeLoadJSONAndToJSON
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::364f2cf3-3763-498a-8677-2a6c6263cde2
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/002
=== RUN   TestTreeLoadJSONAndToJSON/LoadJSON_Invalid_JSON
=== NAME  TestTreeLoadJSONAndToJSON
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/003
=== RUN   TestTreeLoadJSONAndToJSON/LoadJSON_Empty_Input
=== NAME  TestTreeLoadJSONAndToJSON
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/004
=== RUN   TestTreeLoadJSONAndToJSON/LoadJSON_Wrong_Arg_Type
=== NAME  TestTreeLoadJSONAndToJSON
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/005
=== RUN   TestTreeLoadJSONAndToJSON/ToJSON_Simple_Object
=== NAME  TestTreeLoadJSONAndToJSON
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::f43e56fc-bcb9-46b2-9d8f-bc345f465835
    helpers.go:67: [DEBUG] Tree.ToJSON: Successfully formatted tree to JSON handle=GenericTree::f43e56fc-bcb9-46b2-9d8f-bc345f465835
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/006
=== RUN   TestTreeLoadJSONAndToJSON/ToJSON_Invalid_Handle
=== NAME  TestTreeLoadJSONAndToJSON
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeLoadJSONAndToJSON3589803255/007
=== RUN   TestTreeLoadJSONAndToJSON/ToJSON_Handle_Not_Found
--- PASS: TestTreeLoadJSONAndToJSON (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/LoadJSON_Simple_Object (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/LoadJSON_Invalid_JSON (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/LoadJSON_Empty_Input (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/LoadJSON_Wrong_Arg_Type (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/ToJSON_Simple_Object (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/ToJSON_Invalid_Handle (0.00s)
    --- PASS: TestTreeLoadJSONAndToJSON/ToJSON_Handle_Not_Found (0.00s)
=== RUN   TestTreeMetadataTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeMetadataTools236346054/001
=== RUN   TestTreeMetadataTools/SetNodeMetadata_New_Key
=== NAME  TestTreeMetadataTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::ac532881-7911-4d44-bc81-d8be058cfc01
    helpers.go:67: [DEBUG] Tree.SetNodeMetadata: Set node metadata attribute handle=GenericTree::ac532881-7911-4d44-bc81-d8be058cfc01 nodeId=node-1 key=metaKey1 value=metaValue1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::ac532881-7911-4d44-bc81-d8be058cfc01 nodeId=node-1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeMetadataTools236346054/002
=== RUN   TestTreeMetadataTools/SetNodeMetadata_Empty_Key
=== NAME  TestTreeMetadataTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::d1a61637-1024-4fdc-a877-055256db94ca
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeMetadataTools236346054/003
=== RUN   TestTreeMetadataTools/SetNodeMetadata_NonExistent_Node
=== NAME  TestTreeMetadataTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::38aa15f8-dca4-434f-98a1-a1eb5cc5f4ec
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeMetadataTools236346054/004
=== RUN   TestTreeMetadataTools/RemoveNodeMetadata_Existing_Key
=== NAME  TestTreeMetadataTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::3c7c3dec-ca43-418f-b939-174330a0a9db
    helpers.go:67: [DEBUG] Tree.SetNodeMetadata: Set node metadata attribute handle=GenericTree::3c7c3dec-ca43-418f-b939-174330a0a9db nodeId=node-1 key=toRemove value=val
    helpers.go:67: [DEBUG] Tree.RemoveNodeMetadata: Removed node metadata attribute handle=GenericTree::3c7c3dec-ca43-418f-b939-174330a0a9db nodeId=node-1 key=toRemove
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::3c7c3dec-ca43-418f-b939-174330a0a9db nodeId=node-1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeMetadataTools236346054/005
=== RUN   TestTreeMetadataTools/RemoveNodeMetadata_NonExistent_Key
=== NAME  TestTreeMetadataTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::48c6ae15-0677-445f-92fa-64a199ce17f6
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeMetadataTools236346054/006
=== RUN   TestTreeMetadataTools/RemoveNodeMetadata_NonExistent_Node
=== NAME  TestTreeMetadataTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::3915f4dd-cd31-4740-8997-94e90ed9287d
--- PASS: TestTreeMetadataTools (0.00s)
    --- PASS: TestTreeMetadataTools/SetNodeMetadata_New_Key (0.00s)
    --- PASS: TestTreeMetadataTools/SetNodeMetadata_Empty_Key (0.00s)
    --- PASS: TestTreeMetadataTools/SetNodeMetadata_NonExistent_Node (0.00s)
    --- PASS: TestTreeMetadataTools/RemoveNodeMetadata_Existing_Key (0.00s)
    --- PASS: TestTreeMetadataTools/RemoveNodeMetadata_NonExistent_Key (0.00s)
    --- PASS: TestTreeMetadataTools/RemoveNodeMetadata_NonExistent_Node (0.00s)
=== RUN   TestTreeModificationTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/001
=== RUN   TestTreeModificationTools/SetValue_Valid_Leaf_(string_node)_(Robust)
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::feef3b82-c235-4dd0-aedb-253e41b77ed7
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::feef3b82-c235-4dd0-aedb-253e41b77ed7 nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::feef3b82-c235-4dd0-aedb-253e41b77ed7 nodeId=node-1
=== NAME  TestTreeModificationTools/SetValue_Valid_Leaf_(string_node)_(Robust)
    tools_tree_modify_test.go:69: SetValue check: Dynamically found target node ID (for original 'name') as: node-2
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.SetValue: Modified node value handle=GenericTree::feef3b82-c235-4dd0-aedb-253e41b77ed7 nodeId=node-2
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::feef3b82-c235-4dd0-aedb-253e41b77ed7 nodeId=node-2
=== NAME  TestTreeModificationTools/SetValue_Valid_Leaf_(string_node)_(Robust)
    tools_tree_modify_test.go:87: SetValue successfully updated node 'node-2' to 'new_name_value'
=== NAME  TestTreeModificationTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/002
=== RUN   TestTreeModificationTools/SetValue_On_Object_Node
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::d877f1e4-2d14-4cc8-a372-a841bf55738d
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/003
=== RUN   TestTreeModificationTools/SetValue_NonExistent_Node
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::84faa2f2-650a-485c-9a19-88b2a4a28773
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/004
=== RUN   TestTreeModificationTools/AddChildNode_To_Root_Object
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::29306542-623d-4e45-9fed-6eb17d2ebb33
    helpers.go:67: [DEBUG] Tree.AddChildNode: Added new node to tree handle=GenericTree::29306542-623d-4e45-9fed-6eb17d2ebb33 parentId=node-1 newNodeId=newChild1 type=string
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::29306542-623d-4e45-9fed-6eb17d2ebb33 nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::29306542-623d-4e45-9fed-6eb17d2ebb33 nodeId=newChild1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/005
=== RUN   TestTreeModificationTools/AddChildNode_ID_Exists
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::39ed5459-3a66-40c6-bbda-a85de7296708
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/006
=== RUN   TestTreeModificationTools/AddChildNode_To_Leaf_Node_(Robust)
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::4336bf93-11e5-44de-958e-5a2a31dd87c8
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::4336bf93-11e5-44de-958e-5a2a31dd87c8 nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::4336bf93-11e5-44de-958e-5a2a31dd87c8 nodeId=node-1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/007
=== RUN   TestTreeModificationTools/RemoveNode_Leaf_(Robust)
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::a0cba687-4aa8-44e5-b86b-c549d207d23a
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::a0cba687-4aa8-44e5-b86b-c549d207d23a nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::a0cba687-4aa8-44e5-b86b-c549d207d23a nodeId=node-1
=== NAME  TestTreeModificationTools/RemoveNode_Leaf_(Robust)
    tools_tree_modify_test.go:174: Dynamically determined nodeID to remove (node linked by root's 'value' attribute): node-3
[DEBUG removeChildFromParent] Deleted key 'value'. Parent 'node-1' attributes now: map[name:node-2]
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.RemoveNode: Removed node and descendants from tree handle=GenericTree::a0cba687-4aa8-44e5-b86b-c549d207d23a nodeId=node-3
=== NAME  TestTreeModificationTools/RemoveNode_Leaf_(Robust)
    tools_tree_modify_test.go:184: Tree.RemoveNode called successfully for node ID: node-3
    tools_tree_modify_test.go:195: Successfully confirmed node 'node-3' not found.
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::a0cba687-4aa8-44e5-b86b-c549d207d23a nodeId=node-1
=== NAME  TestTreeModificationTools/RemoveNode_Leaf_(Robust)
    tools_tree_modify_test.go:213: Attribute 'value' successfully removed from root node's attributes.
=== NAME  TestTreeModificationTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/008
=== RUN   TestTreeModificationTools/RemoveNode_Root
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::54db41e6-fa77-478e-8b84-5d404e36cc34
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeModificationTools2384963485/009
=== RUN   TestTreeModificationTools/RemoveNode_NonExistent
=== NAME  TestTreeModificationTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=3 handle=GenericTree::2f2f19ee-2102-4b9a-aea3-bd7f8ea843b2
--- PASS: TestTreeModificationTools (0.00s)
    --- PASS: TestTreeModificationTools/SetValue_Valid_Leaf_(string_node)_(Robust) (0.00s)
    --- PASS: TestTreeModificationTools/SetValue_On_Object_Node (0.00s)
    --- PASS: TestTreeModificationTools/SetValue_NonExistent_Node (0.00s)
    --- PASS: TestTreeModificationTools/AddChildNode_To_Root_Object (0.00s)
    --- PASS: TestTreeModificationTools/AddChildNode_ID_Exists (0.00s)
    --- PASS: TestTreeModificationTools/AddChildNode_To_Leaf_Node_(Robust) (0.00s)
    --- PASS: TestTreeModificationTools/RemoveNode_Leaf_(Robust) (0.00s)
    --- PASS: TestTreeModificationTools/RemoveNode_Root (0.00s)
    --- PASS: TestTreeModificationTools/RemoveNode_NonExistent (0.00s)
=== RUN   TestTreeNavigationTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeNavigationTools128935429/001
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=18 handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c
=== RUN   TestTreeNavigationTools/GetNode_Root
=== NAME  TestTreeNavigationTools
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-1
=== RUN   TestTreeNavigationTools/GetNode_Nested_(file1_name)
=== NAME  TestTreeNavigationTools
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-4
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-5
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-6
=== RUN   TestTreeNavigationTools/GetNode_NonExistent_Node
=== RUN   TestTreeNavigationTools/GetNode_Invalid_Handle
=== RUN   TestTreeNavigationTools/GetChildren_of_Array_Node
=== NAME  TestTreeNavigationTools
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetChildren: Retrieved children IDs handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-4 count=2
=== RUN   TestTreeNavigationTools/GetChildren_of_Object_Node
=== RUN   TestTreeNavigationTools/GetChildren_of_Leaf_Node
=== NAME  TestTreeNavigationTools
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-4
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-5
=== RUN   TestTreeNavigationTools/GetParent_of_Root
=== NAME  TestTreeNavigationTools
    helpers.go:67: [DEBUG] Tree.GetParent: Retrieved parent ID handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-1 parentId=
=== RUN   TestTreeNavigationTools/GetParent_of_Child
=== NAME  TestTreeNavigationTools
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-1
    helpers.go:67: [DEBUG] Tree.GetParent: Retrieved parent ID handle=GenericTree::16cf6ed6-37ea-48c4-be84-5ddcc3c9721c nodeId=node-4 parentId=node-1
=== RUN   TestTreeNavigationTools/GetParent_NonExistent_Node
--- PASS: TestTreeNavigationTools (0.00s)
    --- PASS: TestTreeNavigationTools/GetNode_Root (0.00s)
    --- PASS: TestTreeNavigationTools/GetNode_Nested_(file1_name) (0.00s)
    --- PASS: TestTreeNavigationTools/GetNode_NonExistent_Node (0.00s)
    --- PASS: TestTreeNavigationTools/GetNode_Invalid_Handle (0.00s)
    --- PASS: TestTreeNavigationTools/GetChildren_of_Array_Node (0.00s)
    --- PASS: TestTreeNavigationTools/GetChildren_of_Object_Node (0.00s)
    --- PASS: TestTreeNavigationTools/GetChildren_of_Leaf_Node (0.00s)
    --- PASS: TestTreeNavigationTools/GetParent_of_Root (0.00s)
    --- PASS: TestTreeNavigationTools/GetParent_of_Child (0.00s)
    --- PASS: TestTreeNavigationTools/GetParent_NonExistent_Node (0.00s)
=== RUN   TestTreeFindAndRenderTools
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeFindAndRenderTools1399927024/001
=== RUN   TestTreeFindAndRenderTools/FindNodes_By_Type_'file'
=== NAME  TestTreeFindAndRenderTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=21 handle=GenericTree::7b0b489d-ac8d-4fea-9c4c-0fea888c92b9
    helpers.go:67: [DEBUG] Tree.FindNodes: Executing search tree_handle=GenericTree::7b0b489d-ac8d-4fea-9c4c-0fea888c92b9 start_node_id=node-1 query=map[value:file] max_depth=-1 max_results=-1
    helpers.go:67: [DEBUG] Tree.FindNodes: Search completed found_count=2
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::7b0b489d-ac8d-4fea-9c4c-0fea888c92b9 nodeId=node-10
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::7b0b489d-ac8d-4fea-9c4c-0fea888c92b9 nodeId=node-8
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::7b0b489d-ac8d-4fea-9c4c-0fea888c92b9 nodeId=node-18
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::7b0b489d-ac8d-4fea-9c4c-0fea888c92b9 nodeId=node-16
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeFindAndRenderTools1399927024/002
=== RUN   TestTreeFindAndRenderTools/FindNodes_By_Value_of_Name_Attribute
=== NAME  TestTreeFindAndRenderTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=21 handle=GenericTree::48506b00-168f-41e7-99f0-ce5dea3a40bc
    helpers.go:67: [DEBUG] Tree.FindNodes: Executing search tree_handle=GenericTree::48506b00-168f-41e7-99f0-ce5dea3a40bc start_node_id=node-1 query=map[value:file1.txt] max_depth=-1 max_results=-1
    helpers.go:67: [DEBUG] Tree.FindNodes: Search completed found_count=1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::48506b00-168f-41e7-99f0-ce5dea3a40bc nodeId=node-4
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeFindAndRenderTools1399927024/003
=== RUN   TestTreeFindAndRenderTools/FindNodes_By_Metadata_Deep
=== NAME  TestTreeFindAndRenderTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=21 handle=GenericTree::f7f57449-a80f-4f7b-ac8b-24b863ff775e
    helpers.go:67: [DEBUG] Tree.FindNodes: Executing search tree_handle=GenericTree::f7f57449-a80f-4f7b-ac8b-24b863ff775e start_node_id=node-1 query=map[comment:query_is_dynamic_in_checkfunc] max_depth=-1 max_results=-1
    helpers.go:67: [DEBUG] Tree.FindNodes: Search completed found_count=0
    helpers.go:67: [DEBUG] Tree.FindNodes: Executing search tree_handle=GenericTree::f7f57449-a80f-4f7b-ac8b-24b863ff775e start_node_id=node-1 query=map[value:file2.txt] max_depth=-1 max_results=-1
    helpers.go:67: [DEBUG] Tree.FindNodes: Search completed found_count=1
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::f7f57449-a80f-4f7b-ac8b-24b863ff775e nodeId=node-15
    helpers.go:67: [DEBUG] Tree.GetNode: Retrieved node information handle=GenericTree::f7f57449-a80f-4f7b-ac8b-24b863ff775e nodeId=node-14
    helpers.go:67: [DEBUG] Tree.FindNodes: Executing search tree_handle=GenericTree::f7f57449-a80f-4f7b-ac8b-24b863ff775e start_node_id=node-1 query=map[attributes:map[meta_deep:node-18]] max_depth=-1 max_results=-1
    helpers.go:67: [DEBUG] Tree.FindNodes: Search completed found_count=1
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeFindAndRenderTools1399927024/004
=== RUN   TestTreeFindAndRenderTools/FindNodes_Invalid_Query_Type
=== NAME  TestTreeFindAndRenderTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=21 handle=GenericTree::be97e8da-60f6-4c01-aadc-b21d09b272cd
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeFindAndRenderTools1399927024/005
=== RUN   TestTreeFindAndRenderTools/RenderText_Basic
=== NAME  TestTreeFindAndRenderTools
    helpers.go:67: [DEBUG] Tree.LoadJSON: Successfully parsed JSON into tree rootId=node-1 nodeCount=2 handle=GenericTree::d37ff45b-5485-4559-9046-8935d1905336
    helpers.go:67: [DEBUG] Tree.RenderText: Successfully rendered tree to text handle=GenericTree::d37ff45b-5485-4559-9046-8935d1905336
    helpers.go:67: [WARN] NewLLMClient: API key is not set. Using internal NoOpLLMClient.
    helpers.go:67: [DEBUG] FileAPI initialized. sandbox_root=/tmp/TestTreeFindAndRenderTools1399927024/006
=== RUN   TestTreeFindAndRenderTools/RenderText_Invalid_Handle
--- PASS: TestTreeFindAndRenderTools (0.00s)
    --- PASS: TestTreeFindAndRenderTools/FindNodes_By_Type_'file' (0.00s)
    --- PASS: TestTreeFindAndRenderTools/FindNodes_By_Value_of_Name_Attribute (0.00s)
    --- PASS: TestTreeFindAndRenderTools/FindNodes_By_Metadata_Deep (0.00s)
    --- PASS: TestTreeFindAndRenderTools/FindNodes_Invalid_Query_Type (0.00s)
    --- PASS: TestTreeFindAndRenderTools/RenderText_Basic (0.00s)
    --- PASS: TestTreeFindAndRenderTools/RenderText_Invalid_Handle (0.00s)
=== RUN   TestNormalizeString
=== RUN   TestNormalizeString/No_flags_(expect_default)
=== RUN   TestNormalizeString/TrimSpace_only
=== RUN   TestNormalizeString/CompressSpace_only
=== RUN   TestNormalizeString/RemoveGoComments_only
=== RUN   TestNormalizeString/RemoveNSComments_only
=== RUN   TestNormalizeString/RemoveBlankLines_only
=== RUN   TestNormalizeString/Remove_Comments_and_Blank_Lines
=== RUN   TestNormalizeString/Remove_Comments,_Blank_Lines,_AND_Trim
=== RUN   TestNormalizeString/All_flags_(NormDefault)
=== RUN   TestNormalizeString/Empty_Input
=== RUN   TestNormalizeString/Whitespace_only_input
=== RUN   TestNormalizeString/Input_with_only_comments
=== RUN   TestNormalizeString/No_normalization_needed
=== RUN   TestNormalizeString/Windows_Line_Endings
=== RUN   TestNormalizeString/Mixed_Line_Endings_with_Space
=== RUN   TestNormalizeString/Tab_handling
=== RUN   TestNormalizeString/Tab_handling_with_compression
--- PASS: TestNormalizeString (0.00s)
    --- PASS: TestNormalizeString/No_flags_(expect_default) (0.00s)
    --- PASS: TestNormalizeString/TrimSpace_only (0.00s)
    --- PASS: TestNormalizeString/CompressSpace_only (0.00s)
    --- PASS: TestNormalizeString/RemoveGoComments_only (0.00s)
    --- PASS: TestNormalizeString/RemoveNSComments_only (0.00s)
    --- PASS: TestNormalizeString/RemoveBlankLines_only (0.00s)
    --- PASS: TestNormalizeString/Remove_Comments_and_Blank_Lines (0.00s)
    --- PASS: TestNormalizeString/Remove_Comments,_Blank_Lines,_AND_Trim (0.00s)
    --- PASS: TestNormalizeString/All_flags_(NormDefault) (0.00s)
    --- PASS: TestNormalizeString/Empty_Input (0.00s)
    --- PASS: TestNormalizeString/Whitespace_only_input (0.00s)
    --- PASS: TestNormalizeString/Input_with_only_comments (0.00s)
    --- PASS: TestNormalizeString/No_normalization_needed (0.00s)
    --- PASS: TestNormalizeString/Windows_Line_Endings (0.00s)
    --- PASS: TestNormalizeString/Mixed_Line_Endings_with_Space (0.00s)
    --- PASS: TestNormalizeString/Tab_handling (0.00s)
    --- PASS: TestNormalizeString/Tab_handling_with_compression (0.00s)
=== RUN   TestDiffStrings
=== RUN   TestDiffStrings/Equal_strings_after_normalization
=== RUN   TestDiffStrings/Different_strings_after_normalization
=== RUN   TestDiffStrings/DiffShowFull_flag
=== RUN   TestDiffStrings/DiffAnsiColor_flag_runs
=== RUN   TestDiffStrings/DiffVisibleSpace_flag_shows_space_tab_nl
--- PASS: TestDiffStrings (0.00s)
    --- PASS: TestDiffStrings/Equal_strings_after_normalization (0.00s)
    --- PASS: TestDiffStrings/Different_strings_after_normalization (0.00s)
    --- PASS: TestDiffStrings/DiffShowFull_flag (0.00s)
    --- PASS: TestDiffStrings/DiffAnsiColor_flag_runs (0.00s)
    --- PASS: TestDiffStrings/DiffVisibleSpace_flag_shows_space_tab_nl (0.00s)
=== RUN   TestValueTypes
=== RUN   TestValueTypes/StringValue
=== RUN   TestValueTypes/NumberValue
=== RUN   TestValueTypes/BoolValue
=== RUN   TestValueTypes/NilValue
=== RUN   TestValueTypes/ErrorValue
=== RUN   TestValueTypes/EventValue
=== RUN   TestValueTypes/TimedateValue
=== RUN   TestValueTypes/FuzzyValue
--- PASS: TestValueTypes (0.00s)
    --- PASS: TestValueTypes/StringValue (0.00s)
    --- PASS: TestValueTypes/NumberValue (0.00s)
    --- PASS: TestValueTypes/BoolValue (0.00s)
    --- PASS: TestValueTypes/NilValue (0.00s)
    --- PASS: TestValueTypes/ErrorValue (0.00s)
    --- PASS: TestValueTypes/EventValue (0.00s)
    --- PASS: TestValueTypes/TimedateValue (0.00s)
    --- PASS: TestValueTypes/FuzzyValue (0.00s)
=== RUN   TestASTBuilderScenarios
=== RUN   TestASTBuilderScenarios/MinimalStackTestFromPrevious
=== RUN   TestASTBuilderScenarios/DeeplyNestedBlocks
=== RUN   TestASTBuilderScenarios/EmptyAndMinimalBlocks
=== RUN   TestASTBuilderScenarios/SequentialBlocksOfDifferentTypes
=== RUN   TestASTBuilderScenarios/LoopControlsWithNesting
=== RUN   TestASTBuilderScenarios/ScriptWithOnlyMetadataAndComments
=== RUN   TestASTBuilderScenarios/OnErrorAtVeryBeginning
--- PASS: TestASTBuilderScenarios (0.00s)
    --- PASS: TestASTBuilderScenarios/MinimalStackTestFromPrevious (0.00s)
    --- PASS: TestASTBuilderScenarios/DeeplyNestedBlocks (0.00s)
    --- PASS: TestASTBuilderScenarios/EmptyAndMinimalBlocks (0.00s)
    --- PASS: TestASTBuilderScenarios/SequentialBlocksOfDifferentTypes (0.00s)
    --- PASS: TestASTBuilderScenarios/LoopControlsWithNesting (0.00s)
    --- PASS: TestASTBuilderScenarios/ScriptWithOnlyMetadataAndComments (0.00s)
    --- PASS: TestASTBuilderScenarios/OnErrorAtVeryBeginning (0.00s)
=== RUN   TestParseMinimalNewline
    parser_minimal_test.go:53: Minimal script parsed successfully without errors. This might indicate the issue is specific to the break/continue script's content or structure.
--- PASS: TestParseMinimalNewline (0.00s)
FAIL
exit status 1
FAIL	github.com/aprice2704/neuroscript/pkg/core	0.902s

// pkg/core/parser_api.go
package core

import (
	"fmt"
	"io"
	"io/ioutil" // Used to read all bytes from the reader
)

// ParseNeuroScript reads NeuroScript code from an io.Reader, parses it
// using the goyacc-generated parser (yyParse), and returns the resulting
// slice of Procedures or an error.
// ** MODIFIED to get result from lexer object **
func ParseNeuroScript(r io.Reader) ([]Procedure, error) {
	inputBytes, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, fmt.Errorf("error reading input: %w", err)
	}
	inputString := string(inputBytes)

	// Create the lexer instance
	lexer := NewLexer(inputString) // lexer holds the result field

	// Call the parser entry point generated by goyacc.
	// The parser actions should now call lexer.SetResult()
	resultCode := yyParse(lexer) // Pass the concrete lexer instance

	if resultCode != 0 {
		// An error occurred during parsing, yyError should have printed details.
		return nil, fmt.Errorf("parsing failed (syntax error detected)")
	}

	// *** Return the result stored IN THE LEXER object ***
	// Ensure the 'result' field in the lexer struct is accessible (exported or via method)
	// Assuming 'result' is exported (starts with uppercase 'R') or you add a getter method.
	// If 'result' is lowercase, you'll need a getter like 'lexer.GetResult()'.
	// For now, assuming it's accessible directly or via the existing SetResult/internal field:
	if lexer.result == nil {
		// Handle cases where parsing might technically succeed (resultCode==0)
		// but no procedures were actually defined or collected.
		fmt.Println("[Warning] Parsing succeeded but no procedures were collected.")
		return []Procedure{}, nil // Return empty slice, not nil
	}
	return lexer.result, nil
}

// NeuroScript Version: 0.6.2
// File version: 44
// Purpose: Decoder core (part 1) — main dispatch + small readers + anneal fix:
//          mark call-step targets as CallableExpr unconditionally; remove
//          impossible expression-case to satisfy the compiler.
// filename: pkg/canon/decoder_part1.go

package canon

import (
	"bytes"
	"fmt"
	"io"
	"strings"

	"github.com/aprice2704/neuroscript/pkg/ast"
	"github.com/aprice2704/neuroscript/pkg/types"
)

// Decode reconstructs an AST Tree from its canonical binary representation.
func Decode(blob []byte) (*ast.Tree, error) {
	magic := []byte{'N', 'S', 'C', byte(types.KindMarker)}
	if len(blob) < len(magic) {
		return nil, fmt.Errorf("cannot decode blob: too short to be valid")
	}
	if !bytes.Equal(blob[:len(magic)], magic) {
		return nil, fmt.Errorf("invalid magic number: blob is not a valid canonical AST or incompatible version")
	}

	r := &canonReader{r: bytes.NewReader(blob[len(magic):])}
	root, err := r.readNode()
	if err != nil {
		return nil, fmt.Errorf("failed to decode root node: %w", err)
	}
	prog, ok := root.(*ast.Program)
	if !ok {
		return nil, fmt.Errorf("decoded root node is not *ast.Program but %T", root)
	}

	// Post-pass: restore CallTarget.BaseNode.NodeKind deterministically.
	restoreCallTargetKinds(prog)

	return &ast.Tree{Root: prog}, nil
}

type canonReader struct {
	r       *bytes.Reader
	history []string
}

func (r *canonReader) readNode() (ast.Node, error) {
	offset := r.r.Size() - int64(r.r.Len())

	kindVal, err := r.readVarint() // implemented in other decoder parts
	if err != nil {
		if err == io.EOF {
			return nil, err
		}
		return nil, fmt.Errorf("failed to read node kind: %w", err)
	}
	kind := types.Kind(kindVal)
	r.history = append(r.history, fmt.Sprintf("%v", kind))

	switch kind {
	// Structural
	case types.KindProgram:
		return r.readProgram()
	case types.KindProcedureDecl:
		return r.readProcedure()
	case types.KindStep:
		return r.readStep()
	case types.KindCommandBlock:
		return r.readCommand()
	case types.KindOnEventDecl:
		return r.readOnEventDecl()

	// Expressions / literals
	case types.KindLValue:
		return r.readLValue()

	case types.KindStringLiteral:
		s, err := r.readString()
		if err != nil {
			return nil, err
		}
		isRaw, err := r.readBool()
		if err != nil {
			return nil, err
		}
		return &ast.StringLiteralNode{BaseNode: ast.BaseNode{NodeKind: kind}, Value: s, IsRaw: isRaw}, nil

	case types.KindNumberLiteral:
		n, err := r.readNumber()
		if err != nil {
			return nil, err
		}
		return &ast.NumberLiteralNode{BaseNode: ast.BaseNode{NodeKind: kind}, Value: n}, nil

	case types.KindBooleanLiteral:
		b, err := r.readBool()
		if err != nil {
			return nil, err
		}
		return &ast.BooleanLiteralNode{BaseNode: ast.BaseNode{NodeKind: kind}, Value: b}, nil

	case types.KindNilLiteral:
		return &ast.NilLiteralNode{BaseNode: ast.BaseNode{NodeKind: kind}}, nil

	case types.KindCallableExpr:
		return r.readCallableExpr()
	case types.KindVariable:
		name, err := r.readString()
		if err != nil {
			return nil, err
		}
		return &ast.VariableNode{BaseNode: ast.BaseNode{NodeKind: kind}, Name: name}, nil

	case types.KindBinaryOp:
		return r.readBinaryOp()
	case types.KindUnaryOp:
		return r.readUnaryOp()
	case types.KindMapLiteral:
		return r.readMapLiteral()
	case types.KindListLiteral:
		return r.readListLiteral()
	case types.KindElementAccess:
		return r.readElementAccess()
	case types.KindSecretRef:
		return r.readSecretRef()
	case types.KindPlaceholder:
		name, err := r.readString()
		if err != nil {
			return nil, err
		}
		return &ast.PlaceholderNode{BaseNode: ast.BaseNode{NodeKind: kind}, Name: name}, nil

	// Statement-as-expression
	case types.KindExpressionStmt:
		ex, err := r.readNode()
		if err != nil {
			return nil, err
		}
		e, _ := ex.(ast.Expression)
		return &ast.ExpressionStatementNode{BaseNode: ast.BaseNode{NodeKind: kind}, Expression: e}, nil

	// Metadata / misc
	case types.KindMapEntry:
		return r.readMapEntry()
	case types.KindMetadataLine:
		return r.readMetadataLine()

	// ask/promptuser
	case types.KindAskStmt:
		return r.readAskStmt()
	case types.KindPromptUserStmt:
		return r.readPromptUserStmt()

	// Safe aliases (reduce brittleness)
	case types.KindLast, types.KindLastResult:
		return &ast.LastNode{BaseNode: ast.BaseNode{NodeKind: kind}}, nil
	case types.KindEval, types.KindEvalExpr:
		arg, err := r.readNode()
		if err != nil {
			return nil, err
		}
		ex, _ := arg.(ast.Expression)
		return &ast.EvalNode{BaseNode: ast.BaseNode{NodeKind: kind}, Argument: ex}, nil
	case types.KindTypeOf, types.KindTypeOfExpr:
		arg, err := r.readNode()
		if err != nil {
			return nil, err
		}
		ex, _ := arg.(ast.Expression)
		return &ast.TypeOfNode{BaseNode: ast.BaseNode{NodeKind: kind}, Argument: ex}, nil

	default:
		return nil, fmt.Errorf("unhandled node kind for decoding: %v (%d) at byte offset %d. History: [%s]", kind, kind, offset, strings.Join(r.history, ", "))
	}
}

// Small readers (these logically live with part 1)

func (r *canonReader) readMapLiteral() (*ast.MapLiteralNode, error) {
	n, err := r.readVarint()
	if err != nil {
		return nil, fmt.Errorf("map entry count: %w", err)
	}
	m := &ast.MapLiteralNode{
		BaseNode: ast.BaseNode{NodeKind: types.KindMapLiteral},
		Entries:  make([]*ast.MapEntryNode, n),
	}
	for i := 0; i < int(n); i++ {
		node, err := r.readNode()
		if err != nil {
			return nil, fmt.Errorf("map entry[%d]: %w", i, err)
		}
		me, ok := node.(*ast.MapEntryNode)
		if !ok {
			return nil, fmt.Errorf("expected *ast.MapEntryNode, got %T", node)
		}
		m.Entries[i] = me
	}
	return m, nil
}

func (r *canonReader) readMetadataLine() (*ast.MetadataLine, error) {
	k, err := r.readString()
	if err != nil {
		return nil, err
	}
	v, err := r.readString()
	if err != nil {
		return nil, err
	}
	return &ast.MetadataLine{
		BaseNode: ast.BaseNode{NodeKind: types.KindMetadataLine},
		Key:      k,
		Value:    v,
	}, nil
}

// Post-decode annealing

func restoreCallTargetKinds(p *ast.Program) {
	if p == nil {
		return
	}
	// Map of decoded procedure names (if any).
	procs := make(map[string]struct{}, len(p.Procedures))
	for name := range p.Procedures {
		procs[name] = struct{}{}
	}

	var visitExpr func(ast.Expression)
	var visitStep func(*ast.Step)
	var visitLValue func(*ast.LValueNode)

	setTargetKind := func(call *ast.CallableExprNode) {
		if call == nil {
			return
		}
		// If this is a step-level "call", we force CallableExpr — it's a callable by definition.
		// (The step walker sets a flag before calling us.)
		if call.BaseNode.NodeKind == types.KindCallableExpr && call.Target.BaseNode.NodeKind == 0xFFFF {
			call.Target.BaseNode.NodeKind = types.KindCallableExpr
			return
		}
		// Otherwise: tool or decoded procedure => CallableExpr; else => Unknown (built-ins).
		if call.Target.IsTool {
			call.Target.BaseNode.NodeKind = types.KindCallableExpr
			return
		}
		if _, ok := procs[call.Target.Name]; ok {
			call.Target.BaseNode.NodeKind = types.KindCallableExpr
			return
		}
		call.Target.BaseNode.NodeKind = types.KindUnknown
	}

	visitExpr = func(e ast.Expression) {
		switch n := e.(type) {
		case *ast.CallableExprNode:
			// expression context — not a step-level "call"
			setTargetKind(n)
			for _, a := range n.Arguments {
				visitExpr(a)
			}
		case *ast.BinaryOpNode:
			visitExpr(n.Left)
			visitExpr(n.Right)
		case *ast.UnaryOpNode:
			visitExpr(n.Operand)
		case *ast.ListLiteralNode:
			for _, el := range n.Elements {
				visitExpr(el)
			}
		case *ast.MapLiteralNode:
			for _, me := range n.Entries {
				if me != nil {
					visitExpr(me.Value)
				}
			}
		case *ast.ElementAccessNode:
			visitExpr(n.Collection)
			visitExpr(n.Accessor)
		case *ast.EvalNode:
			visitExpr(n.Argument)
		case *ast.TypeOfNode:
			visitExpr(n.Argument)
		// atoms: nothing to do
		case *ast.VariableNode, *ast.StringLiteralNode, *ast.NumberLiteralNode, *ast.BooleanLiteralNode, *ast.NilLiteralNode, *ast.LastNode, *ast.SecretRef, *ast.PlaceholderNode:
		default:
			// be conservative for unknown expression kinds
		}
	}

	visitLValue = func(lv *ast.LValueNode) {
		if lv == nil {
			return
		}
		for _, acc := range lv.Accessors {
			if acc != nil && acc.Key != nil {
				visitExpr(acc.Key)
			}
		}
	}

	visitStep = func(s *ast.Step) {
		if s == nil {
			return
		}
		switch s.Type {
		case "set", "emit", "return", "fail":
			for _, v := range s.Values {
				visitExpr(v)
			}
			for _, lv := range s.LValues {
				visitLValue(lv)
			}
		case "must":
			visitExpr(s.Cond)
		case "if", "while":
			visitExpr(s.Cond)
			for i := range s.Body {
				visitStep(&s.Body[i])
			}
			if s.Type == "if" {
				for i := range s.ElseBody {
					visitStep(&s.ElseBody[i])
				}
			}
		case "for":
			visitExpr(s.Collection)
			for i := range s.Body {
				visitStep(&s.Body[i])
			}
		case "call":
			// Mark this call as step-level so setTargetKind can force CallableExpr.
			if s.Call != nil {
				// Use a sentinel in Target.BaseNode.NodeKind to distinguish this context.
				// (We avoid adding new fields just for annotation.)
				s.Call.Target.BaseNode.NodeKind = 0xFFFF
			}
			setTargetKind(s.Call)
			if s.Call != nil {
				for _, a := range s.Call.Arguments {
					visitExpr(a)
				}
			}
		case "on_error":
			for i := range s.Body {
				visitStep(&s.Body[i])
			}
		case "ask":
			if s.AskStmt != nil {
				visitExpr(s.AskStmt.AgentModelExpr)
				visitExpr(s.AskStmt.PromptExpr)
				if s.AskStmt.WithOptions != nil {
					visitExpr(s.AskStmt.WithOptions)
				}
				visitLValue(s.AskStmt.IntoTarget)
			}
		case "promptuser":
			if s.PromptUserStmt != nil {
				visitExpr(s.PromptUserStmt.PromptExpr)
				visitLValue(s.PromptUserStmt.IntoTarget)
			}
		default:
			// break/continue/clear_error: nothing to do
		}
	}

	// Walk program
	for _, proc := range p.Procedures {
		for i := range proc.Steps {
			visitStep(&proc.Steps[i])
		}
	}
	for _, cmd := range p.Commands {
		for i := range cmd.Body {
			visitStep(&cmd.Body[i])
		}
	}
	for _, ev := range p.Events {
		for i := range ev.Body {
			visitStep(&ev.Body[i])
		}
	}
}

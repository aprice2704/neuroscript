{
  "FDM.Bus.Publish": {
    "prefix": "FDM.Bus.Publish",
    "body": [
      "tool.FDM.Bus.Publish(${1:topic}, ${2:payload_base64}, ${3:scope}, ${4:correlationId})"
    ],
    "description": "Publishes a message to a topic. Source is automatic."
  },
  "FDM.Bus.Request": {
    "prefix": "FDM.Bus.Request",
    "body": [
      "tool.FDM.Bus.Request(${1:topic}, ${2:payload_base64}, ${3:scope}, ${4:timeoutMs})"
    ],
    "description": "Sends a request message and waits for a reply."
  },
  "FDM.CreateNode": {
    "prefix": "FDM.CreateNode",
    "body": [
      "tool.FDM.CreateNode(${1:type}, ${2:fields})"
    ],
    "description": "Creates a new graph node. Specialized builders used for known types."
  },
  "FDM.DeleteNode": {
    "prefix": "FDM.DeleteNode",
    "body": [
      "tool.FDM.DeleteNode({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Deletes a specific node version."
  },
  "FDM.FS.History": {
    "prefix": "FDM.FS.History",
    "body": [
      "tool.FDM.FS.History(${1:path})"
    ],
    "description": "Retrieves the rename/move history for a given path."
  },
  "FDM.FS.ListDir": {
    "prefix": "FDM.FS.ListDir",
    "body": [
      "tool.FDM.FS.ListDir(${1:dirPath}, ${2:recursive})"
    ],
    "description": "Lists the contents of a directory in the FDM."
  },
  "FDM.FS.Lookup": {
    "prefix": "FDM.FS.Lookup",
    "body": [
      "tool.FDM.FS.Lookup(${1:path})"
    ],
    "description": "Looks up a specific path in the filesystem overlay."
  },
  "FDM.FS.Rename": {
    "prefix": "FDM.FS.Rename",
    "body": [
      "tool.FDM.FS.Rename(${1:srcPath}, ${2:dstPath})"
    ],
    "description": "Records a rename/move event for a file or directory."
  },
  "FDM.File.list": {
    "prefix": "FDM.File.list",
    "body": [
      "tool.FDM.File.list()"
    ],
    "description": "Lists indexed file paths."
  },
  "FDM.File.patch": {
    "prefix": "FDM.File.patch",
    "body": [
      "tool.FDM.File.patch(${1:path}, ${2:patchText})"
    ],
    "description": "Applies a diff patch to a file."
  },
  "FDM.File.read": {
    "prefix": "FDM.File.read",
    "body": [
      "tool.FDM.File.read(${1:identifier})"
    ],
    "description": "Reads file content from the Graph."
  },
  "FDM.Forum.CreateForProject": {
    "prefix": "FDM.Forum.CreateForProject",
    "body": [
      "tool.FDM.Forum.CreateForProject(${1:projectEntity}, ${2:title}, ${3:author})"
    ],
    "description": "Creates a new forum thread and links it to a project."
  },
  "FDM.Forum.CreateRoot": {
    "prefix": "FDM.Forum.CreateRoot",
    "body": [
      "tool.FDM.Forum.CreateRoot(${1:title})"
    ],
    "description": "Creates a new standalone root node for a forum or thread."
  },
  "FDM.Forum.Decide": {
    "prefix": "FDM.Forum.Decide",
    "body": [
      "tool.FDM.Forum.Decide(${1:threadID}, ${2:status}, ${3:rationale}, ${4:proposalRef})"
    ],
    "description": "Posts a formal decision message (Tier-A), changing thread state to 'Decided'."
  },
  "FDM.Forum.GetContextBundle": {
    "prefix": "FDM.Forum.GetContextBundle",
    "body": [
      "tool.FDM.Forum.GetContextBundle(${1:threadID}, ${2:count}, ${3:allEpochs})"
    ],
    "description": "Gets the thread head and recent messages as a structured JSON object. By default, only includes messages from the current epoch."
  },
  "FDM.Forum.ListForums": {
    "prefix": "FDM.Forum.ListForums",
    "body": [
      "tool.FDM.Forum.ListForums()"
    ],
    "description": "Lists all available forum threads with their current head metadata."
  },
  "FDM.Forum.ListThread": {
    "prefix": "FDM.Forum.ListThread",
    "body": [
      "tool.FDM.Forum.ListThread(${1:threadID}, ${2:allEpochs})"
    ],
    "description": "Lists messages in a forum thread, sorted by timestamp. By default, only lists messages from the current epoch."
  },
  "FDM.Forum.OpenVote": {
    "prefix": "FDM.Forum.OpenVote",
    "body": [
      "tool.FDM.Forum.OpenVote(${1:threadID}, ${2:proposalRef}, ${3:method})"
    ],
    "description": "Opens a formal vote on a proposal (Tier-A), changing thread state to 'Voting'."
  },
  "FDM.Forum.Post": {
    "prefix": "FDM.Forum.Post",
    "body": [
      "tool.FDM.Forum.Post(${1:threadID}, ${2:parentID}, ${3:markdown}, ${4:kind})"
    ],
    "description": "Posts a new message to a forum thread."
  },
  "FDM.Forum.Propose": {
    "prefix": "FDM.Forum.Propose",
    "body": [
      "tool.FDM.Forum.Propose(${1:threadID}, ${2:title}, ${3:purpose}, ${4:rationale})"
    ],
    "description": "Posts a formal proposal message (Tier-A), changing thread state to 'Pending'."
  },
  "FDM.Forum.Rate": {
    "prefix": "FDM.Forum.Rate",
    "body": [
      "tool.FDM.Forum.Rate(${1:messageID}, ${2:rating}, ${3:reason})"
    ],
    "description": "Submits a bipolar (-1..+1) quality rating for a message."
  },
  "FDM.Forum.Reopen": {
    "prefix": "FDM.Forum.Reopen",
    "body": [
      "tool.FDM.Forum.Reopen(${1:threadID}, ${2:reason}, ${3:decisionRef})"
    ],
    "description": "Reopens a decided or closed thread (Tier-A), starting a new epoch and changing state to 'Open'."
  },
  "FDM.Forum.Summarize": {
    "prefix": "FDM.Forum.Summarize",
    "body": [
      "tool.FDM.Forum.Summarize(${1:rootID}, ${2:content}, ${3:span})"
    ],
    "description": "Generates a summary node for a message or thread."
  },
  "FDM.Forum.Supersede": {
    "prefix": "FDM.Forum.Supersede",
    "body": [
      "tool.FDM.Forum.Supersede(${1:threadID}, ${2:successorThreadID}, ${3:reason})"
    ],
    "description": "Marks a thread as superseded by another (Tier-A), changing state to 'Superseded'."
  },
  "FDM.Forum.System": {
    "prefix": "FDM.Forum.System",
    "body": [
      "tool.FDM.Forum.System(${1:threadID}, ${2:status}, ${3:justification})"
    ],
    "description": "Posts a system administration message (Tier-A), e.g., to close or archive a thread."
  },
  "FDM.Forum.Vote": {
    "prefix": "FDM.Forum.Vote",
    "body": [
      "tool.FDM.Forum.Vote(${1:messageID}, ${2:value})"
    ],
    "description": "Submits a unipolar (+1/support, 0/abstain) vote for a message."
  },
  "FDM.GetNode": {
    "prefix": "FDM.GetNode",
    "body": [
      "tool.FDM.GetNode(${1:id})"
    ],
    "description": "Retrieves a specific node version by NodeID."
  },
  "FDM.IPC.Send": {
    "prefix": "FDM.IPC.Send",
    "body": [
      "tool.FDM.IPC.Send(${1:data})"
    ],
    "description": "Encodes arbitrary data into a high-performance binary envelope and sends it to a connected IPC client like Lotfi."
  },
  "FDM.Meta.Get": {
    "prefix": "FDM.Meta.Get",
    "body": [
      "tool.FDM.Meta.Get(${1:targetID})"
    ],
    "description": "Retrieves metadata attached to a specific node (e.g., a file or chunk ID)."
  },
  "FDM.Ns.GetFunction": {
    "prefix": "FDM.Ns.GetFunction",
    "body": [
      "tool.FDM.Ns.GetFunction(${1:name})"
    ],
    "description": "Retrieves a specific NeuroScript function by name."
  },
  "FDM.Ns.ListFunctions": {
    "prefix": "FDM.Ns.ListFunctions",
    "body": [
      "tool.FDM.Ns.ListFunctions()"
    ],
    "description": "Lists all NeuroScript functions defined in the codebase."
  },
  "FDM.Ns.ListHandlers": {
    "prefix": "FDM.Ns.ListHandlers",
    "body": [
      "tool.FDM.Ns.ListHandlers()"
    ],
    "description": "Lists all NeuroScript event handlers defined in the codebase."
  },
  "FDM.Overlays.ListMeta": {
    "prefix": "FDM.Overlays.ListMeta",
    "body": [
      "tool.FDM.Overlays.ListMeta()"
    ],
    "description": "Lists metadata for all registered overlays."
  },
  "FDM.Overlays.get_fco": {
    "prefix": "FDM.Overlays.get_fco",
    "body": [
      "tool.FDM.Overlays.get_fco()"
    ],
    "description": "Returns the canonical name of the File Content Overlay."
  },
  "FDM.Overlays.get_forum": {
    "prefix": "FDM.Overlays.get_forum",
    "body": [
      "tool.FDM.Overlays.get_forum()"
    ],
    "description": "Returns the canonical name of the forum overlay."
  },
  "FDM.Overlays.get_fso": {
    "prefix": "FDM.Overlays.get_fso",
    "body": [
      "tool.FDM.Overlays.get_fso()"
    ],
    "description": "Returns the canonical name of the Filesystem Overlay."
  },
  "FDM.Plan.AddOverlay": {
    "prefix": "FDM.Plan.AddOverlay",
    "body": [
      "tool.FDM.Plan.AddOverlay(${1:planObj}, ${2:overlayID})"
    ],
    "description": "Adds an overlay to an ingest_plan."
  },
  "FDM.Plan.Create": {
    "prefix": "FDM.Plan.Create",
    "body": [
      "tool.FDM.Plan.Create(${1:repoPath})"
    ],
    "description": "Creates a new ingest_plan node."
  },
  "FDM.Project.Create": {
    "prefix": "FDM.Project.Create",
    "body": [
      "tool.FDM.Project.Create(${1:slug}, ${2:name}, ${3:repos}, ${4:goals}, ${5:overlays}, ${6:teamGroupID})"
    ],
    "description": "Creates a new project node."
  },
  "FDM.Project.Get": {
    "prefix": "FDM.Project.Get",
    "body": [
      "tool.FDM.Project.Get(${1:id_or_handle})"
    ],
    "description": "Retrieves a project node by its unique project ID or Handle."
  },
  "FDM.Project.ListProjects": {
    "prefix": "FDM.Project.ListProjects",
    "body": [
      "tool.FDM.Project.ListProjects()"
    ],
    "description": "Lists all available projects with their core metadata."
  },
  "FDM.Project.Update": {
    "prefix": "FDM.Project.Update",
    "body": [
      "tool.FDM.Project.Update(${1:entity}, ${2:fields})"
    ],
    "description": "Updates fields on an existing project node using Optimistic Locking."
  },
  "FDM.Query": {
    "prefix": "FDM.Query",
    "body": [
      "tool.FDM.Query(${1:filter}, ${2:limit})"
    ],
    "description": "Executes a structured query against the FDM Graph. Supports 'filter' map and optional 'limit'."
  },
  "FDM.RegisterOverlay": {
    "prefix": "FDM.RegisterOverlay",
    "body": [
      "tool.FDM.RegisterOverlay(${1:overlayName})"
    ],
    "description": "Registers a named overlay."
  },
  "FDM.Repo.Ingest": {
    "prefix": "FDM.Repo.Ingest",
    "body": [
      "tool.FDM.Repo.Ingest({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Triggers a full ingestion process based on a plan."
  },
  "FDM.Repo.IngestChanges": {
    "prefix": "FDM.Repo.IngestChanges",
    "body": [
      "tool.FDM.Repo.IngestChanges({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "(Deprecated) Use Ingest instead."
  },
  "FDM.SIO.FindSymbol": {
    "prefix": "FDM.SIO.FindSymbol",
    "body": [
      "tool.FDM.SIO.FindSymbol(${1:symbolName})"
    ],
    "description": "Finds definitions in SIO."
  },
  "FDM.Services.List": {
    "prefix": "FDM.Services.List",
    "body": [
      "tool.FDM.Services.List()"
    ],
    "description": "Lists the status of all registered FDM services."
  },
  "FDM.Symbol.Find": {
    "prefix": "FDM.Symbol.Find",
    "body": [
      "tool.FDM.Symbol.Find(${1:symbolName})"
    ],
    "description": "Finds all definitions of a Go symbol."
  },
  "FDM.Walk.GetEntity": {
    "prefix": "FDM.Walk.GetEntity",
    "body": [
      "tool.FDM.Walk.GetEntity(${1:handle})"
    ],
    "description": "Returns NSEntity object for overlays."
  },
  "FDM.Walk.IsDir": {
    "prefix": "FDM.Walk.IsDir",
    "body": [
      "tool.FDM.Walk.IsDir(${1:handle})"
    ],
    "description": "Returns true if container."
  },
  "FDM.Walk.ModTime": {
    "prefix": "FDM.Walk.ModTime",
    "body": [
      "tool.FDM.Walk.ModTime(${1:handle})"
    ],
    "description": "Returns modification time."
  },
  "FDM.Walk.Ops.StatSummary": {
    "prefix": "FDM.Walk.Ops.StatSummary",
    "body": [
      "tool.FDM.Walk.Ops.StatSummary(${1:handle})"
    ],
    "description": "Returns structural statistics."
  },
  "FDM.Walk.Path": {
    "prefix": "FDM.Walk.Path",
    "body": [
      "tool.FDM.Walk.Path(${1:handle})"
    ],
    "description": "Returns logical path."
  },
  "FDM.Walk.Size": {
    "prefix": "FDM.Walk.Size",
    "body": [
      "tool.FDM.Walk.Size(${1:handle})"
    ],
    "description": "Returns size in bytes."
  },
  "FDM.Walk.Type": {
    "prefix": "FDM.Walk.Type",
    "body": [
      "tool.FDM.Walk.Type(${1:handle})"
    ],
    "description": "Returns handle type tag."
  },
  "account.Delete": {
    "prefix": "account.Delete",
    "body": [
      "tool.account.Delete(${1:name})"
    ],
    "description": "Deletes a provider account configuration."
  },
  "account.Exists": {
    "prefix": "account.Exists",
    "body": [
      "tool.account.Exists(${1:name})"
    ],
    "description": "Checks if an account with the given name is registered."
  },
  "account.List": {
    "prefix": "account.List",
    "body": [
      "tool.account.List()"
    ],
    "description": "Lists the names of all configured provider accounts."
  },
  "account.Register": {
    "prefix": "account.Register",
    "body": [
      "tool.account.Register(${1:name}, ${2:config})"
    ],
    "description": "Registers a new provider account configuration."
  },
  "aeiou.ComposeEnvelope": {
    "prefix": "aeiou.ComposeEnvelope",
    "body": [
      "tool.aeiou.ComposeEnvelope(${1:userdata}, ${2:actions}, ${3:scratchpad}, ${4:output})"
    ],
    "description": "Constructs a valid, multi-line AEIOU v4 envelope string."
  },
  "agentmodel.Delete": {
    "prefix": "agentmodel.Delete",
    "body": [
      "tool.agentmodel.Delete(${1:name})"
    ],
    "description": "Deletes an agent model configuration."
  },
  "agentmodel.Exists": {
    "prefix": "agentmodel.Exists",
    "body": [
      "tool.agentmodel.Exists(${1:name})"
    ],
    "description": "Checks if an agent model with the given name is registered."
  },
  "agentmodel.Get": {
    "prefix": "agentmodel.Get",
    "body": [
      "tool.agentmodel.Get(${1:name})"
    ],
    "description": "Retrieves the full configuration of a registered agent model."
  },
  "agentmodel.List": {
    "prefix": "agentmodel.List",
    "body": [
      "tool.agentmodel.List()"
    ],
    "description": "Lists the names of all configured agent models."
  },
  "agentmodel.Register": {
    "prefix": "agentmodel.Register",
    "body": [
      "tool.agentmodel.Register(${1:name}, ${2:config})"
    ],
    "description": "Registers a new agent model configuration."
  },
  "agentmodel.Select": {
    "prefix": "agentmodel.Select",
    "body": [
      "tool.agentmodel.Select(${1:name})"
    ],
    "description": "Selects a model by name, or the default if no name is provided."
  },
  "agentmodel.Update": {
    "prefix": "agentmodel.Update",
    "body": [
      "tool.agentmodel.Update(${1:name}, ${2:updates})"
    ],
    "description": "Updates an existing agent model configuration."
  },
  "ai.embed.text": {
    "prefix": "ai.embed.text",
    "body": [
      "tool.ai.embed.text(${1:text})"
    ],
    "description": "Generates a semantic vector embedding for the given text."
  },
  "capsule.Add": {
    "prefix": "capsule.Add",
    "body": [
      "tool.capsule.Add(${1:capsuleContent})"
    ],
    "description": "Adds a new capsule to the runtime registry by parsing its content. Requires a privileged interpreter."
  },
  "capsule.GetLatest": {
    "prefix": "capsule.GetLatest",
    "body": [
      "tool.capsule.GetLatest(${1:name})"
    ],
    "description": "Gets the latest version of a capsule by its logical name."
  },
  "capsule.List": {
    "prefix": "capsule.List",
    "body": [
      "tool.capsule.List()"
    ],
    "description": "Lists the IDs of all available documentation capsules."
  },
  "capsule.Parse": {
    "prefix": "capsule.Parse",
    "body": [
      "tool.capsule.Parse(${1:content})"
    ],
    "description": "Parses a raw capsule string (Markdown or NeuroScript) and returns its metadata fields."
  },
  "capsule.Read": {
    "prefix": "capsule.Read",
    "body": [
      "tool.capsule.Read(${1:id})"
    ],
    "description": "Reads a capsule by its full ID ('name@version') or the latest version by name."
  },
  "context.get_payload": {
    "prefix": "context.get_payload",
    "body": [
      "tool.context.get_payload({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the business payload (data map or raw wrapper map) from a raw ns_event structure."
  },
  "context.latest_event": {
    "prefix": "context.latest_event",
    "body": [
      "tool.context.latest_event(${1:events})"
    ],
    "description": "Finds the most recent event (by timestamp) from a list and returns its envelope as a map."
  },
  "context.latest_node": {
    "prefix": "context.latest_node",
    "body": [
      "tool.context.latest_node(${1:events})"
    ],
    "description": "Finds the most recent event (by timestamp) from a list, retrieves its associated node from the graph, and returns the node as a map."
  },
  "context.merged_prompt": {
    "prefix": "context.merged_prompt",
    "body": [
      "tool.context.merged_prompt(${1:events})"
    ],
    "description": "Merges node/event data (title, body, prompt) from a list of events into a single text block, suitable for an AI prompt."
  },
  "debug.dumpClones": {
    "prefix": "debug.dumpClones",
    "body": [
      "tool.debug.dumpClones()"
    ],
    "description": "Logs the state of all registered interpreter clones to the host's stdout."
  },
  "fdm.account.CreateAccount": {
    "prefix": "fdm.account.CreateAccount",
    "body": [
      "tool.fdm.account.CreateAccount(${1:name}, ${2:kind}, ${3:provider}, ${4:api_key}, ${5:org_id}, ${6:project_id})"
    ],
    "description": "Creates a new fdm/account node in the FDM graph."
  },
  "fdm.admin.charter_agent": {
    "prefix": "fdm.admin.charter_agent",
    "body": [
      "tool.fdm.admin.charter_agent({",
      "    \"name\": ${1:name (string)},",
      "    \"kind\": ${2:kind (string)},",
      "    \"script\": ${3:script (string)},",
      "    \"charter\": ${4:charter (string)},",
      "    \"model\": ${5:model (string)},",
      "    \"is_core\": ${6:is_core (bool)}",
      "})"
    ],
    "description": "Charters (creates or updates) an agent with cryptographic identity and signed artifacts."
  },
  "fdm.admin.get_logs": {
    "prefix": "fdm.admin.get_logs",
    "body": [
      "tool.fdm.admin.get_logs(${1:entity_id}, ${2:key})"
    ],
    "description": "Retrieves logs for an entity (Admin/System Context)."
  },
  "fdm.admin.get_sai_did": {
    "prefix": "fdm.admin.get_sai_did",
    "body": [
      "tool.fdm.admin.get_sai_did()"
    ],
    "description": "Returns the DID of the Supervising AI (SAI), which is the core identity of the FDM."
  },
  "fdm.admin.import_agent": {
    "prefix": "fdm.admin.import_agent",
    "body": [
      "tool.fdm.admin.import_agent({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Privileged. Imports an external agent identity into the FDM graph from a details map."
  },
  "fdm.admin.reboot_agent": {
    "prefix": "fdm.admin.reboot_agent",
    "body": [
      "tool.fdm.admin.reboot_agent(${1:did})"
    ],
    "description": "Forces an agent to stop and restart, reloading its configuration and script from the graph head."
  },
  "fdm.admin.set_agent_status": {
    "prefix": "fdm.admin.set_agent_status",
    "body": [
      "tool.fdm.admin.set_agent_status(${1:did}, ${2:status})"
    ],
    "description": "Enables or disables an agent. When disabled, the agent stops running and drops all incoming messages."
  },
  "fdm.admin.set_sai_did": {
    "prefix": "fdm.admin.set_sai_did",
    "body": [
      "tool.fdm.admin.set_sai_did(${1:did})"
    ],
    "description": "Sets the DID of the Supervising AI (SAI) for the FDM instance. Privileged."
  },
  "fdm.admin.sign": {
    "prefix": "fdm.admin.sign",
    "body": [
      "tool.fdm.admin.sign(${1:data_b64})"
    ],
    "description": "Signs raw data bytes using the FDM Core Identity."
  },
  "fdm.admin.sign_agent_artifacts": {
    "prefix": "fdm.admin.sign_agent_artifacts",
    "body": [
      "tool.fdm.admin.sign_agent_artifacts(${1:script_capsule_id}, ${2:charter_capsule_id})"
    ],
    "description": "Fetches latest content for script and charter capsules, signs them (AST hash for script, raw hash for charter), and returns signatures."
  },
  "fdm.agent.AssignModel": {
    "prefix": "fdm.agent.AssignModel",
    "body": [
      "tool.fdm.agent.AssignModel(${1:did}, ${2:modelName})"
    ],
    "description": "Assigns a specific AI model to an agent node by creating a new version of the node."
  },
  "fdm.agent.LoadScriptSigned": {
    "prefix": "fdm.agent.LoadScriptSigned",
    "body": [
      "tool.fdm.agent.LoadScriptSigned(${1:agent_entity}, ${2:script_path}, ${3:signature})"
    ],
    "description": "Updates an agent node with a script path and signature, creating a new version."
  },
  "fdm.agent.SetRole": {
    "prefix": "fdm.agent.SetRole",
    "body": [
      "tool.fdm.agent.SetRole(${1:agent_entity}, ${2:role})"
    ],
    "description": "Sets the 'core:role' field on an agent node, creating a new version."
  },
  "fdm.agent.get_agent_by_did": {
    "prefix": "fdm.agent.get_agent_by_did",
    "body": [
      "tool.fdm.agent.get_agent_by_did(${1:did})"
    ],
    "description": "Retrieves an agent's FDM node by its DID."
  },
  "fdm.agent.get_charter_capsule": {
    "prefix": "fdm.agent.get_charter_capsule",
    "body": [
      "tool.fdm.agent.get_charter_capsule()"
    ],
    "description": "Retrieves the contents of the agent's charter capsule (Cached at Boot)."
  },
  "fdm.agent.get_entity": {
    "prefix": "fdm.agent.get_entity",
    "body": [
      "tool.fdm.agent.get_entity()"
    ],
    "description": "Retrieves the agent's own authoritative NSEntity object (current head)."
  },
  "fdm.agent.get_identities": {
    "prefix": "fdm.agent.get_identities",
    "body": [
      "tool.fdm.agent.get_identities()"
    ],
    "description": "Retrieves the public identity (DID, name, class, status, activity) of all agents in the FDM, as a map keyed by DID."
  },
  "fdm.agent.get_identity": {
    "prefix": "fdm.agent.get_identity",
    "body": [
      "tool.fdm.agent.get_identity()"
    ],
    "description": "Retrieves the agent's own core identity attributes."
  },
  "fdm.agent.get_message_handler_capsule": {
    "prefix": "fdm.agent.get_message_handler_capsule",
    "body": [
      "tool.fdm.agent.get_message_handler_capsule()"
    ],
    "description": "Retrieves the contents of the agent's message handler capsule."
  },
  "fdm.agent.get_model": {
    "prefix": "fdm.agent.get_model",
    "body": [
      "tool.fdm.agent.get_model()"
    ],
    "description": "Retrieves the agent's own default agent_model node."
  },
  "fdm.agent.get_model_name": {
    "prefix": "fdm.agent.get_model_name",
    "body": [
      "tool.fdm.agent.get_model_name()"
    ],
    "description": "Retrieves the registered name of the agent's own default agent_model."
  },
  "fdm.agent.get_node": {
    "prefix": "fdm.agent.get_node",
    "body": [
      "tool.fdm.agent.get_node()"
    ],
    "description": "Retrieves the agent's own FDM node snapshot (immutable version)."
  },
  "fdm.agent.get_noetic_script": {
    "prefix": "fdm.agent.get_noetic_script",
    "body": [
      "tool.fdm.agent.get_noetic_script()"
    ],
    "description": "Retrieves the agent's own startup (Noetic) script source."
  },
  "fdm.agent.grant_caps": {
    "prefix": "fdm.agent.grant_caps",
    "body": [
      "tool.fdm.agent.grant_caps(${1:agent_obj}, ${2:capabilities})"
    ],
    "description": "Grants one or more capabilities to an agent by creating grant nodes."
  },
  "fdm.agent.init_identity": {
    "prefix": "fdm.agent.init_identity",
    "body": [
      "tool.fdm.agent.init_identity(${1:name}, ${2:storage_uri}, ${3:set_as_core})"
    ],
    "description": "Initializes a new core identity (FDM or SAI). Privileged."
  },
  "fdm.agent.is_identity_set": {
    "prefix": "fdm.agent.is_identity_set",
    "body": [
      "tool.fdm.agent.is_identity_set()"
    ],
    "description": "Returns true if the FDM core identity has already been set."
  },
  "fdm.agent.lookup": {
    "prefix": "fdm.agent.lookup",
    "body": [
      "tool.fdm.agent.lookup(${1:did})"
    ],
    "description": "Retrieves the current head node of an agent by its DID."
  },
  "fdm.agent.register_agent": {
    "prefix": "fdm.agent.register_agent",
    "body": [
      "tool.fdm.agent.register_agent(${1:storage_uri}, ${2:script_capsule}, ${3:agent_model}, ${4:charter_capsule_id})"
    ],
    "description": "Creates a signed agent node in the FDM. Privileged."
  },
  "fdm.agent.set_agent_descriptor": {
    "prefix": "fdm.agent.set_agent_descriptor",
    "body": [
      "tool.fdm.agent.set_agent_descriptor(${1:agent_obj}, ${2:interpreter}, ${3:default_tools})"
    ],
    "description": "Creates or updates an agent's runtime descriptor node."
  },
  "fdm.agent.set_noetic_script": {
    "prefix": "fdm.agent.set_noetic_script",
    "body": [
      "tool.fdm.agent.set_noetic_script(${1:script})"
    ],
    "description": "Updates the agent's own startup (Noetic) script source. WARNING: Invalidates signature."
  },
  "fdm.agentmodel.CreateAgentModel": {
    "prefix": "fdm.agentmodel.CreateAgentModel",
    "body": [
      "tool.fdm.agentmodel.CreateAgentModel(${1:name}, ${2:provider}, ${3:model}, ${4:account_name}, ${5:max_turns}, ${6:config})"
    ],
    "description": "Creates a new fdm/agent_model node using named system fields."
  },
  "fdm.agents.get_status": {
    "prefix": "fdm.agents.get_status",
    "body": [
      "tool.fdm.agents.get_status(${1:did})"
    ],
    "description": "Retrieves detailed status and recent lifecycle logs for a specific agent."
  },
  "fdm.agents.list": {
    "prefix": "fdm.agents.list",
    "body": [
      "tool.fdm.agents.list()"
    ],
    "description": "Lists all currently active agents and their status."
  },
  "fdm.analysis.inspect": {
    "prefix": "fdm.analysis.inspect",
    "body": [
      "tool.fdm.analysis.inspect({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Returns status and counters for a specific analysis run or pass."
  },
  "fdm.analysis.logs": {
    "prefix": "fdm.analysis.logs",
    "body": [
      "tool.fdm.analysis.logs(${1:run_id})"
    ],
    "description": "Retrieves pipeline logs for a given run ID."
  },
  "fdm.analysis.ndsa.ingest": {
    "prefix": "fdm.analysis.ndsa.ingest",
    "body": [
      "tool.fdm.analysis.ndsa.ingest({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Parses raw LLM output, sanitizes it, and persists all Atoms/Contracts to the Graph."
  },
  "fdm.analysis.ndsa.sanitize": {
    "prefix": "fdm.analysis.ndsa.sanitize",
    "body": [
      "tool.fdm.analysis.ndsa.sanitize({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Parses and sanitizes raw NDSA JSON output."
  },
  "fdm.analysis.ndsa.submit": {
    "prefix": "fdm.analysis.ndsa.submit",
    "body": [
      "tool.fdm.analysis.ndsa.submit({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Ingests artifacts, updates the WorkItem ledger, and Acks the WorkOrder."
  },
  "fdm.analysis.reconcile": {
    "prefix": "fdm.analysis.reconcile",
    "body": [
      "tool.fdm.analysis.reconcile()"
    ],
    "description": "Forces a router reconciliation cycle to advance stuck pipelines."
  },
  "fdm.analysis.run": {
    "prefix": "fdm.analysis.run",
    "body": [
      "tool.fdm.analysis.run({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Triggers a specific analysis pipeline on a repository."
  },
  "fdm.capsule.CreateCapsule": {
    "prefix": "fdm.capsule.CreateCapsule",
    "body": [
      "tool.fdm.capsule.CreateCapsule(${1:content})"
    ],
    "description": "Creates a new fdm/capsule node from a raw content string."
  },
  "fdm.capsule.ResolveLatest": {
    "prefix": "fdm.capsule.ResolveLatest",
    "body": [
      "tool.fdm.capsule.ResolveLatest(${1:name})"
    ],
    "description": "Resolves the EntityID of the latest version of a capsule by name."
  },
  "fdm.code.census": {
    "prefix": "fdm.code.census",
    "body": [
      "tool.fdm.code.census(${1:repo_path})"
    ],
    "description": "Scans a Go repository and populates the FDM graph with module/package/file/import nodes."
  },
  "fdm.ctxeng.add_file": {
    "prefix": "fdm.ctxeng.add_file",
    "body": [
      "tool.fdm.ctxeng.add_file(${1:handle}, ${2:path}, ${3:content}, ${4:options})"
    ],
    "description": "Adds a file content layer with fencing."
  },
  "fdm.ctxeng.add_system": {
    "prefix": "fdm.ctxeng.add_system",
    "body": [
      "tool.fdm.ctxeng.add_system(${1:handle}, ${2:text}, ${3:options})"
    ],
    "description": "Adds a system instruction layer."
  },
  "fdm.ctxeng.add_user": {
    "prefix": "fdm.ctxeng.add_user",
    "body": [
      "tool.fdm.ctxeng.add_user(${1:handle}, ${2:text}, ${3:options})"
    ],
    "description": "Adds a user instruction layer."
  },
  "fdm.ctxeng.clone": {
    "prefix": "fdm.ctxeng.clone",
    "body": [
      "tool.fdm.ctxeng.clone(${1:handle})"
    ],
    "description": "Clones an existing engine handle."
  },
  "fdm.ctxeng.ensure_cache": {
    "prefix": "fdm.ctxeng.ensure_cache",
    "body": [
      "tool.fdm.ctxeng.ensure_cache(${1:handle}, ${2:account_name}, ${3:ttl_seconds})"
    ],
    "description": "Reconciles the static context with the provider's cache."
  },
  "fdm.ctxeng.fit": {
    "prefix": "fdm.ctxeng.fit",
    "body": [
      "tool.fdm.ctxeng.fit(${1:handle})"
    ],
    "description": "Attempts to fit content within budget."
  },
  "fdm.ctxeng.new": {
    "prefix": "fdm.ctxeng.new",
    "body": [
      "tool.fdm.ctxeng.new(${1:model}, ${2:max_tokens}, ${3:reserved_out}, ${4:safety_pct})"
    ],
    "description": "Creates a new Context Engine instance."
  },
  "fdm.ctxeng.new_from_policy": {
    "prefix": "fdm.ctxeng.new_from_policy",
    "body": [
      "tool.fdm.ctxeng.new_from_policy(${1:policy_id})"
    ],
    "description": "Creates a new Context Engine using a graph-backed context policy."
  },
  "fdm.ctxeng.outline": {
    "prefix": "fdm.ctxeng.outline",
    "body": [
      "tool.fdm.ctxeng.outline(${1:handle})"
    ],
    "description": "Returns the debug manifest."
  },
  "fdm.ctxeng.recall": {
    "prefix": "fdm.ctxeng.recall",
    "body": [
      "tool.fdm.ctxeng.recall(${1:handle}, ${2:query}, ${3:limit}, ${4:options})"
    ],
    "description": "Semantically searches the FDM graph for relevant text."
  },
  "fdm.ctxeng.release": {
    "prefix": "fdm.ctxeng.release",
    "body": [
      "tool.fdm.ctxeng.release(${1:handle})"
    ],
    "description": "Frees the engine handle."
  },
  "fdm.ctxeng.render": {
    "prefix": "fdm.ctxeng.render",
    "body": [
      "tool.fdm.ctxeng.render(${1:handle})"
    ],
    "description": "Renders the final prompt string."
  },
  "fdm.ctxeng.snapshot": {
    "prefix": "fdm.ctxeng.snapshot",
    "body": [
      "tool.fdm.ctxeng.snapshot(${1:handle}, ${2:reason})"
    ],
    "description": "Persists a context snapshot into the FDM graph."
  },
  "fdm.events.compose": {
    "prefix": "fdm.events.compose",
    "body": [
      "tool.fdm.events.compose(${1:kind}, ${2:payload})"
    ],
    "description": "Composes a new standard event object."
  },
  "fdm.events.get_id": {
    "prefix": "fdm.events.get_id",
    "body": [
      "tool.fdm.events.get_id({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the message ID."
  },
  "fdm.events.get_kind": {
    "prefix": "fdm.events.get_kind",
    "body": [
      "tool.fdm.events.get_kind({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the event kind."
  },
  "fdm.events.get_payload": {
    "prefix": "fdm.events.get_payload",
    "body": [
      "tool.fdm.events.get_payload({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the payload from a standard event object."
  },
  "fdm.events.send": {
    "prefix": "fdm.events.send",
    "body": [
      "tool.fdm.events.send({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Sends a pre-composed event object to the FDM bus."
  },
  "fdm.filesync.apply_pass": {
    "prefix": "fdm.filesync.apply_pass",
    "body": [
      "tool.fdm.filesync.apply_pass(${1:pass_id}, ${2:dry_run})"
    ],
    "description": "Applies all patches associated with a Pass Task to the filesystem."
  },
  "fdm.graph.CreateEntity": {
    "prefix": "fdm.graph.CreateEntity",
    "body": [
      "tool.fdm.graph.CreateEntity(${1:id}, ${2:type}, ${3:fields})"
    ],
    "description": "Creates a new Semantic Entity. Returns the NSEntity object {id, _version, _type, fields...}."
  },
  "fdm.graph.DeleteEntity": {
    "prefix": "fdm.graph.DeleteEntity",
    "body": [
      "tool.fdm.graph.DeleteEntity(${1:entity})"
    ],
    "description": "Deletes (tombstones) an Entity. Requires the entity object to ensure you are deleting the version you think you are."
  },
  "fdm.graph.ExtractID": {
    "prefix": "fdm.graph.ExtractID",
    "body": [
      "tool.fdm.graph.ExtractID(${1:entity})"
    ],
    "description": "Extracts the stable EntityID string from an Entity Map or validates a raw ID string."
  },
  "fdm.graph.GetChildren": {
    "prefix": "fdm.graph.GetChildren",
    "body": [
      "tool.fdm.graph.GetChildren(${1:index_id}, ${2:parent_entity})"
    ],
    "description": "Retrieves the child entities of a given parent entity in an FSI index."
  },
  "fdm.graph.GetEntitiesByType": {
    "prefix": "fdm.graph.GetEntitiesByType",
    "body": [
      "tool.fdm.graph.GetEntitiesByType(${1:node_type})"
    ],
    "description": "Retrieves all active entities (Heads) of a specific type."
  },
  "fdm.graph.GetEntity": {
    "prefix": "fdm.graph.GetEntity",
    "body": [
      "tool.fdm.graph.GetEntity(${1:entity})"
    ],
    "description": "Retrieves the current state (Head) of an Entity. Accepts an Entity Object (Map) containing at least 'id'."
  },
  "fdm.graph.GetNodeStats": {
    "prefix": "fdm.graph.GetNodeStats",
    "body": [
      "tool.fdm.graph.GetNodeStats()"
    ],
    "description": "Retrieves comprehensive counts (Total vs Heads) for all node types."
  },
  "fdm.graph.GetNodeTypeCounts": {
    "prefix": "fdm.graph.GetNodeTypeCounts",
    "body": [
      "tool.fdm.graph.GetNodeTypeCounts()"
    ],
    "description": "Retrieves a simple map of total node counts by type."
  },
  "fdm.graph.GetRoots": {
    "prefix": "fdm.graph.GetRoots",
    "body": [
      "tool.fdm.graph.GetRoots(${1:index_id})"
    ],
    "description": "Retrieves the root entities of a given FSI index."
  },
  "fdm.graph.GetSubgraph": {
    "prefix": "fdm.graph.GetSubgraph",
    "body": [
      "tool.fdm.graph.GetSubgraph(${1:ids}, ${2:filter}, ${3:max_hops}, ${4:limit})"
    ],
    "description": "Traverses the graph starting from Entity IDs."
  },
  "fdm.graph.ScanType": {
    "prefix": "fdm.graph.ScanType",
    "body": [
      "tool.fdm.graph.ScanType(${1:node_type})"
    ],
    "description": "Retrieves ALL node versions (History) for a type. DEBUG ONLY."
  },
  "fdm.graph.UpdateEntity": {
    "prefix": "fdm.graph.UpdateEntity",
    "body": [
      "tool.fdm.graph.UpdateEntity(${1:entity}, ${2:fields})"
    ],
    "description": "Updates an existing Entity. Enforces Optimistic Locking by requiring the full 'entity' object with '_version'."
  },
  "fdm.handle.associate": {
    "prefix": "fdm.handle.associate",
    "body": [
      "tool.fdm.handle.associate({",
      "    \"type\": ${1:type (string)},",
      "    \"id\": ${2:id (entityid)},",
      "    \"handle\": ${3:handle (string)}",
      "})"
    ],
    "description": "Assigns a unique handle to an existing entity."
  },
  "fdm.handle.get": {
    "prefix": "fdm.handle.get",
    "body": [
      "tool.fdm.handle.get({",
      "    \"id\": ${1:id (entityid)}",
      "})"
    ],
    "description": "Retrieves the handle for an EntityID."
  },
  "fdm.handle.getdisplayname": {
    "prefix": "fdm.handle.getdisplayname",
    "body": [
      "tool.fdm.handle.getdisplayname({",
      "    \"id\": ${1:id (entityid)}",
      "})"
    ],
    "description": "Retrieves the non-unique fdm:displayname for an entity."
  },
  "fdm.handle.list": {
    "prefix": "fdm.handle.list",
    "body": [
      "tool.fdm.handle.list({",
      "    \"match\": ${1:match (string)}",
      "})"
    ],
    "description": "Debug tool to list handles matching a substring."
  },
  "fdm.handle.lookup": {
    "prefix": "fdm.handle.lookup",
    "body": [
      "tool.fdm.handle.lookup({",
      "    \"type\": ${1:type (string)},",
      "    \"handle\": ${2:handle (string)}",
      "})"
    ],
    "description": "Resolves a handle to an EntityID, returning nil if not found."
  },
  "fdm.handle.resolve": {
    "prefix": "fdm.handle.resolve",
    "body": [
      "tool.fdm.handle.resolve({",
      "    \"type\": ${1:type (string)},",
      "    \"handle\": ${2:handle (string)}",
      "})"
    ],
    "description": "Resolves a human-friendly handle to a stable EntityID."
  },
  "fdm.handle.setdisplayname": {
    "prefix": "fdm.handle.setdisplayname",
    "body": [
      "tool.fdm.handle.setdisplayname({",
      "    \"id\": ${1:id (entityid)},",
      "    \"name\": ${2:name (string)}",
      "})"
    ],
    "description": "Sets the human-readable display name for an entity."
  },
  "fdm.index.search_files": {
    "prefix": "fdm.index.search_files",
    "body": [
      "tool.fdm.index.search_files(${1:query}, ${2:provider}, ${3:limit})"
    ],
    "description": "Semantic search that aggregates chunks to find relevant files."
  },
  "fdm.index.search_vectors": {
    "prefix": "fdm.index.search_vectors",
    "body": [
      "tool.fdm.index.search_vectors(${1:query}, ${2:provider}, ${3:limit}, ${4:min_score})"
    ],
    "description": "Performs a raw semantic search against the vector index, returning chunks."
  },
  "fdm.llm.CountTokens": {
    "prefix": "fdm.llm.CountTokens",
    "body": [
      "tool.fdm.llm.CountTokens(${1:agent_name}, ${2:text})"
    ],
    "description": "Counts the tokens for a given text using a specified agent's model."
  },
  "fdm.logging.append": {
    "prefix": "fdm.logging.append",
    "body": [
      "tool.fdm.logging.append(${1:content}, ${2:key})"
    ],
    "description": "Appends a line of text to an off-graph log associated with the current agent entity."
  },
  "fdm.logging.get_all": {
    "prefix": "fdm.logging.get_all",
    "body": [
      "tool.fdm.logging.get_all(${1:entityid}, ${2:key})"
    ],
    "description": "Retrieves all log lines for a specific entity and key."
  },
  "fdm.nodes.agent.descriptor.create": {
    "prefix": "fdm.nodes.agent.descriptor.create",
    "body": [
      "tool.fdm.nodes.agent.descriptor.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AgentDescriptor. Expects a map of fields.\\nValid keys:\\n- agenttargetdid: Subject EntityID (Required)\\n- agentinterpreter: Interpreter ID/Type (Required)\\n- agentdefaulttools: List of default tools"
  },
  "fdm.nodes.agent.descriptor.find": {
    "prefix": "fdm.nodes.agent.descriptor.find",
    "body": [
      "tool.fdm.nodes.agent.descriptor.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AgentDescriptor nodes by exact field match."
  },
  "fdm.nodes.agent.descriptor.get": {
    "prefix": "fdm.nodes.agent.descriptor.get",
    "body": [
      "tool.fdm.nodes.agent.descriptor.get(${1:id})"
    ],
    "description": "Gets a AgentDescriptor node by E_ or N_ ID."
  },
  "fdm.nodes.agent.descriptor.list": {
    "prefix": "fdm.nodes.agent.descriptor.list",
    "body": [
      "tool.fdm.nodes.agent.descriptor.list()"
    ],
    "description": "Lists all active AgentDescriptor nodes."
  },
  "fdm.nodes.agent.descriptor.mutate": {
    "prefix": "fdm.nodes.agent.descriptor.mutate",
    "body": [
      "tool.fdm.nodes.agent.descriptor.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AgentDescriptor. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- agenttargetdid: Subject EntityID (Required)\\n- agentinterpreter: Interpreter ID/Type (Required)\\n- agentdefaulttools: List of default tools"
  },
  "fdm.nodes.agent.descriptor.upsert": {
    "prefix": "fdm.nodes.agent.descriptor.upsert",
    "body": [
      "tool.fdm.nodes.agent.descriptor.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AgentDescriptor entity exists with the given human handle."
  },
  "fdm.nodes.agent.grant.create": {
    "prefix": "fdm.nodes.agent.grant.create",
    "body": [
      "tool.fdm.nodes.agent.grant.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AgentGrant. Expects a map of fields.\\nValid keys:\\n- agenttargetdid: Beneficiary EntityID (Required)\\n- agentcapability: Granted capability string (Required)"
  },
  "fdm.nodes.agent.grant.find": {
    "prefix": "fdm.nodes.agent.grant.find",
    "body": [
      "tool.fdm.nodes.agent.grant.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AgentGrant nodes by exact field match."
  },
  "fdm.nodes.agent.grant.get": {
    "prefix": "fdm.nodes.agent.grant.get",
    "body": [
      "tool.fdm.nodes.agent.grant.get(${1:id})"
    ],
    "description": "Gets a AgentGrant node by E_ or N_ ID."
  },
  "fdm.nodes.agent.grant.list": {
    "prefix": "fdm.nodes.agent.grant.list",
    "body": [
      "tool.fdm.nodes.agent.grant.list()"
    ],
    "description": "Lists all active AgentGrant nodes."
  },
  "fdm.nodes.agent.grant.mutate": {
    "prefix": "fdm.nodes.agent.grant.mutate",
    "body": [
      "tool.fdm.nodes.agent.grant.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AgentGrant. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- agenttargetdid: Beneficiary EntityID (Required)\\n- agentcapability: Granted capability string (Required)"
  },
  "fdm.nodes.agent.grant.upsert": {
    "prefix": "fdm.nodes.agent.grant.upsert",
    "body": [
      "tool.fdm.nodes.agent.grant.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AgentGrant entity exists with the given human handle."
  },
  "fdm.nodes.ai.cache_ref.create": {
    "prefix": "fdm.nodes.ai.cache_ref.create",
    "body": [
      "tool.fdm.nodes.ai.cache_ref.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AiCacheRef. Expects a map of fields.\\nValid keys:\\n- aiprovider: The LLM provider hosting this cache. (Required)\\n- aimodel: The specific model ID this cache is built for. (Required)\\n- aicontenthash: SHA256 hash of the static context content. (Required)\\n- airemoteid: The provider-assigned identifier for the cache. (Required)\\n- aiexpiresat: When the remote cache is scheduled to expire. (Required)\\n- aitokencount: The number of tokens in the cached block. (Required)"
  },
  "fdm.nodes.ai.cache_ref.find": {
    "prefix": "fdm.nodes.ai.cache_ref.find",
    "body": [
      "tool.fdm.nodes.ai.cache_ref.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AiCacheRef nodes by exact field match."
  },
  "fdm.nodes.ai.cache_ref.get": {
    "prefix": "fdm.nodes.ai.cache_ref.get",
    "body": [
      "tool.fdm.nodes.ai.cache_ref.get(${1:id})"
    ],
    "description": "Gets a AiCacheRef node by E_ or N_ ID."
  },
  "fdm.nodes.ai.cache_ref.list": {
    "prefix": "fdm.nodes.ai.cache_ref.list",
    "body": [
      "tool.fdm.nodes.ai.cache_ref.list()"
    ],
    "description": "Lists all active AiCacheRef nodes."
  },
  "fdm.nodes.ai.cache_ref.mutate": {
    "prefix": "fdm.nodes.ai.cache_ref.mutate",
    "body": [
      "tool.fdm.nodes.ai.cache_ref.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AiCacheRef. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- aiprovider: The LLM provider hosting this cache. (Required)\\n- aimodel: The specific model ID this cache is built for. (Required)\\n- aicontenthash: SHA256 hash of the static context content. (Required)\\n- airemoteid: The provider-assigned identifier for the cache. (Required)\\n- aiexpiresat: When the remote cache is scheduled to expire. (Required)\\n- aitokencount: The number of tokens in the cached block. (Required)"
  },
  "fdm.nodes.ai.cache_ref.upsert": {
    "prefix": "fdm.nodes.ai.cache_ref.upsert",
    "body": [
      "tool.fdm.nodes.ai.cache_ref.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AiCacheRef entity exists with the given human handle."
  },
  "fdm.nodes.ai.context_policy.create": {
    "prefix": "fdm.nodes.ai.context_policy.create",
    "body": [
      "tool.fdm.nodes.ai.context_policy.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AiContextPolicy. Expects a map of fields.\\nValid keys:\\n- aimodelid: Target Model ID (Required)\\n- aibudgetmax: Maximum token budget\\n- aibudgetreserved: Reserved token amount\\n- aibudgetsafety: Safety buffer amount"
  },
  "fdm.nodes.ai.context_policy.find": {
    "prefix": "fdm.nodes.ai.context_policy.find",
    "body": [
      "tool.fdm.nodes.ai.context_policy.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AiContextPolicy nodes by exact field match."
  },
  "fdm.nodes.ai.context_policy.get": {
    "prefix": "fdm.nodes.ai.context_policy.get",
    "body": [
      "tool.fdm.nodes.ai.context_policy.get(${1:id})"
    ],
    "description": "Gets a AiContextPolicy node by E_ or N_ ID."
  },
  "fdm.nodes.ai.context_policy.list": {
    "prefix": "fdm.nodes.ai.context_policy.list",
    "body": [
      "tool.fdm.nodes.ai.context_policy.list()"
    ],
    "description": "Lists all active AiContextPolicy nodes."
  },
  "fdm.nodes.ai.context_policy.mutate": {
    "prefix": "fdm.nodes.ai.context_policy.mutate",
    "body": [
      "tool.fdm.nodes.ai.context_policy.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AiContextPolicy. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- aimodelid: Target Model ID (Required)\\n- aibudgetmax: Maximum token budget\\n- aibudgetreserved: Reserved token amount\\n- aibudgetsafety: Safety buffer amount"
  },
  "fdm.nodes.ai.context_policy.upsert": {
    "prefix": "fdm.nodes.ai.context_policy.upsert",
    "body": [
      "tool.fdm.nodes.ai.context_policy.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AiContextPolicy entity exists with the given human handle."
  },
  "fdm.nodes.ai.context_snapshot.create": {
    "prefix": "fdm.nodes.ai.context_snapshot.create",
    "body": [
      "tool.fdm.nodes.ai.context_snapshot.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AiContextSnapshot. Expects a map of fields.\\nValid keys:\\n- ainonce: Unique nonce (Required)\\n- aireason: Snapshot trigger reason (Required)\\n- aipolicyid: Active Policy ID\\n- aimodelid: Model ID\\n- aibudgetmax: Max budget\\n- aibudgetreserved: Reserved budget\\n- aibudgetsafety: Safety buffer\\n- aipressureused: Used tokens\\n- aipressurelimit: Limit tokens\\n- aipressureutil: Utilization ratio\\n- aipressureover: Over budget flag\\n- ailayers: Context layers"
  },
  "fdm.nodes.ai.context_snapshot.find": {
    "prefix": "fdm.nodes.ai.context_snapshot.find",
    "body": [
      "tool.fdm.nodes.ai.context_snapshot.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AiContextSnapshot nodes by exact field match."
  },
  "fdm.nodes.ai.context_snapshot.get": {
    "prefix": "fdm.nodes.ai.context_snapshot.get",
    "body": [
      "tool.fdm.nodes.ai.context_snapshot.get(${1:id})"
    ],
    "description": "Gets a AiContextSnapshot node by E_ or N_ ID."
  },
  "fdm.nodes.ai.context_snapshot.list": {
    "prefix": "fdm.nodes.ai.context_snapshot.list",
    "body": [
      "tool.fdm.nodes.ai.context_snapshot.list()"
    ],
    "description": "Lists all active AiContextSnapshot nodes."
  },
  "fdm.nodes.ai.context_snapshot.mutate": {
    "prefix": "fdm.nodes.ai.context_snapshot.mutate",
    "body": [
      "tool.fdm.nodes.ai.context_snapshot.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AiContextSnapshot. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ainonce: Unique nonce (Required)\\n- aireason: Snapshot trigger reason (Required)\\n- aipolicyid: Active Policy ID\\n- aimodelid: Model ID\\n- aibudgetmax: Max budget\\n- aibudgetreserved: Reserved budget\\n- aibudgetsafety: Safety buffer\\n- aipressureused: Used tokens\\n- aipressurelimit: Limit tokens\\n- aipressureutil: Utilization ratio\\n- aipressureover: Over budget flag\\n- ailayers: Context layers"
  },
  "fdm.nodes.ai.context_snapshot.upsert": {
    "prefix": "fdm.nodes.ai.context_snapshot.upsert",
    "body": [
      "tool.fdm.nodes.ai.context_snapshot.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AiContextSnapshot entity exists with the given human handle."
  },
  "fdm.nodes.analysis.pass_run.create": {
    "prefix": "fdm.nodes.analysis.pass_run.create",
    "body": [
      "tool.fdm.nodes.analysis.pass_run.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AnalysisPassRun. Expects a map of fields.\\nValid keys:\\n- analysisrunid: Parent Analysis Run (Snapshot) (Required)\\n- analysispassid: The ID of the pass (e.g. 'structure', 'contracts') (Required)\\n- analysispassstatus: Pass execution status (Required)\\n- analysiscounters: WorkItem status counters\\n- analysispolicysnapshot: Configuration policy snapshot"
  },
  "fdm.nodes.analysis.pass_run.find": {
    "prefix": "fdm.nodes.analysis.pass_run.find",
    "body": [
      "tool.fdm.nodes.analysis.pass_run.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AnalysisPassRun nodes by exact field match."
  },
  "fdm.nodes.analysis.pass_run.get": {
    "prefix": "fdm.nodes.analysis.pass_run.get",
    "body": [
      "tool.fdm.nodes.analysis.pass_run.get(${1:id})"
    ],
    "description": "Gets a AnalysisPassRun node by E_ or N_ ID."
  },
  "fdm.nodes.analysis.pass_run.list": {
    "prefix": "fdm.nodes.analysis.pass_run.list",
    "body": [
      "tool.fdm.nodes.analysis.pass_run.list()"
    ],
    "description": "Lists all active AnalysisPassRun nodes."
  },
  "fdm.nodes.analysis.pass_run.mutate": {
    "prefix": "fdm.nodes.analysis.pass_run.mutate",
    "body": [
      "tool.fdm.nodes.analysis.pass_run.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AnalysisPassRun. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- analysisrunid: Parent Analysis Run (Snapshot) (Required)\\n- analysispassid: The ID of the pass (e.g. 'structure', 'contracts') (Required)\\n- analysispassstatus: Pass execution status (Required)\\n- analysiscounters: WorkItem status counters\\n- analysispolicysnapshot: Configuration policy snapshot"
  },
  "fdm.nodes.analysis.pass_run.upsert": {
    "prefix": "fdm.nodes.analysis.pass_run.upsert",
    "body": [
      "tool.fdm.nodes.analysis.pass_run.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AnalysisPassRun entity exists with the given human handle."
  },
  "fdm.nodes.analysis.run.create": {
    "prefix": "fdm.nodes.analysis.run.create",
    "body": [
      "tool.fdm.nodes.analysis.run.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new AnalysisRun. Expects a map of fields.\\nValid keys:\\n- analysisrunts: Start timestamp (nanoseconds) (Required)\\n- analysispasses: List of passes included in this run\\n- analysisdurationms: Execution duration in milliseconds\\n- analysisrunstatus: Overall run status\\n- analysisconfigname: Name of the pipeline config\\n- analysisconfighash: Hash of the pipeline config\\n- verrepoid: Repository EntityID (Required)\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference"
  },
  "fdm.nodes.analysis.run.find": {
    "prefix": "fdm.nodes.analysis.run.find",
    "body": [
      "tool.fdm.nodes.analysis.run.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds AnalysisRun nodes by exact field match."
  },
  "fdm.nodes.analysis.run.get": {
    "prefix": "fdm.nodes.analysis.run.get",
    "body": [
      "tool.fdm.nodes.analysis.run.get(${1:id})"
    ],
    "description": "Gets a AnalysisRun node by E_ or N_ ID."
  },
  "fdm.nodes.analysis.run.list": {
    "prefix": "fdm.nodes.analysis.run.list",
    "body": [
      "tool.fdm.nodes.analysis.run.list()"
    ],
    "description": "Lists all active AnalysisRun nodes."
  },
  "fdm.nodes.analysis.run.mutate": {
    "prefix": "fdm.nodes.analysis.run.mutate",
    "body": [
      "tool.fdm.nodes.analysis.run.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for AnalysisRun. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- analysisrunts: Start timestamp (nanoseconds) (Required)\\n- analysispasses: List of passes included in this run\\n- analysisdurationms: Execution duration in milliseconds\\n- analysisrunstatus: Overall run status\\n- analysisconfigname: Name of the pipeline config\\n- analysisconfighash: Hash of the pipeline config\\n- verrepoid: Repository EntityID (Required)\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference"
  },
  "fdm.nodes.analysis.run.upsert": {
    "prefix": "fdm.nodes.analysis.run.upsert",
    "body": [
      "tool.fdm.nodes.analysis.run.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a AnalysisRun entity exists with the given human handle."
  },
  "fdm.nodes.capsule.def.create": {
    "prefix": "fdm.nodes.capsule.def.create",
    "body": [
      "tool.fdm.nodes.capsule.def.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CapsuleDef. Expects a map of fields.\\nValid keys:\\n"
  },
  "fdm.nodes.capsule.def.find": {
    "prefix": "fdm.nodes.capsule.def.find",
    "body": [
      "tool.fdm.nodes.capsule.def.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CapsuleDef nodes by exact field match."
  },
  "fdm.nodes.capsule.def.get": {
    "prefix": "fdm.nodes.capsule.def.get",
    "body": [
      "tool.fdm.nodes.capsule.def.get(${1:id})"
    ],
    "description": "Gets a CapsuleDef node by E_ or N_ ID."
  },
  "fdm.nodes.capsule.def.list": {
    "prefix": "fdm.nodes.capsule.def.list",
    "body": [
      "tool.fdm.nodes.capsule.def.list()"
    ],
    "description": "Lists all active CapsuleDef nodes."
  },
  "fdm.nodes.capsule.def.mutate": {
    "prefix": "fdm.nodes.capsule.def.mutate",
    "body": [
      "tool.fdm.nodes.capsule.def.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CapsuleDef. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n"
  },
  "fdm.nodes.capsule.def.upsert": {
    "prefix": "fdm.nodes.capsule.def.upsert",
    "body": [
      "tool.fdm.nodes.capsule.def.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CapsuleDef entity exists with the given human handle."
  },
  "fdm.nodes.code.binary_chunk.create": {
    "prefix": "fdm.nodes.code.binary_chunk.create",
    "body": [
      "tool.fdm.nodes.code.binary_chunk.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeBinaryChunk. Expects a map of fields.\\nValid keys:\\n- fsiparent: Parent file reference (Required)\\n- codeoffset: Byte offset in the parent file (Required)\\n- codecontent: Binary content of the chunk (Required)\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference"
  },
  "fdm.nodes.code.binary_chunk.find": {
    "prefix": "fdm.nodes.code.binary_chunk.find",
    "body": [
      "tool.fdm.nodes.code.binary_chunk.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeBinaryChunk nodes by exact field match."
  },
  "fdm.nodes.code.binary_chunk.get": {
    "prefix": "fdm.nodes.code.binary_chunk.get",
    "body": [
      "tool.fdm.nodes.code.binary_chunk.get(${1:id})"
    ],
    "description": "Gets a CodeBinaryChunk node by E_ or N_ ID."
  },
  "fdm.nodes.code.binary_chunk.list": {
    "prefix": "fdm.nodes.code.binary_chunk.list",
    "body": [
      "tool.fdm.nodes.code.binary_chunk.list()"
    ],
    "description": "Lists all active CodeBinaryChunk nodes."
  },
  "fdm.nodes.code.binary_chunk.mutate": {
    "prefix": "fdm.nodes.code.binary_chunk.mutate",
    "body": [
      "tool.fdm.nodes.code.binary_chunk.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeBinaryChunk. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fsiparent: Parent file reference (Required)\\n- codeoffset: Byte offset in the parent file (Required)\\n- codecontent: Binary content of the chunk (Required)\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference"
  },
  "fdm.nodes.code.binary_chunk.upsert": {
    "prefix": "fdm.nodes.code.binary_chunk.upsert",
    "body": [
      "tool.fdm.nodes.code.binary_chunk.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeBinaryChunk entity exists with the given human handle."
  },
  "fdm.nodes.code.chunk.create": {
    "prefix": "fdm.nodes.code.chunk.create",
    "body": [
      "tool.fdm.nodes.code.chunk.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeChunk. Expects a map of fields.\\nValid keys:\\n- codelanguage: Chunk language\\n- codetext: The raw text of the chunk (Required)\\n- codecontent: The semantic content of the chunk\\n- codestartline: Starting line number\\n- codeembedding: Vector embedding\\n- codeembeddingmodel: Model used for embedding (e.g. text-embedding-004)\\n- codeembeddingver: Version/config of the embedder\\n- fsiparent: Reference to the parent file or node (Required)\\n- fsidefinessymbol: Symbols defined in this chunk\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference"
  },
  "fdm.nodes.code.chunk.find": {
    "prefix": "fdm.nodes.code.chunk.find",
    "body": [
      "tool.fdm.nodes.code.chunk.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeChunk nodes by exact field match."
  },
  "fdm.nodes.code.chunk.get": {
    "prefix": "fdm.nodes.code.chunk.get",
    "body": [
      "tool.fdm.nodes.code.chunk.get(${1:id})"
    ],
    "description": "Gets a CodeChunk node by E_ or N_ ID."
  },
  "fdm.nodes.code.chunk.list": {
    "prefix": "fdm.nodes.code.chunk.list",
    "body": [
      "tool.fdm.nodes.code.chunk.list()"
    ],
    "description": "Lists all active CodeChunk nodes."
  },
  "fdm.nodes.code.chunk.mutate": {
    "prefix": "fdm.nodes.code.chunk.mutate",
    "body": [
      "tool.fdm.nodes.code.chunk.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeChunk. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- codelanguage: Chunk language\\n- codetext: The raw text of the chunk (Required)\\n- codecontent: The semantic content of the chunk\\n- codestartline: Starting line number\\n- codeembedding: Vector embedding\\n- codeembeddingmodel: Model used for embedding (e.g. text-embedding-004)\\n- codeembeddingver: Version/config of the embedder\\n- fsiparent: Reference to the parent file or node (Required)\\n- fsidefinessymbol: Symbols defined in this chunk\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference"
  },
  "fdm.nodes.code.chunk.upsert": {
    "prefix": "fdm.nodes.code.chunk.upsert",
    "body": [
      "tool.fdm.nodes.code.chunk.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeChunk entity exists with the given human handle."
  },
  "fdm.nodes.code.context_bundle.create": {
    "prefix": "fdm.nodes.code.context_bundle.create",
    "body": [
      "tool.fdm.nodes.code.context_bundle.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeContextBundle. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Bundle Name (Required)\\n- fdmdescription: Description of the bundle content\\n- codecontent: Serialized content (JSON/Text) (Required)\\n- codeformat: Format of the content (Required)\\n- codeformula: The query recipe used to generate this bundle (Required)\\n- codeprovenance: Reference to the Analysis Run snapshot used (Required)"
  },
  "fdm.nodes.code.context_bundle.find": {
    "prefix": "fdm.nodes.code.context_bundle.find",
    "body": [
      "tool.fdm.nodes.code.context_bundle.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeContextBundle nodes by exact field match."
  },
  "fdm.nodes.code.context_bundle.get": {
    "prefix": "fdm.nodes.code.context_bundle.get",
    "body": [
      "tool.fdm.nodes.code.context_bundle.get(${1:id})"
    ],
    "description": "Gets a CodeContextBundle node by E_ or N_ ID."
  },
  "fdm.nodes.code.context_bundle.list": {
    "prefix": "fdm.nodes.code.context_bundle.list",
    "body": [
      "tool.fdm.nodes.code.context_bundle.list()"
    ],
    "description": "Lists all active CodeContextBundle nodes."
  },
  "fdm.nodes.code.context_bundle.mutate": {
    "prefix": "fdm.nodes.code.context_bundle.mutate",
    "body": [
      "tool.fdm.nodes.code.context_bundle.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeContextBundle. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Bundle Name (Required)\\n- fdmdescription: Description of the bundle content\\n- codecontent: Serialized content (JSON/Text) (Required)\\n- codeformat: Format of the content (Required)\\n- codeformula: The query recipe used to generate this bundle (Required)\\n- codeprovenance: Reference to the Analysis Run snapshot used (Required)"
  },
  "fdm.nodes.code.context_bundle.upsert": {
    "prefix": "fdm.nodes.code.context_bundle.upsert",
    "body": [
      "tool.fdm.nodes.code.context_bundle.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeContextBundle entity exists with the given human handle."
  },
  "fdm.nodes.code.contract.create": {
    "prefix": "fdm.nodes.code.contract.create",
    "body": [
      "tool.fdm.nodes.code.contract.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeContract. Expects a map of fields.\\nValid keys:\\n- contractsubject: Subject of the contract (Required)\\n- contracttype: Type (function, interface)\\n- contractvisibility: Visibility (public, private)\\n- contractsignature: Full signature string\\n- fdmdisplayname: Name (e.g. DoWork) (Required)\\n- contractpkg: Package name\\n- contractcontractistool: Is this a tool?\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.code.contract.find": {
    "prefix": "fdm.nodes.code.contract.find",
    "body": [
      "tool.fdm.nodes.code.contract.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeContract nodes by exact field match."
  },
  "fdm.nodes.code.contract.get": {
    "prefix": "fdm.nodes.code.contract.get",
    "body": [
      "tool.fdm.nodes.code.contract.get(${1:id})"
    ],
    "description": "Gets a CodeContract node by E_ or N_ ID."
  },
  "fdm.nodes.code.contract.list": {
    "prefix": "fdm.nodes.code.contract.list",
    "body": [
      "tool.fdm.nodes.code.contract.list()"
    ],
    "description": "Lists all active CodeContract nodes."
  },
  "fdm.nodes.code.contract.mutate": {
    "prefix": "fdm.nodes.code.contract.mutate",
    "body": [
      "tool.fdm.nodes.code.contract.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeContract. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- contractsubject: Subject of the contract (Required)\\n- contracttype: Type (function, interface)\\n- contractvisibility: Visibility (public, private)\\n- contractsignature: Full signature string\\n- fdmdisplayname: Name (e.g. DoWork) (Required)\\n- contractpkg: Package name\\n- contractcontractistool: Is this a tool?\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.code.contract.upsert": {
    "prefix": "fdm.nodes.code.contract.upsert",
    "body": [
      "tool.fdm.nodes.code.contract.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeContract entity exists with the given human handle."
  },
  "fdm.nodes.code.file.create": {
    "prefix": "fdm.nodes.code.file.create",
    "body": [
      "tool.fdm.nodes.code.file.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeFile. Expects a map of fields.\\nValid keys:\\n- codepath: Relative path of the file (Identity) (Required)\\n- codecontent: The full textual content of the file\\n- codeabspath: Absolute filesystem path (IO)\\n- codelanguage: Detected language (Required)\\n- codesha: Content SHA\\n- codesize: File size in bytes\\n- codemode: File permission mode\\n- codemodtime: Modification time\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference\\n- verbranch: Branch name\\n- vertag: Tag name\\n- fsiparent: Parent directory or container"
  },
  "fdm.nodes.code.file.find": {
    "prefix": "fdm.nodes.code.file.find",
    "body": [
      "tool.fdm.nodes.code.file.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeFile nodes by exact field match."
  },
  "fdm.nodes.code.file.get": {
    "prefix": "fdm.nodes.code.file.get",
    "body": [
      "tool.fdm.nodes.code.file.get(${1:id})"
    ],
    "description": "Gets a CodeFile node by E_ or N_ ID."
  },
  "fdm.nodes.code.file.list": {
    "prefix": "fdm.nodes.code.file.list",
    "body": [
      "tool.fdm.nodes.code.file.list()"
    ],
    "description": "Lists all active CodeFile nodes."
  },
  "fdm.nodes.code.file.mutate": {
    "prefix": "fdm.nodes.code.file.mutate",
    "body": [
      "tool.fdm.nodes.code.file.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeFile. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- codepath: Relative path of the file (Identity) (Required)\\n- codecontent: The full textual content of the file\\n- codeabspath: Absolute filesystem path (IO)\\n- codelanguage: Detected language (Required)\\n- codesha: Content SHA\\n- codesize: File size in bytes\\n- codemode: File permission mode\\n- codemodtime: Modification time\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio reference\\n- verbranch: Branch name\\n- vertag: Tag name\\n- fsiparent: Parent directory or container"
  },
  "fdm.nodes.code.file.upsert": {
    "prefix": "fdm.nodes.code.file.upsert",
    "body": [
      "tool.fdm.nodes.code.file.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeFile entity exists with the given human handle."
  },
  "fdm.nodes.code.line.create": {
    "prefix": "fdm.nodes.code.line.create",
    "body": [
      "tool.fdm.nodes.code.line.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeLine. Expects a map of fields.\\nValid keys:\\n"
  },
  "fdm.nodes.code.line.find": {
    "prefix": "fdm.nodes.code.line.find",
    "body": [
      "tool.fdm.nodes.code.line.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeLine nodes by exact field match."
  },
  "fdm.nodes.code.line.get": {
    "prefix": "fdm.nodes.code.line.get",
    "body": [
      "tool.fdm.nodes.code.line.get(${1:id})"
    ],
    "description": "Gets a CodeLine node by E_ or N_ ID."
  },
  "fdm.nodes.code.line.list": {
    "prefix": "fdm.nodes.code.line.list",
    "body": [
      "tool.fdm.nodes.code.line.list()"
    ],
    "description": "Lists all active CodeLine nodes."
  },
  "fdm.nodes.code.line.mutate": {
    "prefix": "fdm.nodes.code.line.mutate",
    "body": [
      "tool.fdm.nodes.code.line.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeLine. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n"
  },
  "fdm.nodes.code.line.upsert": {
    "prefix": "fdm.nodes.code.line.upsert",
    "body": [
      "tool.fdm.nodes.code.line.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeLine entity exists with the given human handle."
  },
  "fdm.nodes.code.repo.create": {
    "prefix": "fdm.nodes.code.repo.create",
    "body": [
      "tool.fdm.nodes.code.repo.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CodeRepo. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Human-friendly name of the repository (Required)\\n- codepath: Physical path to the repository on the host filesystem (Required)\\n- codevcs: Version control system type (e.g., git, svn)\\n- verbranch: The active or default branch name\\n- vercommithash: The current HEAD commit identifier\\n- vercommitts: The timestamp of the current HEAD commit\\n- verishead: Indicates if this node represents the current head of the repository\\n- verversion: Monotonic version number\\n- verfolio: Folio reference for external tracking"
  },
  "fdm.nodes.code.repo.find": {
    "prefix": "fdm.nodes.code.repo.find",
    "body": [
      "tool.fdm.nodes.code.repo.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CodeRepo nodes by exact field match."
  },
  "fdm.nodes.code.repo.get": {
    "prefix": "fdm.nodes.code.repo.get",
    "body": [
      "tool.fdm.nodes.code.repo.get(${1:id})"
    ],
    "description": "Gets a CodeRepo node by E_ or N_ ID."
  },
  "fdm.nodes.code.repo.list": {
    "prefix": "fdm.nodes.code.repo.list",
    "body": [
      "tool.fdm.nodes.code.repo.list()"
    ],
    "description": "Lists all active CodeRepo nodes."
  },
  "fdm.nodes.code.repo.mutate": {
    "prefix": "fdm.nodes.code.repo.mutate",
    "body": [
      "tool.fdm.nodes.code.repo.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CodeRepo. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Human-friendly name of the repository (Required)\\n- codepath: Physical path to the repository on the host filesystem (Required)\\n- codevcs: Version control system type (e.g., git, svn)\\n- verbranch: The active or default branch name\\n- vercommithash: The current HEAD commit identifier\\n- vercommitts: The timestamp of the current HEAD commit\\n- verishead: Indicates if this node represents the current head of the repository\\n- verversion: Monotonic version number\\n- verfolio: Folio reference for external tracking"
  },
  "fdm.nodes.code.repo.upsert": {
    "prefix": "fdm.nodes.code.repo.upsert",
    "body": [
      "tool.fdm.nodes.code.repo.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CodeRepo entity exists with the given human handle."
  },
  "fdm.nodes.core.agent.create": {
    "prefix": "fdm.nodes.core.agent.create",
    "body": [
      "tool.fdm.nodes.core.agent.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CoreAgent. Expects a map of fields.\\nValid keys:\\n- coredid: Decentralized Identifier (Required)\\n- fdmdisplayname: Human readable name (Required)\\n- coreulid: Unique lexicographical ID\\n- corepublickey: Public Key\\n- corecreatedat: Creation timestamp (ISO8601)\\n- corelastseen: Last active timestamp\\n- coreclass: Agent class\\n- coreagentstatus: Administrative status\\n- coremodel: Model identifier\\n- corerole: System role\\n- coreseq: Sequence number\\n- corerepbase: Reputation base\\n- corescript: Snapshot of script source code\\n- corescriptid: Link to origin script capsule\\n- corechartertext: Snapshot of charter text\\n- corecharterid: Link to origin charter capsule\\n- corescriptsig: Signature over (Script + Charter)"
  },
  "fdm.nodes.core.agent.find": {
    "prefix": "fdm.nodes.core.agent.find",
    "body": [
      "tool.fdm.nodes.core.agent.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CoreAgent nodes by exact field match."
  },
  "fdm.nodes.core.agent.get": {
    "prefix": "fdm.nodes.core.agent.get",
    "body": [
      "tool.fdm.nodes.core.agent.get(${1:id})"
    ],
    "description": "Gets a CoreAgent node by E_ or N_ ID."
  },
  "fdm.nodes.core.agent.list": {
    "prefix": "fdm.nodes.core.agent.list",
    "body": [
      "tool.fdm.nodes.core.agent.list()"
    ],
    "description": "Lists all active CoreAgent nodes."
  },
  "fdm.nodes.core.agent.mutate": {
    "prefix": "fdm.nodes.core.agent.mutate",
    "body": [
      "tool.fdm.nodes.core.agent.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CoreAgent. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- coredid: Decentralized Identifier (Required)\\n- fdmdisplayname: Human readable name (Required)\\n- coreulid: Unique lexicographical ID\\n- corepublickey: Public Key\\n- corecreatedat: Creation timestamp (ISO8601)\\n- corelastseen: Last active timestamp\\n- coreclass: Agent class\\n- coreagentstatus: Administrative status\\n- coremodel: Model identifier\\n- corerole: System role\\n- coreseq: Sequence number\\n- corerepbase: Reputation base\\n- corescript: Snapshot of script source code\\n- corescriptid: Link to origin script capsule\\n- corechartertext: Snapshot of charter text\\n- corecharterid: Link to origin charter capsule\\n- corescriptsig: Signature over (Script + Charter)"
  },
  "fdm.nodes.core.agent.upsert": {
    "prefix": "fdm.nodes.core.agent.upsert",
    "body": [
      "tool.fdm.nodes.core.agent.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CoreAgent entity exists with the given human handle."
  },
  "fdm.nodes.core.noetic_capsule.create": {
    "prefix": "fdm.nodes.core.noetic_capsule.create",
    "body": [
      "tool.fdm.nodes.core.noetic_capsule.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new CoreNoeticCapsule. Expects a map of fields.\\nValid keys:\\n- coretargetagent: Target Agent EntityID (Required)\\n- coredata: Capsule content (instructions/data) (Required)"
  },
  "fdm.nodes.core.noetic_capsule.find": {
    "prefix": "fdm.nodes.core.noetic_capsule.find",
    "body": [
      "tool.fdm.nodes.core.noetic_capsule.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds CoreNoeticCapsule nodes by exact field match."
  },
  "fdm.nodes.core.noetic_capsule.get": {
    "prefix": "fdm.nodes.core.noetic_capsule.get",
    "body": [
      "tool.fdm.nodes.core.noetic_capsule.get(${1:id})"
    ],
    "description": "Gets a CoreNoeticCapsule node by E_ or N_ ID."
  },
  "fdm.nodes.core.noetic_capsule.list": {
    "prefix": "fdm.nodes.core.noetic_capsule.list",
    "body": [
      "tool.fdm.nodes.core.noetic_capsule.list()"
    ],
    "description": "Lists all active CoreNoeticCapsule nodes."
  },
  "fdm.nodes.core.noetic_capsule.mutate": {
    "prefix": "fdm.nodes.core.noetic_capsule.mutate",
    "body": [
      "tool.fdm.nodes.core.noetic_capsule.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for CoreNoeticCapsule. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- coretargetagent: Target Agent EntityID (Required)\\n- coredata: Capsule content (instructions/data) (Required)"
  },
  "fdm.nodes.core.noetic_capsule.upsert": {
    "prefix": "fdm.nodes.core.noetic_capsule.upsert",
    "body": [
      "tool.fdm.nodes.core.noetic_capsule.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a CoreNoeticCapsule entity exists with the given human handle."
  },
  "fdm.nodes.desc.summary.create": {
    "prefix": "fdm.nodes.desc.summary.create",
    "body": [
      "tool.fdm.nodes.desc.summary.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DescSummary. Expects a map of fields.\\nValid keys:\\n- desctext: The summary text containing citations (Required)\\n- desccitationfmt: The required citation format used in the text (Required)\\n- descanchorref: The CodeFile or CodeChunk snapshot being described (Required)\\n- descmodel: The model used to generate the summary\\n- descpromptver: Version of the prompt used\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.desc.summary.find": {
    "prefix": "fdm.nodes.desc.summary.find",
    "body": [
      "tool.fdm.nodes.desc.summary.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DescSummary nodes by exact field match."
  },
  "fdm.nodes.desc.summary.get": {
    "prefix": "fdm.nodes.desc.summary.get",
    "body": [
      "tool.fdm.nodes.desc.summary.get(${1:id})"
    ],
    "description": "Gets a DescSummary node by E_ or N_ ID."
  },
  "fdm.nodes.desc.summary.list": {
    "prefix": "fdm.nodes.desc.summary.list",
    "body": [
      "tool.fdm.nodes.desc.summary.list()"
    ],
    "description": "Lists all active DescSummary nodes."
  },
  "fdm.nodes.desc.summary.mutate": {
    "prefix": "fdm.nodes.desc.summary.mutate",
    "body": [
      "tool.fdm.nodes.desc.summary.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DescSummary. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- desctext: The summary text containing citations (Required)\\n- desccitationfmt: The required citation format used in the text (Required)\\n- descanchorref: The CodeFile or CodeChunk snapshot being described (Required)\\n- descmodel: The model used to generate the summary\\n- descpromptver: Version of the prompt used\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.desc.summary.upsert": {
    "prefix": "fdm.nodes.desc.summary.upsert",
    "body": [
      "tool.fdm.nodes.desc.summary.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DescSummary entity exists with the given human handle."
  },
  "fdm.nodes.doc.block.create": {
    "prefix": "fdm.nodes.doc.block.create",
    "body": [
      "tool.fdm.nodes.doc.block.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocBlock. Expects a map of fields.\\nValid keys:\\n- docroot: Parent Document (Required)\\n- docsection: Parent Section (Required)\\n- docorder: Sort key (Required)\\n- dockind: Presentation hint (Required)\\n- docauthor: Author Agent EntityID\\n- doctextpayload: Text content\\n- docpayloadref: Link to external content\\n- docepochcreated: Creation timestamp"
  },
  "fdm.nodes.doc.block.find": {
    "prefix": "fdm.nodes.doc.block.find",
    "body": [
      "tool.fdm.nodes.doc.block.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocBlock nodes by exact field match."
  },
  "fdm.nodes.doc.block.get": {
    "prefix": "fdm.nodes.doc.block.get",
    "body": [
      "tool.fdm.nodes.doc.block.get(${1:id})"
    ],
    "description": "Gets a DocBlock node by E_ or N_ ID."
  },
  "fdm.nodes.doc.block.list": {
    "prefix": "fdm.nodes.doc.block.list",
    "body": [
      "tool.fdm.nodes.doc.block.list()"
    ],
    "description": "Lists all active DocBlock nodes."
  },
  "fdm.nodes.doc.block.mutate": {
    "prefix": "fdm.nodes.doc.block.mutate",
    "body": [
      "tool.fdm.nodes.doc.block.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocBlock. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- docroot: Parent Document (Required)\\n- docsection: Parent Section (Required)\\n- docorder: Sort key (Required)\\n- dockind: Presentation hint (Required)\\n- docauthor: Author Agent EntityID\\n- doctextpayload: Text content\\n- docpayloadref: Link to external content\\n- docepochcreated: Creation timestamp"
  },
  "fdm.nodes.doc.block.upsert": {
    "prefix": "fdm.nodes.doc.block.upsert",
    "body": [
      "tool.fdm.nodes.doc.block.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocBlock entity exists with the given human handle."
  },
  "fdm.nodes.doc.change_set.create": {
    "prefix": "fdm.nodes.doc.change_set.create",
    "body": [
      "tool.fdm.nodes.doc.change_set.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocChangeSet. Expects a map of fields.\\nValid keys:\\n- docroot: Parent Document (Required)\\n- docactor: Who made the change (Agent EntityID) (Required)\\n- docsummary: Description of change (Required)\\n- docepoch: Timestamp (Required)\\n- docaddedblocks: Added blocks\\n- docmodifiedblocks: Modified blocks\\n- doctombstonedblocks: Deleted blocks"
  },
  "fdm.nodes.doc.change_set.find": {
    "prefix": "fdm.nodes.doc.change_set.find",
    "body": [
      "tool.fdm.nodes.doc.change_set.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocChangeSet nodes by exact field match."
  },
  "fdm.nodes.doc.change_set.get": {
    "prefix": "fdm.nodes.doc.change_set.get",
    "body": [
      "tool.fdm.nodes.doc.change_set.get(${1:id})"
    ],
    "description": "Gets a DocChangeSet node by E_ or N_ ID."
  },
  "fdm.nodes.doc.change_set.list": {
    "prefix": "fdm.nodes.doc.change_set.list",
    "body": [
      "tool.fdm.nodes.doc.change_set.list()"
    ],
    "description": "Lists all active DocChangeSet nodes."
  },
  "fdm.nodes.doc.change_set.mutate": {
    "prefix": "fdm.nodes.doc.change_set.mutate",
    "body": [
      "tool.fdm.nodes.doc.change_set.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocChangeSet. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- docroot: Parent Document (Required)\\n- docactor: Who made the change (Agent EntityID) (Required)\\n- docsummary: Description of change (Required)\\n- docepoch: Timestamp (Required)\\n- docaddedblocks: Added blocks\\n- docmodifiedblocks: Modified blocks\\n- doctombstonedblocks: Deleted blocks"
  },
  "fdm.nodes.doc.change_set.upsert": {
    "prefix": "fdm.nodes.doc.change_set.upsert",
    "body": [
      "tool.fdm.nodes.doc.change_set.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocChangeSet entity exists with the given human handle."
  },
  "fdm.nodes.doc.event.create": {
    "prefix": "fdm.nodes.doc.event.create",
    "body": [
      "tool.fdm.nodes.doc.event.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocEvent. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Event name (Required)\\n- docpayload: Event payload description\\n- docsourcechunk: Source text chunk (Required)\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.event.find": {
    "prefix": "fdm.nodes.doc.event.find",
    "body": [
      "tool.fdm.nodes.doc.event.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocEvent nodes by exact field match."
  },
  "fdm.nodes.doc.event.get": {
    "prefix": "fdm.nodes.doc.event.get",
    "body": [
      "tool.fdm.nodes.doc.event.get(${1:id})"
    ],
    "description": "Gets a DocEvent node by E_ or N_ ID."
  },
  "fdm.nodes.doc.event.list": {
    "prefix": "fdm.nodes.doc.event.list",
    "body": [
      "tool.fdm.nodes.doc.event.list()"
    ],
    "description": "Lists all active DocEvent nodes."
  },
  "fdm.nodes.doc.event.mutate": {
    "prefix": "fdm.nodes.doc.event.mutate",
    "body": [
      "tool.fdm.nodes.doc.event.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocEvent. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Event name (Required)\\n- docpayload: Event payload description\\n- docsourcechunk: Source text chunk (Required)\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.event.upsert": {
    "prefix": "fdm.nodes.doc.event.upsert",
    "body": [
      "tool.fdm.nodes.doc.event.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocEvent entity exists with the given human handle."
  },
  "fdm.nodes.doc.fact.create": {
    "prefix": "fdm.nodes.doc.fact.create",
    "body": [
      "tool.fdm.nodes.doc.fact.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocFact. Expects a map of fields.\\nValid keys:\\n- docsubject: Subject node (Actor/Component) (Required)\\n- docpredicate: Predicate verb (e.g. 'doc:depends_on') (Required)\\n- docobject: Object node (Target)\\n- docobjatom: Object literal (if not a node)\\n- docmodality: Strength (MUST, SHOULD, MAY)\\n- doccondition: Conditional constraint\\n- docorigin: Origin (manual, llm)\\n- docsource: Source reference (File:Line)"
  },
  "fdm.nodes.doc.fact.find": {
    "prefix": "fdm.nodes.doc.fact.find",
    "body": [
      "tool.fdm.nodes.doc.fact.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocFact nodes by exact field match."
  },
  "fdm.nodes.doc.fact.get": {
    "prefix": "fdm.nodes.doc.fact.get",
    "body": [
      "tool.fdm.nodes.doc.fact.get(${1:id})"
    ],
    "description": "Gets a DocFact node by E_ or N_ ID."
  },
  "fdm.nodes.doc.fact.list": {
    "prefix": "fdm.nodes.doc.fact.list",
    "body": [
      "tool.fdm.nodes.doc.fact.list()"
    ],
    "description": "Lists all active DocFact nodes."
  },
  "fdm.nodes.doc.fact.mutate": {
    "prefix": "fdm.nodes.doc.fact.mutate",
    "body": [
      "tool.fdm.nodes.doc.fact.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocFact. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- docsubject: Subject node (Actor/Component) (Required)\\n- docpredicate: Predicate verb (e.g. 'doc:depends_on') (Required)\\n- docobject: Object node (Target)\\n- docobjatom: Object literal (if not a node)\\n- docmodality: Strength (MUST, SHOULD, MAY)\\n- doccondition: Conditional constraint\\n- docorigin: Origin (manual, llm)\\n- docsource: Source reference (File:Line)"
  },
  "fdm.nodes.doc.fact.upsert": {
    "prefix": "fdm.nodes.doc.fact.upsert",
    "body": [
      "tool.fdm.nodes.doc.fact.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocFact entity exists with the given human handle."
  },
  "fdm.nodes.doc.glossary.create": {
    "prefix": "fdm.nodes.doc.glossary.create",
    "body": [
      "tool.fdm.nodes.doc.glossary.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocGlossary. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: The term being defined (Required)\\n- docdefinition: The definition text (Required)\\n- docsynonyms: Alternative terms\\n- docsourcechunk: Source text chunk (Required)\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.glossary.find": {
    "prefix": "fdm.nodes.doc.glossary.find",
    "body": [
      "tool.fdm.nodes.doc.glossary.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocGlossary nodes by exact field match."
  },
  "fdm.nodes.doc.glossary.get": {
    "prefix": "fdm.nodes.doc.glossary.get",
    "body": [
      "tool.fdm.nodes.doc.glossary.get(${1:id})"
    ],
    "description": "Gets a DocGlossary node by E_ or N_ ID."
  },
  "fdm.nodes.doc.glossary.list": {
    "prefix": "fdm.nodes.doc.glossary.list",
    "body": [
      "tool.fdm.nodes.doc.glossary.list()"
    ],
    "description": "Lists all active DocGlossary nodes."
  },
  "fdm.nodes.doc.glossary.mutate": {
    "prefix": "fdm.nodes.doc.glossary.mutate",
    "body": [
      "tool.fdm.nodes.doc.glossary.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocGlossary. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: The term being defined (Required)\\n- docdefinition: The definition text (Required)\\n- docsynonyms: Alternative terms\\n- docsourcechunk: Source text chunk (Required)\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.glossary.upsert": {
    "prefix": "fdm.nodes.doc.glossary.upsert",
    "body": [
      "tool.fdm.nodes.doc.glossary.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocGlossary entity exists with the given human handle."
  },
  "fdm.nodes.doc.lifecycle.create": {
    "prefix": "fdm.nodes.doc.lifecycle.create",
    "body": [
      "tool.fdm.nodes.doc.lifecycle.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocLifecycle. Expects a map of fields.\\nValid keys:\\n- docentity: The entity this lifecycle applies to (Required)\\n- docstates: List of identified states\\n- docsourcechunk: Source text chunk\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.lifecycle.find": {
    "prefix": "fdm.nodes.doc.lifecycle.find",
    "body": [
      "tool.fdm.nodes.doc.lifecycle.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocLifecycle nodes by exact field match."
  },
  "fdm.nodes.doc.lifecycle.get": {
    "prefix": "fdm.nodes.doc.lifecycle.get",
    "body": [
      "tool.fdm.nodes.doc.lifecycle.get(${1:id})"
    ],
    "description": "Gets a DocLifecycle node by E_ or N_ ID."
  },
  "fdm.nodes.doc.lifecycle.list": {
    "prefix": "fdm.nodes.doc.lifecycle.list",
    "body": [
      "tool.fdm.nodes.doc.lifecycle.list()"
    ],
    "description": "Lists all active DocLifecycle nodes."
  },
  "fdm.nodes.doc.lifecycle.mutate": {
    "prefix": "fdm.nodes.doc.lifecycle.mutate",
    "body": [
      "tool.fdm.nodes.doc.lifecycle.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocLifecycle. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- docentity: The entity this lifecycle applies to (Required)\\n- docstates: List of identified states\\n- docsourcechunk: Source text chunk\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.lifecycle.upsert": {
    "prefix": "fdm.nodes.doc.lifecycle.upsert",
    "body": [
      "tool.fdm.nodes.doc.lifecycle.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocLifecycle entity exists with the given human handle."
  },
  "fdm.nodes.doc.policy.create": {
    "prefix": "fdm.nodes.doc.policy.create",
    "body": [
      "tool.fdm.nodes.doc.policy.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocPolicy. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: The rule text or expression (Required)\\n- docsourcechunk: Source text chunk (Required)\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.policy.find": {
    "prefix": "fdm.nodes.doc.policy.find",
    "body": [
      "tool.fdm.nodes.doc.policy.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocPolicy nodes by exact field match."
  },
  "fdm.nodes.doc.policy.get": {
    "prefix": "fdm.nodes.doc.policy.get",
    "body": [
      "tool.fdm.nodes.doc.policy.get(${1:id})"
    ],
    "description": "Gets a DocPolicy node by E_ or N_ ID."
  },
  "fdm.nodes.doc.policy.list": {
    "prefix": "fdm.nodes.doc.policy.list",
    "body": [
      "tool.fdm.nodes.doc.policy.list()"
    ],
    "description": "Lists all active DocPolicy nodes."
  },
  "fdm.nodes.doc.policy.mutate": {
    "prefix": "fdm.nodes.doc.policy.mutate",
    "body": [
      "tool.fdm.nodes.doc.policy.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocPolicy. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: The rule text or expression (Required)\\n- docsourcechunk: Source text chunk (Required)\\n- docconfidence: Extraction confidence (0-1)\\n- docauthority: Source authority/provenance\\n- docquote: Verbatim quote"
  },
  "fdm.nodes.doc.policy.upsert": {
    "prefix": "fdm.nodes.doc.policy.upsert",
    "body": [
      "tool.fdm.nodes.doc.policy.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocPolicy entity exists with the given human handle."
  },
  "fdm.nodes.doc.root.create": {
    "prefix": "fdm.nodes.doc.root.create",
    "body": [
      "tool.fdm.nodes.doc.root.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocRoot. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Document title (Required)\\n- dockind: Document kind (Required)\\n- docstatus: Lifecycle status (Required)\\n- docowner: Owner Agent/Team EntityID\\n- docsourcefile: Optional source link\\n- doccreatedepoch: Created timestamp\\n- docupdatedepoch: Updated timestamp"
  },
  "fdm.nodes.doc.root.find": {
    "prefix": "fdm.nodes.doc.root.find",
    "body": [
      "tool.fdm.nodes.doc.root.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocRoot nodes by exact field match."
  },
  "fdm.nodes.doc.root.get": {
    "prefix": "fdm.nodes.doc.root.get",
    "body": [
      "tool.fdm.nodes.doc.root.get(${1:id})"
    ],
    "description": "Gets a DocRoot node by E_ or N_ ID."
  },
  "fdm.nodes.doc.root.list": {
    "prefix": "fdm.nodes.doc.root.list",
    "body": [
      "tool.fdm.nodes.doc.root.list()"
    ],
    "description": "Lists all active DocRoot nodes."
  },
  "fdm.nodes.doc.root.mutate": {
    "prefix": "fdm.nodes.doc.root.mutate",
    "body": [
      "tool.fdm.nodes.doc.root.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocRoot. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Document title (Required)\\n- dockind: Document kind (Required)\\n- docstatus: Lifecycle status (Required)\\n- docowner: Owner Agent/Team EntityID\\n- docsourcefile: Optional source link\\n- doccreatedepoch: Created timestamp\\n- docupdatedepoch: Updated timestamp"
  },
  "fdm.nodes.doc.root.upsert": {
    "prefix": "fdm.nodes.doc.root.upsert",
    "body": [
      "tool.fdm.nodes.doc.root.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocRoot entity exists with the given human handle."
  },
  "fdm.nodes.doc.section.create": {
    "prefix": "fdm.nodes.doc.section.create",
    "body": [
      "tool.fdm.nodes.doc.section.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocSection. Expects a map of fields.\\nValid keys:\\n- docroot: Parent Document (Required)\\n- docparentsection: Parent Section\\n- doclabel: Header label (Required)\\n- docorder: Sort key\\n- doctext: Raw section text\\n- docsourcechunk: Source text chunk\\n- docconfidence: Extraction confidence\\n- docauthority: Source authority"
  },
  "fdm.nodes.doc.section.find": {
    "prefix": "fdm.nodes.doc.section.find",
    "body": [
      "tool.fdm.nodes.doc.section.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocSection nodes by exact field match."
  },
  "fdm.nodes.doc.section.get": {
    "prefix": "fdm.nodes.doc.section.get",
    "body": [
      "tool.fdm.nodes.doc.section.get(${1:id})"
    ],
    "description": "Gets a DocSection node by E_ or N_ ID."
  },
  "fdm.nodes.doc.section.list": {
    "prefix": "fdm.nodes.doc.section.list",
    "body": [
      "tool.fdm.nodes.doc.section.list()"
    ],
    "description": "Lists all active DocSection nodes."
  },
  "fdm.nodes.doc.section.mutate": {
    "prefix": "fdm.nodes.doc.section.mutate",
    "body": [
      "tool.fdm.nodes.doc.section.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocSection. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- docroot: Parent Document (Required)\\n- docparentsection: Parent Section\\n- doclabel: Header label (Required)\\n- docorder: Sort key\\n- doctext: Raw section text\\n- docsourcechunk: Source text chunk\\n- docconfidence: Extraction confidence\\n- docauthority: Source authority"
  },
  "fdm.nodes.doc.section.upsert": {
    "prefix": "fdm.nodes.doc.section.upsert",
    "body": [
      "tool.fdm.nodes.doc.section.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocSection entity exists with the given human handle."
  },
  "fdm.nodes.doc.view.create": {
    "prefix": "fdm.nodes.doc.view.create",
    "body": [
      "tool.fdm.nodes.doc.view.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new DocView. Expects a map of fields.\\nValid keys:\\n- docroot: Parent Document (Required)\\n- dockind: Format (Required)\\n- docepochgenerated: Generation timestamp\\n- docsourcerevision: ChangeSet ID\\n- doctarget: Target URI/Path"
  },
  "fdm.nodes.doc.view.find": {
    "prefix": "fdm.nodes.doc.view.find",
    "body": [
      "tool.fdm.nodes.doc.view.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds DocView nodes by exact field match."
  },
  "fdm.nodes.doc.view.get": {
    "prefix": "fdm.nodes.doc.view.get",
    "body": [
      "tool.fdm.nodes.doc.view.get(${1:id})"
    ],
    "description": "Gets a DocView node by E_ or N_ ID."
  },
  "fdm.nodes.doc.view.list": {
    "prefix": "fdm.nodes.doc.view.list",
    "body": [
      "tool.fdm.nodes.doc.view.list()"
    ],
    "description": "Lists all active DocView nodes."
  },
  "fdm.nodes.doc.view.mutate": {
    "prefix": "fdm.nodes.doc.view.mutate",
    "body": [
      "tool.fdm.nodes.doc.view.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for DocView. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- docroot: Parent Document (Required)\\n- dockind: Format (Required)\\n- docepochgenerated: Generation timestamp\\n- docsourcerevision: ChangeSet ID\\n- doctarget: Target URI/Path"
  },
  "fdm.nodes.doc.view.upsert": {
    "prefix": "fdm.nodes.doc.view.upsert",
    "body": [
      "tool.fdm.nodes.doc.view.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a DocView entity exists with the given human handle."
  },
  "fdm.nodes.fdm.account.create": {
    "prefix": "fdm.nodes.fdm.account.create",
    "body": [
      "tool.fdm.nodes.fdm.account.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FdmAccount. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Account Name (Required)\\n- fdmkind: Account Kind (Required)\\n- fdmprovider: Provider (Required)\\n- fdmapikey: API Key\\n- fdmorgid: Organization ID\\n- fdmprojectid: Project ID"
  },
  "fdm.nodes.fdm.account.find": {
    "prefix": "fdm.nodes.fdm.account.find",
    "body": [
      "tool.fdm.nodes.fdm.account.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FdmAccount nodes by exact field match."
  },
  "fdm.nodes.fdm.account.get": {
    "prefix": "fdm.nodes.fdm.account.get",
    "body": [
      "tool.fdm.nodes.fdm.account.get(${1:id})"
    ],
    "description": "Gets a FdmAccount node by E_ or N_ ID."
  },
  "fdm.nodes.fdm.account.list": {
    "prefix": "fdm.nodes.fdm.account.list",
    "body": [
      "tool.fdm.nodes.fdm.account.list()"
    ],
    "description": "Lists all active FdmAccount nodes."
  },
  "fdm.nodes.fdm.account.mutate": {
    "prefix": "fdm.nodes.fdm.account.mutate",
    "body": [
      "tool.fdm.nodes.fdm.account.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FdmAccount. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Account Name (Required)\\n- fdmkind: Account Kind (Required)\\n- fdmprovider: Provider (Required)\\n- fdmapikey: API Key\\n- fdmorgid: Organization ID\\n- fdmprojectid: Project ID"
  },
  "fdm.nodes.fdm.account.upsert": {
    "prefix": "fdm.nodes.fdm.account.upsert",
    "body": [
      "tool.fdm.nodes.fdm.account.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FdmAccount entity exists with the given human handle."
  },
  "fdm.nodes.fdm.agent_model.create": {
    "prefix": "fdm.nodes.fdm.agent_model.create",
    "body": [
      "tool.fdm.nodes.fdm.agent_model.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FdmAgentModel. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Model Name (Required)\\n- fdmprovider: Provider (Required)\\n- fdmmodel: Model ID (Required)\\n- fdmaccountname: Linked Account Name (Required)\\n- fdmmaxturns: Max Turns\\n- fdmconfigmap: Configuration Map"
  },
  "fdm.nodes.fdm.agent_model.find": {
    "prefix": "fdm.nodes.fdm.agent_model.find",
    "body": [
      "tool.fdm.nodes.fdm.agent_model.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FdmAgentModel nodes by exact field match."
  },
  "fdm.nodes.fdm.agent_model.get": {
    "prefix": "fdm.nodes.fdm.agent_model.get",
    "body": [
      "tool.fdm.nodes.fdm.agent_model.get(${1:id})"
    ],
    "description": "Gets a FdmAgentModel node by E_ or N_ ID."
  },
  "fdm.nodes.fdm.agent_model.list": {
    "prefix": "fdm.nodes.fdm.agent_model.list",
    "body": [
      "tool.fdm.nodes.fdm.agent_model.list()"
    ],
    "description": "Lists all active FdmAgentModel nodes."
  },
  "fdm.nodes.fdm.agent_model.mutate": {
    "prefix": "fdm.nodes.fdm.agent_model.mutate",
    "body": [
      "tool.fdm.nodes.fdm.agent_model.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FdmAgentModel. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Model Name (Required)\\n- fdmprovider: Provider (Required)\\n- fdmmodel: Model ID (Required)\\n- fdmaccountname: Linked Account Name (Required)\\n- fdmmaxturns: Max Turns\\n- fdmconfigmap: Configuration Map"
  },
  "fdm.nodes.fdm.agent_model.upsert": {
    "prefix": "fdm.nodes.fdm.agent_model.upsert",
    "body": [
      "tool.fdm.nodes.fdm.agent_model.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FdmAgentModel entity exists with the given human handle."
  },
  "fdm.nodes.fdm.capsule.create": {
    "prefix": "fdm.nodes.fdm.capsule.create",
    "body": [
      "tool.fdm.nodes.fdm.capsule.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FdmCapsule. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Capsule Name (Required)\\n- fdmcontent: Content (Required)\\n- fdmversion: Version (Required)\\n- fdmdescription: Description (Required)\\n- fdmmime: MIME Type (Required)"
  },
  "fdm.nodes.fdm.capsule.find": {
    "prefix": "fdm.nodes.fdm.capsule.find",
    "body": [
      "tool.fdm.nodes.fdm.capsule.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FdmCapsule nodes by exact field match."
  },
  "fdm.nodes.fdm.capsule.get": {
    "prefix": "fdm.nodes.fdm.capsule.get",
    "body": [
      "tool.fdm.nodes.fdm.capsule.get(${1:id})"
    ],
    "description": "Gets a FdmCapsule node by E_ or N_ ID."
  },
  "fdm.nodes.fdm.capsule.list": {
    "prefix": "fdm.nodes.fdm.capsule.list",
    "body": [
      "tool.fdm.nodes.fdm.capsule.list()"
    ],
    "description": "Lists all active FdmCapsule nodes."
  },
  "fdm.nodes.fdm.capsule.mutate": {
    "prefix": "fdm.nodes.fdm.capsule.mutate",
    "body": [
      "tool.fdm.nodes.fdm.capsule.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FdmCapsule. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Capsule Name (Required)\\n- fdmcontent: Content (Required)\\n- fdmversion: Version (Required)\\n- fdmdescription: Description (Required)\\n- fdmmime: MIME Type (Required)"
  },
  "fdm.nodes.fdm.capsule.upsert": {
    "prefix": "fdm.nodes.fdm.capsule.upsert",
    "body": [
      "tool.fdm.nodes.fdm.capsule.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FdmCapsule entity exists with the given human handle."
  },
  "fdm.nodes.file.version.create": {
    "prefix": "fdm.nodes.file.version.create",
    "body": [
      "tool.fdm.nodes.file.version.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FileVersion. Expects a map of fields.\\nValid keys:\\n- filepath: Relative repository path (Required)\\n- filesha256: Content SHA256\\n- filetimestamp: Version timestamp\\n- fileparentversion: Parent version node"
  },
  "fdm.nodes.file.version.find": {
    "prefix": "fdm.nodes.file.version.find",
    "body": [
      "tool.fdm.nodes.file.version.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FileVersion nodes by exact field match."
  },
  "fdm.nodes.file.version.get": {
    "prefix": "fdm.nodes.file.version.get",
    "body": [
      "tool.fdm.nodes.file.version.get(${1:id})"
    ],
    "description": "Gets a FileVersion node by E_ or N_ ID."
  },
  "fdm.nodes.file.version.list": {
    "prefix": "fdm.nodes.file.version.list",
    "body": [
      "tool.fdm.nodes.file.version.list()"
    ],
    "description": "Lists all active FileVersion nodes."
  },
  "fdm.nodes.file.version.mutate": {
    "prefix": "fdm.nodes.file.version.mutate",
    "body": [
      "tool.fdm.nodes.file.version.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FileVersion. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- filepath: Relative repository path (Required)\\n- filesha256: Content SHA256\\n- filetimestamp: Version timestamp\\n- fileparentversion: Parent version node"
  },
  "fdm.nodes.file.version.upsert": {
    "prefix": "fdm.nodes.file.version.upsert",
    "body": [
      "tool.fdm.nodes.file.version.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FileVersion entity exists with the given human handle."
  },
  "fdm.nodes.forum.feedback.create": {
    "prefix": "fdm.nodes.forum.feedback.create",
    "body": [
      "tool.fdm.nodes.forum.feedback.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumFeedback. Expects a map of fields.\\nValid keys:\\n- forummsg: Target message snapshot (Required)\\n- forumrater: Rater EntityID (Required)\\n- forumrating: Rating value (Required)\\n- forumts: Timestamp (Required)\\n- forumreason: Reason text"
  },
  "fdm.nodes.forum.feedback.find": {
    "prefix": "fdm.nodes.forum.feedback.find",
    "body": [
      "tool.fdm.nodes.forum.feedback.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumFeedback nodes by exact field match."
  },
  "fdm.nodes.forum.feedback.get": {
    "prefix": "fdm.nodes.forum.feedback.get",
    "body": [
      "tool.fdm.nodes.forum.feedback.get(${1:id})"
    ],
    "description": "Gets a ForumFeedback node by E_ or N_ ID."
  },
  "fdm.nodes.forum.feedback.list": {
    "prefix": "fdm.nodes.forum.feedback.list",
    "body": [
      "tool.fdm.nodes.forum.feedback.list()"
    ],
    "description": "Lists all active ForumFeedback nodes."
  },
  "fdm.nodes.forum.feedback.mutate": {
    "prefix": "fdm.nodes.forum.feedback.mutate",
    "body": [
      "tool.fdm.nodes.forum.feedback.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumFeedback. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- forummsg: Target message snapshot (Required)\\n- forumrater: Rater EntityID (Required)\\n- forumrating: Rating value (Required)\\n- forumts: Timestamp (Required)\\n- forumreason: Reason text"
  },
  "fdm.nodes.forum.feedback.upsert": {
    "prefix": "fdm.nodes.forum.feedback.upsert",
    "body": [
      "tool.fdm.nodes.forum.feedback.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumFeedback entity exists with the given human handle."
  },
  "fdm.nodes.forum.head.create": {
    "prefix": "fdm.nodes.forum.head.create",
    "body": [
      "tool.fdm.nodes.forum.head.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumHead. Expects a map of fields.\\nValid keys:\\n- forumthreadid: Thread ID (Required)\\n- forumepoch: Epoch number (Required)\\n- forumstate: State (active/sealed) (Required)\\n- forumlastauth: Last authoritative message\\n- forumdigest: Content digest (Required)\\n- forumcomputedat: Computation timestamp (Required)\\n- forumcomputedby: Signer EntityID (Required)\\n- forumsignature: Digital signature (Required)"
  },
  "fdm.nodes.forum.head.find": {
    "prefix": "fdm.nodes.forum.head.find",
    "body": [
      "tool.fdm.nodes.forum.head.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumHead nodes by exact field match."
  },
  "fdm.nodes.forum.head.get": {
    "prefix": "fdm.nodes.forum.head.get",
    "body": [
      "tool.fdm.nodes.forum.head.get(${1:id})"
    ],
    "description": "Gets a ForumHead node by E_ or N_ ID."
  },
  "fdm.nodes.forum.head.list": {
    "prefix": "fdm.nodes.forum.head.list",
    "body": [
      "tool.fdm.nodes.forum.head.list()"
    ],
    "description": "Lists all active ForumHead nodes."
  },
  "fdm.nodes.forum.head.mutate": {
    "prefix": "fdm.nodes.forum.head.mutate",
    "body": [
      "tool.fdm.nodes.forum.head.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumHead. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- forumthreadid: Thread ID (Required)\\n- forumepoch: Epoch number (Required)\\n- forumstate: State (active/sealed) (Required)\\n- forumlastauth: Last authoritative message\\n- forumdigest: Content digest (Required)\\n- forumcomputedat: Computation timestamp (Required)\\n- forumcomputedby: Signer EntityID (Required)\\n- forumsignature: Digital signature (Required)"
  },
  "fdm.nodes.forum.head.upsert": {
    "prefix": "fdm.nodes.forum.head.upsert",
    "body": [
      "tool.fdm.nodes.forum.head.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumHead entity exists with the given human handle."
  },
  "fdm.nodes.forum.msg.create": {
    "prefix": "fdm.nodes.forum.msg.create",
    "body": [
      "tool.fdm.nodes.forum.msg.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumMsg. Expects a map of fields.\\nValid keys:\\n- forumrootid: Root ID\\n- forumthreadid: Thread ID (Required)\\n- forumforumid: Forum ID\\n- forumparentid: Parent Message ID\\n- forumauthor: Author EntityID (Required)\\n- forumbody: Message content (Required)\\n- forumtimestamp: Timestamp (Required)\\n- forumintent: Message intent\\n- forumkind: Message kind (Required)\\n- forummeta: Metadata (Required)"
  },
  "fdm.nodes.forum.msg.find": {
    "prefix": "fdm.nodes.forum.msg.find",
    "body": [
      "tool.fdm.nodes.forum.msg.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumMsg nodes by exact field match."
  },
  "fdm.nodes.forum.msg.get": {
    "prefix": "fdm.nodes.forum.msg.get",
    "body": [
      "tool.fdm.nodes.forum.msg.get(${1:id})"
    ],
    "description": "Gets a ForumMsg node by E_ or N_ ID."
  },
  "fdm.nodes.forum.msg.list": {
    "prefix": "fdm.nodes.forum.msg.list",
    "body": [
      "tool.fdm.nodes.forum.msg.list()"
    ],
    "description": "Lists all active ForumMsg nodes."
  },
  "fdm.nodes.forum.msg.mutate": {
    "prefix": "fdm.nodes.forum.msg.mutate",
    "body": [
      "tool.fdm.nodes.forum.msg.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumMsg. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- forumrootid: Root ID\\n- forumthreadid: Thread ID (Required)\\n- forumforumid: Forum ID\\n- forumparentid: Parent Message ID\\n- forumauthor: Author EntityID (Required)\\n- forumbody: Message content (Required)\\n- forumtimestamp: Timestamp (Required)\\n- forumintent: Message intent\\n- forumkind: Message kind (Required)\\n- forummeta: Metadata (Required)"
  },
  "fdm.nodes.forum.msg.upsert": {
    "prefix": "fdm.nodes.forum.msg.upsert",
    "body": [
      "tool.fdm.nodes.forum.msg.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumMsg entity exists with the given human handle."
  },
  "fdm.nodes.forum.post.create": {
    "prefix": "fdm.nodes.forum.post.create",
    "body": [
      "tool.fdm.nodes.forum.post.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumPost. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Post title (Required)\\n- forumbody: Post content (Required)\\n- forumauthor: Author EntityID (Required)\\n- forumtimestamp: Creation timestamp (Required)\\n- forumproject: Project EntityID\\n- forumtags: Tags"
  },
  "fdm.nodes.forum.post.find": {
    "prefix": "fdm.nodes.forum.post.find",
    "body": [
      "tool.fdm.nodes.forum.post.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumPost nodes by exact field match."
  },
  "fdm.nodes.forum.post.get": {
    "prefix": "fdm.nodes.forum.post.get",
    "body": [
      "tool.fdm.nodes.forum.post.get(${1:id})"
    ],
    "description": "Gets a ForumPost node by E_ or N_ ID."
  },
  "fdm.nodes.forum.post.list": {
    "prefix": "fdm.nodes.forum.post.list",
    "body": [
      "tool.fdm.nodes.forum.post.list()"
    ],
    "description": "Lists all active ForumPost nodes."
  },
  "fdm.nodes.forum.post.mutate": {
    "prefix": "fdm.nodes.forum.post.mutate",
    "body": [
      "tool.fdm.nodes.forum.post.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumPost. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Post title (Required)\\n- forumbody: Post content (Required)\\n- forumauthor: Author EntityID (Required)\\n- forumtimestamp: Creation timestamp (Required)\\n- forumproject: Project EntityID\\n- forumtags: Tags"
  },
  "fdm.nodes.forum.post.upsert": {
    "prefix": "fdm.nodes.forum.post.upsert",
    "body": [
      "tool.fdm.nodes.forum.post.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumPost entity exists with the given human handle."
  },
  "fdm.nodes.forum.root.create": {
    "prefix": "fdm.nodes.forum.root.create",
    "body": [
      "tool.fdm.nodes.forum.root.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumRoot. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Title (Required)\\n- forumauthor: Author EntityID (Required)\\n- forumcreated: Creation timestamp (Required)\\n- forumproject: Project link"
  },
  "fdm.nodes.forum.root.find": {
    "prefix": "fdm.nodes.forum.root.find",
    "body": [
      "tool.fdm.nodes.forum.root.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumRoot nodes by exact field match."
  },
  "fdm.nodes.forum.root.get": {
    "prefix": "fdm.nodes.forum.root.get",
    "body": [
      "tool.fdm.nodes.forum.root.get(${1:id})"
    ],
    "description": "Gets a ForumRoot node by E_ or N_ ID."
  },
  "fdm.nodes.forum.root.list": {
    "prefix": "fdm.nodes.forum.root.list",
    "body": [
      "tool.fdm.nodes.forum.root.list()"
    ],
    "description": "Lists all active ForumRoot nodes."
  },
  "fdm.nodes.forum.root.mutate": {
    "prefix": "fdm.nodes.forum.root.mutate",
    "body": [
      "tool.fdm.nodes.forum.root.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumRoot. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Title (Required)\\n- forumauthor: Author EntityID (Required)\\n- forumcreated: Creation timestamp (Required)\\n- forumproject: Project link"
  },
  "fdm.nodes.forum.root.upsert": {
    "prefix": "fdm.nodes.forum.root.upsert",
    "body": [
      "tool.fdm.nodes.forum.root.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumRoot entity exists with the given human handle."
  },
  "fdm.nodes.forum.summary.create": {
    "prefix": "fdm.nodes.forum.summary.create",
    "body": [
      "tool.fdm.nodes.forum.summary.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumSummary. Expects a map of fields.\\nValid keys:\\n- forumcontent: Summary content (Required)\\n- forumcreator: Creator EntityID (Required)\\n- forumroot: Root thread EntityID\\n- forumspan: Span"
  },
  "fdm.nodes.forum.summary.find": {
    "prefix": "fdm.nodes.forum.summary.find",
    "body": [
      "tool.fdm.nodes.forum.summary.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumSummary nodes by exact field match."
  },
  "fdm.nodes.forum.summary.get": {
    "prefix": "fdm.nodes.forum.summary.get",
    "body": [
      "tool.fdm.nodes.forum.summary.get(${1:id})"
    ],
    "description": "Gets a ForumSummary node by E_ or N_ ID."
  },
  "fdm.nodes.forum.summary.list": {
    "prefix": "fdm.nodes.forum.summary.list",
    "body": [
      "tool.fdm.nodes.forum.summary.list()"
    ],
    "description": "Lists all active ForumSummary nodes."
  },
  "fdm.nodes.forum.summary.mutate": {
    "prefix": "fdm.nodes.forum.summary.mutate",
    "body": [
      "tool.fdm.nodes.forum.summary.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumSummary. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- forumcontent: Summary content (Required)\\n- forumcreator: Creator EntityID (Required)\\n- forumroot: Root thread EntityID\\n- forumspan: Span"
  },
  "fdm.nodes.forum.summary.upsert": {
    "prefix": "fdm.nodes.forum.summary.upsert",
    "body": [
      "tool.fdm.nodes.forum.summary.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumSummary entity exists with the given human handle."
  },
  "fdm.nodes.forum.vote.create": {
    "prefix": "fdm.nodes.forum.vote.create",
    "body": [
      "tool.fdm.nodes.forum.vote.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new ForumVote. Expects a map of fields.\\nValid keys:\\n- forummsg: Target message snapshot (Required)\\n- forumvoter: Voter EntityID (Required)\\n- forumvalue: Vote value (Required)"
  },
  "fdm.nodes.forum.vote.find": {
    "prefix": "fdm.nodes.forum.vote.find",
    "body": [
      "tool.fdm.nodes.forum.vote.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds ForumVote nodes by exact field match."
  },
  "fdm.nodes.forum.vote.get": {
    "prefix": "fdm.nodes.forum.vote.get",
    "body": [
      "tool.fdm.nodes.forum.vote.get(${1:id})"
    ],
    "description": "Gets a ForumVote node by E_ or N_ ID."
  },
  "fdm.nodes.forum.vote.list": {
    "prefix": "fdm.nodes.forum.vote.list",
    "body": [
      "tool.fdm.nodes.forum.vote.list()"
    ],
    "description": "Lists all active ForumVote nodes."
  },
  "fdm.nodes.forum.vote.mutate": {
    "prefix": "fdm.nodes.forum.vote.mutate",
    "body": [
      "tool.fdm.nodes.forum.vote.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for ForumVote. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- forummsg: Target message snapshot (Required)\\n- forumvoter: Voter EntityID (Required)\\n- forumvalue: Vote value (Required)"
  },
  "fdm.nodes.forum.vote.upsert": {
    "prefix": "fdm.nodes.forum.vote.upsert",
    "body": [
      "tool.fdm.nodes.forum.vote.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a ForumVote entity exists with the given human handle."
  },
  "fdm.nodes.fs.dir.create": {
    "prefix": "fdm.nodes.fs.dir.create",
    "body": [
      "tool.fdm.nodes.fs.dir.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FsDir. Expects a map of fields.\\nValid keys:\\n- fspath: Absolute directory path (Required)\\n- fskind: Directory kind (Required)\\n- fsparent: Parent directory"
  },
  "fdm.nodes.fs.dir.find": {
    "prefix": "fdm.nodes.fs.dir.find",
    "body": [
      "tool.fdm.nodes.fs.dir.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FsDir nodes by exact field match."
  },
  "fdm.nodes.fs.dir.get": {
    "prefix": "fdm.nodes.fs.dir.get",
    "body": [
      "tool.fdm.nodes.fs.dir.get(${1:id})"
    ],
    "description": "Gets a FsDir node by E_ or N_ ID."
  },
  "fdm.nodes.fs.dir.list": {
    "prefix": "fdm.nodes.fs.dir.list",
    "body": [
      "tool.fdm.nodes.fs.dir.list()"
    ],
    "description": "Lists all active FsDir nodes."
  },
  "fdm.nodes.fs.dir.mutate": {
    "prefix": "fdm.nodes.fs.dir.mutate",
    "body": [
      "tool.fdm.nodes.fs.dir.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FsDir. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fspath: Absolute directory path (Required)\\n- fskind: Directory kind (Required)\\n- fsparent: Parent directory"
  },
  "fdm.nodes.fs.dir.upsert": {
    "prefix": "fdm.nodes.fs.dir.upsert",
    "body": [
      "tool.fdm.nodes.fs.dir.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FsDir entity exists with the given human handle."
  },
  "fdm.nodes.fs.file.create": {
    "prefix": "fdm.nodes.fs.file.create",
    "body": [
      "tool.fdm.nodes.fs.file.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FsFile. Expects a map of fields.\\nValid keys:\\n- fspath: Absolute filesystem path (Required)\\n- fssize: File size (Required)\\n- fsmode: File mode (Required)\\n- fsmodtime: Modification time (Required)\\n- fssha: Content SHA (Required)\\n- fsparent: Parent directory"
  },
  "fdm.nodes.fs.file.find": {
    "prefix": "fdm.nodes.fs.file.find",
    "body": [
      "tool.fdm.nodes.fs.file.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FsFile nodes by exact field match."
  },
  "fdm.nodes.fs.file.get": {
    "prefix": "fdm.nodes.fs.file.get",
    "body": [
      "tool.fdm.nodes.fs.file.get(${1:id})"
    ],
    "description": "Gets a FsFile node by E_ or N_ ID."
  },
  "fdm.nodes.fs.file.list": {
    "prefix": "fdm.nodes.fs.file.list",
    "body": [
      "tool.fdm.nodes.fs.file.list()"
    ],
    "description": "Lists all active FsFile nodes."
  },
  "fdm.nodes.fs.file.mutate": {
    "prefix": "fdm.nodes.fs.file.mutate",
    "body": [
      "tool.fdm.nodes.fs.file.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FsFile. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fspath: Absolute filesystem path (Required)\\n- fssize: File size (Required)\\n- fsmode: File mode (Required)\\n- fsmodtime: Modification time (Required)\\n- fssha: Content SHA (Required)\\n- fsparent: Parent directory"
  },
  "fdm.nodes.fs.file.upsert": {
    "prefix": "fdm.nodes.fs.file.upsert",
    "body": [
      "tool.fdm.nodes.fs.file.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FsFile entity exists with the given human handle."
  },
  "fdm.nodes.fs.rename.create": {
    "prefix": "fdm.nodes.fs.rename.create",
    "body": [
      "tool.fdm.nodes.fs.rename.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new FsRename. Expects a map of fields.\\nValid keys:\\n- fssrcnode: Source node (Required)\\n- fsdstnode: Destination node (Required)\\n- fsts: Rename timestamp (Required)"
  },
  "fdm.nodes.fs.rename.find": {
    "prefix": "fdm.nodes.fs.rename.find",
    "body": [
      "tool.fdm.nodes.fs.rename.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds FsRename nodes by exact field match."
  },
  "fdm.nodes.fs.rename.get": {
    "prefix": "fdm.nodes.fs.rename.get",
    "body": [
      "tool.fdm.nodes.fs.rename.get(${1:id})"
    ],
    "description": "Gets a FsRename node by E_ or N_ ID."
  },
  "fdm.nodes.fs.rename.list": {
    "prefix": "fdm.nodes.fs.rename.list",
    "body": [
      "tool.fdm.nodes.fs.rename.list()"
    ],
    "description": "Lists all active FsRename nodes."
  },
  "fdm.nodes.fs.rename.mutate": {
    "prefix": "fdm.nodes.fs.rename.mutate",
    "body": [
      "tool.fdm.nodes.fs.rename.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for FsRename. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fssrcnode: Source node (Required)\\n- fsdstnode: Destination node (Required)\\n- fsts: Rename timestamp (Required)"
  },
  "fdm.nodes.fs.rename.upsert": {
    "prefix": "fdm.nodes.fs.rename.upsert",
    "body": [
      "tool.fdm.nodes.fs.rename.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a FsRename entity exists with the given human handle."
  },
  "fdm.nodes.go.file.create": {
    "prefix": "fdm.nodes.go.file.create",
    "body": [
      "tool.fdm.nodes.go.file.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new GoFile. Expects a map of fields.\\nValid keys:\\n- gopath: Relative path of the file (Required)\\n- goimportpath: Import path (Required)\\n- fsiparent: Parent link (Required)\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.go.file.find": {
    "prefix": "fdm.nodes.go.file.find",
    "body": [
      "tool.fdm.nodes.go.file.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds GoFile nodes by exact field match."
  },
  "fdm.nodes.go.file.get": {
    "prefix": "fdm.nodes.go.file.get",
    "body": [
      "tool.fdm.nodes.go.file.get(${1:id})"
    ],
    "description": "Gets a GoFile node by E_ or N_ ID."
  },
  "fdm.nodes.go.file.list": {
    "prefix": "fdm.nodes.go.file.list",
    "body": [
      "tool.fdm.nodes.go.file.list()"
    ],
    "description": "Lists all active GoFile nodes."
  },
  "fdm.nodes.go.file.mutate": {
    "prefix": "fdm.nodes.go.file.mutate",
    "body": [
      "tool.fdm.nodes.go.file.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for GoFile. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- gopath: Relative path of the file (Required)\\n- goimportpath: Import path (Required)\\n- fsiparent: Parent link (Required)\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.go.file.upsert": {
    "prefix": "fdm.nodes.go.file.upsert",
    "body": [
      "tool.fdm.nodes.go.file.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a GoFile entity exists with the given human handle."
  },
  "fdm.nodes.go.import.create": {
    "prefix": "fdm.nodes.go.import.create",
    "body": [
      "tool.fdm.nodes.go.import.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new GoImport. Expects a map of fields.\\nValid keys:\\n- goimportpath: Imported path (Required)\\n- fsiparent: Parent file snapshot (Required)"
  },
  "fdm.nodes.go.import.find": {
    "prefix": "fdm.nodes.go.import.find",
    "body": [
      "tool.fdm.nodes.go.import.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds GoImport nodes by exact field match."
  },
  "fdm.nodes.go.import.get": {
    "prefix": "fdm.nodes.go.import.get",
    "body": [
      "tool.fdm.nodes.go.import.get(${1:id})"
    ],
    "description": "Gets a GoImport node by E_ or N_ ID."
  },
  "fdm.nodes.go.import.list": {
    "prefix": "fdm.nodes.go.import.list",
    "body": [
      "tool.fdm.nodes.go.import.list()"
    ],
    "description": "Lists all active GoImport nodes."
  },
  "fdm.nodes.go.import.mutate": {
    "prefix": "fdm.nodes.go.import.mutate",
    "body": [
      "tool.fdm.nodes.go.import.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for GoImport. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- goimportpath: Imported path (Required)\\n- fsiparent: Parent file snapshot (Required)"
  },
  "fdm.nodes.go.import.upsert": {
    "prefix": "fdm.nodes.go.import.upsert",
    "body": [
      "tool.fdm.nodes.go.import.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a GoImport entity exists with the given human handle."
  },
  "fdm.nodes.go.module.create": {
    "prefix": "fdm.nodes.go.module.create",
    "body": [
      "tool.fdm.nodes.go.module.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new GoModule. Expects a map of fields.\\nValid keys:\\n- gomodulepath: Module path (Required)\\n- gomoduleversion: Module version (Required)\\n- godirpath: Filesystem directory path (Required)\\n- goimports: Required modules"
  },
  "fdm.nodes.go.module.find": {
    "prefix": "fdm.nodes.go.module.find",
    "body": [
      "tool.fdm.nodes.go.module.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds GoModule nodes by exact field match."
  },
  "fdm.nodes.go.module.get": {
    "prefix": "fdm.nodes.go.module.get",
    "body": [
      "tool.fdm.nodes.go.module.get(${1:id})"
    ],
    "description": "Gets a GoModule node by E_ or N_ ID."
  },
  "fdm.nodes.go.module.list": {
    "prefix": "fdm.nodes.go.module.list",
    "body": [
      "tool.fdm.nodes.go.module.list()"
    ],
    "description": "Lists all active GoModule nodes."
  },
  "fdm.nodes.go.module.mutate": {
    "prefix": "fdm.nodes.go.module.mutate",
    "body": [
      "tool.fdm.nodes.go.module.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for GoModule. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- gomodulepath: Module path (Required)\\n- gomoduleversion: Module version (Required)\\n- godirpath: Filesystem directory path (Required)\\n- goimports: Required modules"
  },
  "fdm.nodes.go.module.upsert": {
    "prefix": "fdm.nodes.go.module.upsert",
    "body": [
      "tool.fdm.nodes.go.module.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a GoModule entity exists with the given human handle."
  },
  "fdm.nodes.go.package.create": {
    "prefix": "fdm.nodes.go.package.create",
    "body": [
      "tool.fdm.nodes.go.package.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new GoPackage. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Package name (Required)\\n- goimportpath: Import path (Required)\\n- gopath: Filesystem path (Required)"
  },
  "fdm.nodes.go.package.find": {
    "prefix": "fdm.nodes.go.package.find",
    "body": [
      "tool.fdm.nodes.go.package.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds GoPackage nodes by exact field match."
  },
  "fdm.nodes.go.package.get": {
    "prefix": "fdm.nodes.go.package.get",
    "body": [
      "tool.fdm.nodes.go.package.get(${1:id})"
    ],
    "description": "Gets a GoPackage node by E_ or N_ ID."
  },
  "fdm.nodes.go.package.list": {
    "prefix": "fdm.nodes.go.package.list",
    "body": [
      "tool.fdm.nodes.go.package.list()"
    ],
    "description": "Lists all active GoPackage nodes."
  },
  "fdm.nodes.go.package.mutate": {
    "prefix": "fdm.nodes.go.package.mutate",
    "body": [
      "tool.fdm.nodes.go.package.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for GoPackage. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Package name (Required)\\n- goimportpath: Import path (Required)\\n- gopath: Filesystem path (Required)"
  },
  "fdm.nodes.go.package.upsert": {
    "prefix": "fdm.nodes.go.package.upsert",
    "body": [
      "tool.fdm.nodes.go.package.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a GoPackage entity exists with the given human handle."
  },
  "fdm.nodes.go.symbol.create": {
    "prefix": "fdm.nodes.go.symbol.create",
    "body": [
      "tool.fdm.nodes.go.symbol.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new GoSymbol. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Symbol name (Required)\\n- gokind: Symbol kind (Required)\\n- gofile: File path (Required)\\n- gopos: Position (Required)\\n- gohash: Content hash (Required)\\n- gorecv: Receiver\\n- fsiparent: Parent link\\n- analysisrunid: Analysis Run ID\\n- gosignature: Full signature\\n- goisexported: Is exported\\n- goloc: Lines of Code\\n- gostartline: Start line\\n- goendline: End line\\n- verrepoid: Repo EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio"
  },
  "fdm.nodes.go.symbol.find": {
    "prefix": "fdm.nodes.go.symbol.find",
    "body": [
      "tool.fdm.nodes.go.symbol.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds GoSymbol nodes by exact field match."
  },
  "fdm.nodes.go.symbol.get": {
    "prefix": "fdm.nodes.go.symbol.get",
    "body": [
      "tool.fdm.nodes.go.symbol.get(${1:id})"
    ],
    "description": "Gets a GoSymbol node by E_ or N_ ID."
  },
  "fdm.nodes.go.symbol.list": {
    "prefix": "fdm.nodes.go.symbol.list",
    "body": [
      "tool.fdm.nodes.go.symbol.list()"
    ],
    "description": "Lists all active GoSymbol nodes."
  },
  "fdm.nodes.go.symbol.mutate": {
    "prefix": "fdm.nodes.go.symbol.mutate",
    "body": [
      "tool.fdm.nodes.go.symbol.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for GoSymbol. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Symbol name (Required)\\n- gokind: Symbol kind (Required)\\n- gofile: File path (Required)\\n- gopos: Position (Required)\\n- gohash: Content hash (Required)\\n- gorecv: Receiver\\n- fsiparent: Parent link\\n- analysisrunid: Analysis Run ID\\n- gosignature: Full signature\\n- goisexported: Is exported\\n- goloc: Lines of Code\\n- gostartline: Start line\\n- goendline: End line\\n- verrepoid: Repo EntityID\\n- vercommithash: Commit Hash\\n- vercommitts: Commit Timestamp\\n- verishead: Is Head\\n- verversion: Version\\n- verfolio: Folio"
  },
  "fdm.nodes.go.symbol.upsert": {
    "prefix": "fdm.nodes.go.symbol.upsert",
    "body": [
      "tool.fdm.nodes.go.symbol.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a GoSymbol entity exists with the given human handle."
  },
  "fdm.nodes.group.create": {
    "prefix": "fdm.nodes.group.create",
    "body": [
      "tool.fdm.nodes.group.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new Group. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Group title (Required)\\n- groupdescription: Description\\n- groupmembers: Explicit members\\n- grouprolefilters: Role filters\\n- grouphints: Hints"
  },
  "fdm.nodes.group.find": {
    "prefix": "fdm.nodes.group.find",
    "body": [
      "tool.fdm.nodes.group.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds Group nodes by exact field match."
  },
  "fdm.nodes.group.get": {
    "prefix": "fdm.nodes.group.get",
    "body": [
      "tool.fdm.nodes.group.get(${1:id})"
    ],
    "description": "Gets a Group node by E_ or N_ ID."
  },
  "fdm.nodes.group.list": {
    "prefix": "fdm.nodes.group.list",
    "body": [
      "tool.fdm.nodes.group.list()"
    ],
    "description": "Lists all active Group nodes."
  },
  "fdm.nodes.group.mutate": {
    "prefix": "fdm.nodes.group.mutate",
    "body": [
      "tool.fdm.nodes.group.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for Group. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Group title (Required)\\n- groupdescription: Description\\n- groupmembers: Explicit members\\n- grouprolefilters: Role filters\\n- grouphints: Hints"
  },
  "fdm.nodes.group.upsert": {
    "prefix": "fdm.nodes.group.upsert",
    "body": [
      "tool.fdm.nodes.group.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a Group entity exists with the given human handle."
  },
  "fdm.nodes.intent.item.create": {
    "prefix": "fdm.nodes.intent.item.create",
    "body": [
      "tool.fdm.nodes.intent.item.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new IntentItem. Expects a map of fields.\\nValid keys:\\n- intentcategory: Category (TODO/FIXME) (Required)\\n- intenttext: Intent content (Required)\\n- intentsource: Source file (Required)\\n- intentline: Line number (Required)\\n- intentauthor: Author Agent EntityID\\n- intentpriority: Priority level\\n- intentscope: Scope (package/line)\\n- analysisrunid: Analysis run anchor"
  },
  "fdm.nodes.intent.item.find": {
    "prefix": "fdm.nodes.intent.item.find",
    "body": [
      "tool.fdm.nodes.intent.item.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds IntentItem nodes by exact field match."
  },
  "fdm.nodes.intent.item.get": {
    "prefix": "fdm.nodes.intent.item.get",
    "body": [
      "tool.fdm.nodes.intent.item.get(${1:id})"
    ],
    "description": "Gets a IntentItem node by E_ or N_ ID."
  },
  "fdm.nodes.intent.item.list": {
    "prefix": "fdm.nodes.intent.item.list",
    "body": [
      "tool.fdm.nodes.intent.item.list()"
    ],
    "description": "Lists all active IntentItem nodes."
  },
  "fdm.nodes.intent.item.mutate": {
    "prefix": "fdm.nodes.intent.item.mutate",
    "body": [
      "tool.fdm.nodes.intent.item.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for IntentItem. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- intentcategory: Category (TODO/FIXME) (Required)\\n- intenttext: Intent content (Required)\\n- intentsource: Source file (Required)\\n- intentline: Line number (Required)\\n- intentauthor: Author Agent EntityID\\n- intentpriority: Priority level\\n- intentscope: Scope (package/line)\\n- analysisrunid: Analysis run anchor"
  },
  "fdm.nodes.intent.item.upsert": {
    "prefix": "fdm.nodes.intent.item.upsert",
    "body": [
      "tool.fdm.nodes.intent.item.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a IntentItem entity exists with the given human handle."
  },
  "fdm.nodes.link.edge.create": {
    "prefix": "fdm.nodes.link.edge.create",
    "body": [
      "tool.fdm.nodes.link.edge.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new LinkEdge. Expects a map of fields.\\nValid keys:\\n- linkfrom: Source node ID (Required)\\n- linkto: Target node ID (Snapshot)\\n- linktoentity: Target entity ID (Live)\\n- linkkind: Relation kind (Required)\\n- linkoverlay: Overlay context\\n- linkweight: Edge weight"
  },
  "fdm.nodes.link.edge.find": {
    "prefix": "fdm.nodes.link.edge.find",
    "body": [
      "tool.fdm.nodes.link.edge.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds LinkEdge nodes by exact field match."
  },
  "fdm.nodes.link.edge.get": {
    "prefix": "fdm.nodes.link.edge.get",
    "body": [
      "tool.fdm.nodes.link.edge.get(${1:id})"
    ],
    "description": "Gets a LinkEdge node by E_ or N_ ID."
  },
  "fdm.nodes.link.edge.list": {
    "prefix": "fdm.nodes.link.edge.list",
    "body": [
      "tool.fdm.nodes.link.edge.list()"
    ],
    "description": "Lists all active LinkEdge nodes."
  },
  "fdm.nodes.link.edge.mutate": {
    "prefix": "fdm.nodes.link.edge.mutate",
    "body": [
      "tool.fdm.nodes.link.edge.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for LinkEdge. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- linkfrom: Source node ID (Required)\\n- linkto: Target node ID (Snapshot)\\n- linktoentity: Target entity ID (Live)\\n- linkkind: Relation kind (Required)\\n- linkoverlay: Overlay context\\n- linkweight: Edge weight"
  },
  "fdm.nodes.link.edge.upsert": {
    "prefix": "fdm.nodes.link.edge.upsert",
    "body": [
      "tool.fdm.nodes.link.edge.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a LinkEdge entity exists with the given human handle."
  },
  "fdm.nodes.link.entity.create": {
    "prefix": "fdm.nodes.link.entity.create",
    "body": [
      "tool.fdm.nodes.link.entity.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new LinkEntity. Expects a map of fields.\\nValid keys:\\n- linkfrom: Source EntityID (Required)\\n- linkto: Target EntityID (Required)\\n- linkkind: Relation kind (Required)\\n- linkoverlay: Overlay context\\n- linkweight: Edge weight"
  },
  "fdm.nodes.link.entity.find": {
    "prefix": "fdm.nodes.link.entity.find",
    "body": [
      "tool.fdm.nodes.link.entity.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds LinkEntity nodes by exact field match."
  },
  "fdm.nodes.link.entity.get": {
    "prefix": "fdm.nodes.link.entity.get",
    "body": [
      "tool.fdm.nodes.link.entity.get(${1:id})"
    ],
    "description": "Gets a LinkEntity node by E_ or N_ ID."
  },
  "fdm.nodes.link.entity.list": {
    "prefix": "fdm.nodes.link.entity.list",
    "body": [
      "tool.fdm.nodes.link.entity.list()"
    ],
    "description": "Lists all active LinkEntity nodes."
  },
  "fdm.nodes.link.entity.mutate": {
    "prefix": "fdm.nodes.link.entity.mutate",
    "body": [
      "tool.fdm.nodes.link.entity.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for LinkEntity. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- linkfrom: Source EntityID (Required)\\n- linkto: Target EntityID (Required)\\n- linkkind: Relation kind (Required)\\n- linkoverlay: Overlay context\\n- linkweight: Edge weight"
  },
  "fdm.nodes.link.entity.upsert": {
    "prefix": "fdm.nodes.link.entity.upsert",
    "body": [
      "tool.fdm.nodes.link.entity.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a LinkEntity entity exists with the given human handle."
  },
  "fdm.nodes.meta.kv.create": {
    "prefix": "fdm.nodes.meta.kv.create",
    "body": [
      "tool.fdm.nodes.meta.kv.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new MetaKv. Expects a map of fields.\\nValid keys:\\n- metasource: Source node snapshot (Required)\\n- metamap: Metadata map (Required)"
  },
  "fdm.nodes.meta.kv.find": {
    "prefix": "fdm.nodes.meta.kv.find",
    "body": [
      "tool.fdm.nodes.meta.kv.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds MetaKv nodes by exact field match."
  },
  "fdm.nodes.meta.kv.get": {
    "prefix": "fdm.nodes.meta.kv.get",
    "body": [
      "tool.fdm.nodes.meta.kv.get(${1:id})"
    ],
    "description": "Gets a MetaKv node by E_ or N_ ID."
  },
  "fdm.nodes.meta.kv.list": {
    "prefix": "fdm.nodes.meta.kv.list",
    "body": [
      "tool.fdm.nodes.meta.kv.list()"
    ],
    "description": "Lists all active MetaKv nodes."
  },
  "fdm.nodes.meta.kv.mutate": {
    "prefix": "fdm.nodes.meta.kv.mutate",
    "body": [
      "tool.fdm.nodes.meta.kv.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for MetaKv. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- metasource: Source node snapshot (Required)\\n- metamap: Metadata map (Required)"
  },
  "fdm.nodes.meta.kv.upsert": {
    "prefix": "fdm.nodes.meta.kv.upsert",
    "body": [
      "tool.fdm.nodes.meta.kv.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a MetaKv entity exists with the given human handle."
  },
  "fdm.nodes.nd.block.create": {
    "prefix": "fdm.nodes.nd.block.create",
    "body": [
      "tool.fdm.nodes.nd.block.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdBlock. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Human-friendly name of the block (Required)\\n- ndblocktype: Block type discriminator (e.g. ndcl, doc, notes) (Required)\\n- ndsource: Optional source locator (path/URI/handle)\\n- ndtags: Tags for organizing/searching"
  },
  "fdm.nodes.nd.block.find": {
    "prefix": "fdm.nodes.nd.block.find",
    "body": [
      "tool.fdm.nodes.nd.block.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdBlock nodes by exact field match."
  },
  "fdm.nodes.nd.block.get": {
    "prefix": "fdm.nodes.nd.block.get",
    "body": [
      "tool.fdm.nodes.nd.block.get(${1:id})"
    ],
    "description": "Gets a NdBlock node by E_ or N_ ID."
  },
  "fdm.nodes.nd.block.list": {
    "prefix": "fdm.nodes.nd.block.list",
    "body": [
      "tool.fdm.nodes.nd.block.list()"
    ],
    "description": "Lists all active NdBlock nodes."
  },
  "fdm.nodes.nd.block.mutate": {
    "prefix": "fdm.nodes.nd.block.mutate",
    "body": [
      "tool.fdm.nodes.nd.block.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdBlock. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Human-friendly name of the block (Required)\\n- ndblocktype: Block type discriminator (e.g. ndcl, doc, notes) (Required)\\n- ndsource: Optional source locator (path/URI/handle)\\n- ndtags: Tags for organizing/searching"
  },
  "fdm.nodes.nd.block.upsert": {
    "prefix": "fdm.nodes.nd.block.upsert",
    "body": [
      "tool.fdm.nodes.nd.block.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdBlock entity exists with the given human handle."
  },
  "fdm.nodes.nd.block_state.create": {
    "prefix": "fdm.nodes.nd.block_state.create",
    "body": [
      "tool.fdm.nodes.nd.block_state.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdBlockState. Expects a map of fields.\\nValid keys:\\n- ndblock: Owning block EntityID (Required)\\n- ndtext: Raw block body text (preserved byte-for-byte) (Required)\\n- ndmeta: Block metadata (JSON object, list, or scalar)\\n- ndsourceanchor: Immutable source snapshot node\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.nd.block_state.find": {
    "prefix": "fdm.nodes.nd.block_state.find",
    "body": [
      "tool.fdm.nodes.nd.block_state.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdBlockState nodes by exact field match."
  },
  "fdm.nodes.nd.block_state.get": {
    "prefix": "fdm.nodes.nd.block_state.get",
    "body": [
      "tool.fdm.nodes.nd.block_state.get(${1:id})"
    ],
    "description": "Gets a NdBlockState node by E_ or N_ ID."
  },
  "fdm.nodes.nd.block_state.list": {
    "prefix": "fdm.nodes.nd.block_state.list",
    "body": [
      "tool.fdm.nodes.nd.block_state.list()"
    ],
    "description": "Lists all active NdBlockState nodes."
  },
  "fdm.nodes.nd.block_state.mutate": {
    "prefix": "fdm.nodes.nd.block_state.mutate",
    "body": [
      "tool.fdm.nodes.nd.block_state.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdBlockState. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndblock: Owning block EntityID (Required)\\n- ndtext: Raw block body text (preserved byte-for-byte) (Required)\\n- ndmeta: Block metadata (JSON object, list, or scalar)\\n- ndsourceanchor: Immutable source snapshot node\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.nd.block_state.upsert": {
    "prefix": "fdm.nodes.nd.block_state.upsert",
    "body": [
      "tool.fdm.nodes.nd.block_state.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdBlockState entity exists with the given human handle."
  },
  "fdm.nodes.ndcl.checklist.create": {
    "prefix": "fdm.nodes.ndcl.checklist.create",
    "body": [
      "tool.fdm.nodes.ndcl.checklist.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdclChecklist. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Human-friendly checklist name (Required)\\n- ndclformatversion: NDCL text format version (e.g. 0.9)\\n- ndclcontainerblock: Container nd/block EntityID (optional)\\n- ndclunits: Units for ndcl:remaining values\\n- ndclunitlabel: Custom unit label (required when units=custom)\\n- ndclrootitem: Root ndcl/item (optional)"
  },
  "fdm.nodes.ndcl.checklist.find": {
    "prefix": "fdm.nodes.ndcl.checklist.find",
    "body": [
      "tool.fdm.nodes.ndcl.checklist.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdclChecklist nodes by exact field match."
  },
  "fdm.nodes.ndcl.checklist.get": {
    "prefix": "fdm.nodes.ndcl.checklist.get",
    "body": [
      "tool.fdm.nodes.ndcl.checklist.get(${1:id})"
    ],
    "description": "Gets a NdclChecklist node by E_ or N_ ID."
  },
  "fdm.nodes.ndcl.checklist.list": {
    "prefix": "fdm.nodes.ndcl.checklist.list",
    "body": [
      "tool.fdm.nodes.ndcl.checklist.list()"
    ],
    "description": "Lists all active NdclChecklist nodes."
  },
  "fdm.nodes.ndcl.checklist.mutate": {
    "prefix": "fdm.nodes.ndcl.checklist.mutate",
    "body": [
      "tool.fdm.nodes.ndcl.checklist.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdclChecklist. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Human-friendly checklist name (Required)\\n- ndclformatversion: NDCL text format version (e.g. 0.9)\\n- ndclcontainerblock: Container nd/block EntityID (optional)\\n- ndclunits: Units for ndcl:remaining values\\n- ndclunitlabel: Custom unit label (required when units=custom)\\n- ndclrootitem: Root ndcl/item (optional)"
  },
  "fdm.nodes.ndcl.checklist.upsert": {
    "prefix": "fdm.nodes.ndcl.checklist.upsert",
    "body": [
      "tool.fdm.nodes.ndcl.checklist.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdclChecklist entity exists with the given human handle."
  },
  "fdm.nodes.ndcl.item.create": {
    "prefix": "fdm.nodes.ndcl.item.create",
    "body": [
      "tool.fdm.nodes.ndcl.item.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdclItem. Expects a map of fields.\\nValid keys:\\n- ndclchecklist: Owning ndcl/checklist EntityID (Required)\\n- ndclitemid: Stable item identifier from #(id) marker (Required)\\n- fdmdisplayname: Optional short label for the item"
  },
  "fdm.nodes.ndcl.item.find": {
    "prefix": "fdm.nodes.ndcl.item.find",
    "body": [
      "tool.fdm.nodes.ndcl.item.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdclItem nodes by exact field match."
  },
  "fdm.nodes.ndcl.item.get": {
    "prefix": "fdm.nodes.ndcl.item.get",
    "body": [
      "tool.fdm.nodes.ndcl.item.get(${1:id})"
    ],
    "description": "Gets a NdclItem node by E_ or N_ ID."
  },
  "fdm.nodes.ndcl.item.list": {
    "prefix": "fdm.nodes.ndcl.item.list",
    "body": [
      "tool.fdm.nodes.ndcl.item.list()"
    ],
    "description": "Lists all active NdclItem nodes."
  },
  "fdm.nodes.ndcl.item.mutate": {
    "prefix": "fdm.nodes.ndcl.item.mutate",
    "body": [
      "tool.fdm.nodes.ndcl.item.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdclItem. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndclchecklist: Owning ndcl/checklist EntityID (Required)\\n- ndclitemid: Stable item identifier from #(id) marker (Required)\\n- fdmdisplayname: Optional short label for the item"
  },
  "fdm.nodes.ndcl.item.upsert": {
    "prefix": "fdm.nodes.ndcl.item.upsert",
    "body": [
      "tool.fdm.nodes.ndcl.item.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdclItem entity exists with the given human handle."
  },
  "fdm.nodes.ndcl.item_state.create": {
    "prefix": "fdm.nodes.ndcl.item_state.create",
    "body": [
      "tool.fdm.nodes.ndcl.item_state.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdclItemState. Expects a map of fields.\\nValid keys:\\n- ndclitem: Owning ndcl/item EntityID (Required)\\n- ndclcompletion: Completion in [0,1] (Required)\\n- ndclremaining: Remaining effort (float, unbounded)\\n- ndclstate: Categorical state for attention/semantics\\n- ndcltext: Canonical item text (without #(id) marker)\\n- ndclisautomatic: Is this item an automatic rollup item?\\n- ndclsymbol: Legacy render symbol (optional)\\n- ndclsourceline: Source line number in the last parsed/rendered text (optional)\\n- ndclindent: Indent level observed in last parse/render (optional)\\n- ndclsourceblockstate: nd/block_state snapshot node used for merge/provenance\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.ndcl.item_state.find": {
    "prefix": "fdm.nodes.ndcl.item_state.find",
    "body": [
      "tool.fdm.nodes.ndcl.item_state.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdclItemState nodes by exact field match."
  },
  "fdm.nodes.ndcl.item_state.get": {
    "prefix": "fdm.nodes.ndcl.item_state.get",
    "body": [
      "tool.fdm.nodes.ndcl.item_state.get(${1:id})"
    ],
    "description": "Gets a NdclItemState node by E_ or N_ ID."
  },
  "fdm.nodes.ndcl.item_state.list": {
    "prefix": "fdm.nodes.ndcl.item_state.list",
    "body": [
      "tool.fdm.nodes.ndcl.item_state.list()"
    ],
    "description": "Lists all active NdclItemState nodes."
  },
  "fdm.nodes.ndcl.item_state.mutate": {
    "prefix": "fdm.nodes.ndcl.item_state.mutate",
    "body": [
      "tool.fdm.nodes.ndcl.item_state.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdclItemState. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndclitem: Owning ndcl/item EntityID (Required)\\n- ndclcompletion: Completion in [0,1] (Required)\\n- ndclremaining: Remaining effort (float, unbounded)\\n- ndclstate: Categorical state for attention/semantics\\n- ndcltext: Canonical item text (without #(id) marker)\\n- ndclisautomatic: Is this item an automatic rollup item?\\n- ndclsymbol: Legacy render symbol (optional)\\n- ndclsourceline: Source line number in the last parsed/rendered text (optional)\\n- ndclindent: Indent level observed in last parse/render (optional)\\n- ndclsourceblockstate: nd/block_state snapshot node used for merge/provenance\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.ndcl.item_state.upsert": {
    "prefix": "fdm.nodes.ndcl.item_state.upsert",
    "body": [
      "tool.fdm.nodes.ndcl.item_state.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdclItemState entity exists with the given human handle."
  },
  "fdm.nodes.ndcl.structure.create": {
    "prefix": "fdm.nodes.ndcl.structure.create",
    "body": [
      "tool.fdm.nodes.ndcl.structure.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdclStructure. Expects a map of fields.\\nValid keys:\\n- ndclchecklist: Owning ndcl/checklist EntityID (Required)"
  },
  "fdm.nodes.ndcl.structure.find": {
    "prefix": "fdm.nodes.ndcl.structure.find",
    "body": [
      "tool.fdm.nodes.ndcl.structure.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdclStructure nodes by exact field match."
  },
  "fdm.nodes.ndcl.structure.get": {
    "prefix": "fdm.nodes.ndcl.structure.get",
    "body": [
      "tool.fdm.nodes.ndcl.structure.get(${1:id})"
    ],
    "description": "Gets a NdclStructure node by E_ or N_ ID."
  },
  "fdm.nodes.ndcl.structure.list": {
    "prefix": "fdm.nodes.ndcl.structure.list",
    "body": [
      "tool.fdm.nodes.ndcl.structure.list()"
    ],
    "description": "Lists all active NdclStructure nodes."
  },
  "fdm.nodes.ndcl.structure.mutate": {
    "prefix": "fdm.nodes.ndcl.structure.mutate",
    "body": [
      "tool.fdm.nodes.ndcl.structure.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdclStructure. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndclchecklist: Owning ndcl/checklist EntityID (Required)"
  },
  "fdm.nodes.ndcl.structure.upsert": {
    "prefix": "fdm.nodes.ndcl.structure.upsert",
    "body": [
      "tool.fdm.nodes.ndcl.structure.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdclStructure entity exists with the given human handle."
  },
  "fdm.nodes.ndcl.structure_state.create": {
    "prefix": "fdm.nodes.ndcl.structure_state.create",
    "body": [
      "tool.fdm.nodes.ndcl.structure_state.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdclStructureState. Expects a map of fields.\\nValid keys:\\n- ndclstructure: Owning ndcl/structure EntityID (Required)\\n- ndclitems: Ordered list of ndcl/item EntityIDs (Required)\\n- ndclparentindex: Parallel parent index array (-1 for root; otherwise index into ndcl:items) (Required)\\n- ndclindent: Parallel indent array (required; 0 for roots) (Required)\\n- ndclsourceblockstate: nd/block_state snapshot node used for merge/provenance\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.ndcl.structure_state.find": {
    "prefix": "fdm.nodes.ndcl.structure_state.find",
    "body": [
      "tool.fdm.nodes.ndcl.structure_state.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdclStructureState nodes by exact field match."
  },
  "fdm.nodes.ndcl.structure_state.get": {
    "prefix": "fdm.nodes.ndcl.structure_state.get",
    "body": [
      "tool.fdm.nodes.ndcl.structure_state.get(${1:id})"
    ],
    "description": "Gets a NdclStructureState node by E_ or N_ ID."
  },
  "fdm.nodes.ndcl.structure_state.list": {
    "prefix": "fdm.nodes.ndcl.structure_state.list",
    "body": [
      "tool.fdm.nodes.ndcl.structure_state.list()"
    ],
    "description": "Lists all active NdclStructureState nodes."
  },
  "fdm.nodes.ndcl.structure_state.mutate": {
    "prefix": "fdm.nodes.ndcl.structure_state.mutate",
    "body": [
      "tool.fdm.nodes.ndcl.structure_state.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdclStructureState. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndclstructure: Owning ndcl/structure EntityID (Required)\\n- ndclitems: Ordered list of ndcl/item EntityIDs (Required)\\n- ndclparentindex: Parallel parent index array (-1 for root; otherwise index into ndcl:items) (Required)\\n- ndclindent: Parallel indent array (required; 0 for roots) (Required)\\n- ndclsourceblockstate: nd/block_state snapshot node used for merge/provenance\\n- analysisrunid: Analysis Run ID"
  },
  "fdm.nodes.ndcl.structure_state.upsert": {
    "prefix": "fdm.nodes.ndcl.structure_state.upsert",
    "body": [
      "tool.fdm.nodes.ndcl.structure_state.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdclStructureState entity exists with the given human handle."
  },
  "fdm.nodes.ndsa.atom.create": {
    "prefix": "fdm.nodes.ndsa.atom.create",
    "body": [
      "tool.fdm.nodes.ndsa.atom.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdsaAtom. Expects a map of fields.\\nValid keys:\\n- ndsasubject: The EntityID this is about (Required)\\n- ndsafamily: Semantic class of speech act (Required)\\n- ndsakey: Specific key (e.g. risk.impact) (Required)\\n- ndsacontentkind: Discriminator for content field (Required)\\n- ndsacontenttext: Text payload\\n- ndsacontentlist: List payload (Native JSON)\\n- ndsacontentmap: Map payload (Native JSON)\\n- ndsascope: Scope of the assertion (Required)\\n- ndsascopeid: Identifier for the scope (e.g. function signature or symbol name)\\n- ndsaconfidence: Confidence 0.0-1.0\\n- ndsamodel: Asserter identity/model\\n- ndsasourcehash: Hash of the source file content\\n- ndsaevidencekind: Source of truth backing this claim\\n- ndsaevidencerefs: List of structured evidence objects (frozen contract)\\n- ndsavector: Embedding vector"
  },
  "fdm.nodes.ndsa.atom.find": {
    "prefix": "fdm.nodes.ndsa.atom.find",
    "body": [
      "tool.fdm.nodes.ndsa.atom.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdsaAtom nodes by exact field match."
  },
  "fdm.nodes.ndsa.atom.get": {
    "prefix": "fdm.nodes.ndsa.atom.get",
    "body": [
      "tool.fdm.nodes.ndsa.atom.get(${1:id})"
    ],
    "description": "Gets a NdsaAtom node by E_ or N_ ID."
  },
  "fdm.nodes.ndsa.atom.list": {
    "prefix": "fdm.nodes.ndsa.atom.list",
    "body": [
      "tool.fdm.nodes.ndsa.atom.list()"
    ],
    "description": "Lists all active NdsaAtom nodes."
  },
  "fdm.nodes.ndsa.atom.mutate": {
    "prefix": "fdm.nodes.ndsa.atom.mutate",
    "body": [
      "tool.fdm.nodes.ndsa.atom.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdsaAtom. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndsasubject: The EntityID this is about (Required)\\n- ndsafamily: Semantic class of speech act (Required)\\n- ndsakey: Specific key (e.g. risk.impact) (Required)\\n- ndsacontentkind: Discriminator for content field (Required)\\n- ndsacontenttext: Text payload\\n- ndsacontentlist: List payload (Native JSON)\\n- ndsacontentmap: Map payload (Native JSON)\\n- ndsascope: Scope of the assertion (Required)\\n- ndsascopeid: Identifier for the scope (e.g. function signature or symbol name)\\n- ndsaconfidence: Confidence 0.0-1.0\\n- ndsamodel: Asserter identity/model\\n- ndsasourcehash: Hash of the source file content\\n- ndsaevidencekind: Source of truth backing this claim\\n- ndsaevidencerefs: List of structured evidence objects (frozen contract)\\n- ndsavector: Embedding vector"
  },
  "fdm.nodes.ndsa.atom.upsert": {
    "prefix": "fdm.nodes.ndsa.atom.upsert",
    "body": [
      "tool.fdm.nodes.ndsa.atom.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdsaAtom entity exists with the given human handle."
  },
  "fdm.nodes.ndsa.canonical.create": {
    "prefix": "fdm.nodes.ndsa.canonical.create",
    "body": [
      "tool.fdm.nodes.ndsa.canonical.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NdsaCanonical. Expects a map of fields.\\nValid keys:\\n- ndsasubject: The EntityID this fact applies to (Required)\\n- ndsascope: Scope (file, func, type) (Required)\\n- ndsascopeid: Scope Identifier (e.g. signature)\\n- ndsafamily: Semantic family (Required)\\n- ndsakey: Specific key (Required)\\n- ndsacontentkind: Discriminator (Required)\\n- ndsacontenttext: Merged Text payload\\n- ndsacontentlist: Merged List payload\\n- ndsacontentmap: Merged Map payload\\n- ndsasourceatoms: List of immutable Atom NodeIDs merged into this node\\n- ndsacanonicalhash: Hash of the merged content for change detection\\n- ndsaepochupdated: Last update timestamp"
  },
  "fdm.nodes.ndsa.canonical.find": {
    "prefix": "fdm.nodes.ndsa.canonical.find",
    "body": [
      "tool.fdm.nodes.ndsa.canonical.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NdsaCanonical nodes by exact field match."
  },
  "fdm.nodes.ndsa.canonical.get": {
    "prefix": "fdm.nodes.ndsa.canonical.get",
    "body": [
      "tool.fdm.nodes.ndsa.canonical.get(${1:id})"
    ],
    "description": "Gets a NdsaCanonical node by E_ or N_ ID."
  },
  "fdm.nodes.ndsa.canonical.list": {
    "prefix": "fdm.nodes.ndsa.canonical.list",
    "body": [
      "tool.fdm.nodes.ndsa.canonical.list()"
    ],
    "description": "Lists all active NdsaCanonical nodes."
  },
  "fdm.nodes.ndsa.canonical.mutate": {
    "prefix": "fdm.nodes.ndsa.canonical.mutate",
    "body": [
      "tool.fdm.nodes.ndsa.canonical.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NdsaCanonical. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- ndsasubject: The EntityID this fact applies to (Required)\\n- ndsascope: Scope (file, func, type) (Required)\\n- ndsascopeid: Scope Identifier (e.g. signature)\\n- ndsafamily: Semantic family (Required)\\n- ndsakey: Specific key (Required)\\n- ndsacontentkind: Discriminator (Required)\\n- ndsacontenttext: Merged Text payload\\n- ndsacontentlist: Merged List payload\\n- ndsacontentmap: Merged Map payload\\n- ndsasourceatoms: List of immutable Atom NodeIDs merged into this node\\n- ndsacanonicalhash: Hash of the merged content for change detection\\n- ndsaepochupdated: Last update timestamp"
  },
  "fdm.nodes.ndsa.canonical.upsert": {
    "prefix": "fdm.nodes.ndsa.canonical.upsert",
    "body": [
      "tool.fdm.nodes.ndsa.canonical.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NdsaCanonical entity exists with the given human handle."
  },
  "fdm.nodes.ns.constant.create": {
    "prefix": "fdm.nodes.ns.constant.create",
    "body": [
      "tool.fdm.nodes.ns.constant.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NsConstant. Expects a map of fields.\\nValid keys:\\n- nsast: Serialized AST (Required)\\n- fdmdisplayname: Constant name (Required)\\n- nsversion: Version string (Required)\\n- nsbinaryversion: Binary compatibility version\\n- nssourcechunk: Source chunk ID (Required)\\n- nsfile: Source file path (Required)"
  },
  "fdm.nodes.ns.constant.find": {
    "prefix": "fdm.nodes.ns.constant.find",
    "body": [
      "tool.fdm.nodes.ns.constant.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NsConstant nodes by exact field match."
  },
  "fdm.nodes.ns.constant.get": {
    "prefix": "fdm.nodes.ns.constant.get",
    "body": [
      "tool.fdm.nodes.ns.constant.get(${1:id})"
    ],
    "description": "Gets a NsConstant node by E_ or N_ ID."
  },
  "fdm.nodes.ns.constant.list": {
    "prefix": "fdm.nodes.ns.constant.list",
    "body": [
      "tool.fdm.nodes.ns.constant.list()"
    ],
    "description": "Lists all active NsConstant nodes."
  },
  "fdm.nodes.ns.constant.mutate": {
    "prefix": "fdm.nodes.ns.constant.mutate",
    "body": [
      "tool.fdm.nodes.ns.constant.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NsConstant. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- nsast: Serialized AST (Required)\\n- fdmdisplayname: Constant name (Required)\\n- nsversion: Version string (Required)\\n- nsbinaryversion: Binary compatibility version\\n- nssourcechunk: Source chunk ID (Required)\\n- nsfile: Source file path (Required)"
  },
  "fdm.nodes.ns.constant.upsert": {
    "prefix": "fdm.nodes.ns.constant.upsert",
    "body": [
      "tool.fdm.nodes.ns.constant.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NsConstant entity exists with the given human handle."
  },
  "fdm.nodes.ns.function.create": {
    "prefix": "fdm.nodes.ns.function.create",
    "body": [
      "tool.fdm.nodes.ns.function.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NsFunction. Expects a map of fields.\\nValid keys:\\n- nsast: Serialized AST (Required)\\n- fdmdisplayname: Function name (Required)\\n- nsversion: Version string (Required)\\n- nsbinaryversion: Binary compatibility version\\n- nssourcechunk: Source chunk ID (Required)\\n- nsfile: Source file path (Required)"
  },
  "fdm.nodes.ns.function.find": {
    "prefix": "fdm.nodes.ns.function.find",
    "body": [
      "tool.fdm.nodes.ns.function.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NsFunction nodes by exact field match."
  },
  "fdm.nodes.ns.function.get": {
    "prefix": "fdm.nodes.ns.function.get",
    "body": [
      "tool.fdm.nodes.ns.function.get(${1:id})"
    ],
    "description": "Gets a NsFunction node by E_ or N_ ID."
  },
  "fdm.nodes.ns.function.list": {
    "prefix": "fdm.nodes.ns.function.list",
    "body": [
      "tool.fdm.nodes.ns.function.list()"
    ],
    "description": "Lists all active NsFunction nodes."
  },
  "fdm.nodes.ns.function.mutate": {
    "prefix": "fdm.nodes.ns.function.mutate",
    "body": [
      "tool.fdm.nodes.ns.function.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NsFunction. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- nsast: Serialized AST (Required)\\n- fdmdisplayname: Function name (Required)\\n- nsversion: Version string (Required)\\n- nsbinaryversion: Binary compatibility version\\n- nssourcechunk: Source chunk ID (Required)\\n- nsfile: Source file path (Required)"
  },
  "fdm.nodes.ns.function.upsert": {
    "prefix": "fdm.nodes.ns.function.upsert",
    "body": [
      "tool.fdm.nodes.ns.function.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NsFunction entity exists with the given human handle."
  },
  "fdm.nodes.ns.handler.create": {
    "prefix": "fdm.nodes.ns.handler.create",
    "body": [
      "tool.fdm.nodes.ns.handler.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new NsHandler. Expects a map of fields.\\nValid keys:\\n- nsast: Serialized AST (Required)\\n- fdmdisplayname: Handler name (Required)\\n- nsversion: Version string (Required)\\n- nsbinaryversion: Binary compatibility version\\n- nssourcechunk: Source chunk ID (Required)\\n- nsfile: Source file path (Required)"
  },
  "fdm.nodes.ns.handler.find": {
    "prefix": "fdm.nodes.ns.handler.find",
    "body": [
      "tool.fdm.nodes.ns.handler.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds NsHandler nodes by exact field match."
  },
  "fdm.nodes.ns.handler.get": {
    "prefix": "fdm.nodes.ns.handler.get",
    "body": [
      "tool.fdm.nodes.ns.handler.get(${1:id})"
    ],
    "description": "Gets a NsHandler node by E_ or N_ ID."
  },
  "fdm.nodes.ns.handler.list": {
    "prefix": "fdm.nodes.ns.handler.list",
    "body": [
      "tool.fdm.nodes.ns.handler.list()"
    ],
    "description": "Lists all active NsHandler nodes."
  },
  "fdm.nodes.ns.handler.mutate": {
    "prefix": "fdm.nodes.ns.handler.mutate",
    "body": [
      "tool.fdm.nodes.ns.handler.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for NsHandler. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- nsast: Serialized AST (Required)\\n- fdmdisplayname: Handler name (Required)\\n- nsversion: Version string (Required)\\n- nsbinaryversion: Binary compatibility version\\n- nssourcechunk: Source chunk ID (Required)\\n- nsfile: Source file path (Required)"
  },
  "fdm.nodes.ns.handler.upsert": {
    "prefix": "fdm.nodes.ns.handler.upsert",
    "body": [
      "tool.fdm.nodes.ns.handler.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a NsHandler entity exists with the given human handle."
  },
  "fdm.nodes.patch.create": {
    "prefix": "fdm.nodes.patch.create",
    "body": [
      "tool.fdm.nodes.patch.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new Patch. Expects a map of fields.\\nValid keys:\\n- patchcontent: Patch content (Required)\\n- patchinputsha: Optimistic locking SHA\\n- patchsource: Provenance source snapshot"
  },
  "fdm.nodes.patch.find": {
    "prefix": "fdm.nodes.patch.find",
    "body": [
      "tool.fdm.nodes.patch.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds Patch nodes by exact field match."
  },
  "fdm.nodes.patch.get": {
    "prefix": "fdm.nodes.patch.get",
    "body": [
      "tool.fdm.nodes.patch.get(${1:id})"
    ],
    "description": "Gets a Patch node by E_ or N_ ID."
  },
  "fdm.nodes.patch.list": {
    "prefix": "fdm.nodes.patch.list",
    "body": [
      "tool.fdm.nodes.patch.list()"
    ],
    "description": "Lists all active Patch nodes."
  },
  "fdm.nodes.patch.mutate": {
    "prefix": "fdm.nodes.patch.mutate",
    "body": [
      "tool.fdm.nodes.patch.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for Patch. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- patchcontent: Patch content (Required)\\n- patchinputsha: Optimistic locking SHA\\n- patchsource: Provenance source snapshot"
  },
  "fdm.nodes.patch.upsert": {
    "prefix": "fdm.nodes.patch.upsert",
    "body": [
      "tool.fdm.nodes.patch.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a Patch entity exists with the given human handle."
  },
  "fdm.nodes.plan.ingest.create": {
    "prefix": "fdm.nodes.plan.ingest.create",
    "body": [
      "tool.fdm.nodes.plan.ingest.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new PlanIngest. Expects a map of fields.\\nValid keys:\\n- planrepopath: Repository path (Required)\\n- fdmdisplayname: Repository name\\n- plancreatedby: Creator EntityID (Required)\\n- planoverlays: Enabled overlays (Required)\\n- planindexes: Enabled indexes (Required)\\n- planembedmodel: Embedding model\\n- planchunker: Chunking strategy\\n- planignorepatterns: Ignore patterns\\n- planrespectgitignore: Use gitignore\\n- planexcludemimetypes: Excluded MIME types"
  },
  "fdm.nodes.plan.ingest.find": {
    "prefix": "fdm.nodes.plan.ingest.find",
    "body": [
      "tool.fdm.nodes.plan.ingest.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds PlanIngest nodes by exact field match."
  },
  "fdm.nodes.plan.ingest.get": {
    "prefix": "fdm.nodes.plan.ingest.get",
    "body": [
      "tool.fdm.nodes.plan.ingest.get(${1:id})"
    ],
    "description": "Gets a PlanIngest node by E_ or N_ ID."
  },
  "fdm.nodes.plan.ingest.list": {
    "prefix": "fdm.nodes.plan.ingest.list",
    "body": [
      "tool.fdm.nodes.plan.ingest.list()"
    ],
    "description": "Lists all active PlanIngest nodes."
  },
  "fdm.nodes.plan.ingest.mutate": {
    "prefix": "fdm.nodes.plan.ingest.mutate",
    "body": [
      "tool.fdm.nodes.plan.ingest.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for PlanIngest. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- planrepopath: Repository path (Required)\\n- fdmdisplayname: Repository name\\n- plancreatedby: Creator EntityID (Required)\\n- planoverlays: Enabled overlays (Required)\\n- planindexes: Enabled indexes (Required)\\n- planembedmodel: Embedding model\\n- planchunker: Chunking strategy\\n- planignorepatterns: Ignore patterns\\n- planrespectgitignore: Use gitignore\\n- planexcludemimetypes: Excluded MIME types"
  },
  "fdm.nodes.plan.ingest.upsert": {
    "prefix": "fdm.nodes.plan.ingest.upsert",
    "body": [
      "tool.fdm.nodes.plan.ingest.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a PlanIngest entity exists with the given human handle."
  },
  "fdm.nodes.plan.walk.create": {
    "prefix": "fdm.nodes.plan.walk.create",
    "body": [
      "tool.fdm.nodes.plan.walk.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new PlanWalk. Expects a map of fields.\\nValid keys:\\n- planwalkroot: Start path or NodeID (Required)\\n- planwalkoperation: Action to perform (list, submit) (Required)\\n- planwalksource: Walker source (filesystem, overlay)\\n- planwalkfilters: List of filter maps\\n- planwalkincludedirs: Include directories\\n- planwalktarget: Output destination\\n- planwalkfilehandlerfn: Per-file NS function\\n- planwalkdirhandlerfn: Per-dir NS function\\n- planwalkworkqueue: Target Work Queue\\n- planwalktaskdef: Task definition base\\n- planwalktasktemplate: Task template args"
  },
  "fdm.nodes.plan.walk.find": {
    "prefix": "fdm.nodes.plan.walk.find",
    "body": [
      "tool.fdm.nodes.plan.walk.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds PlanWalk nodes by exact field match."
  },
  "fdm.nodes.plan.walk.get": {
    "prefix": "fdm.nodes.plan.walk.get",
    "body": [
      "tool.fdm.nodes.plan.walk.get(${1:id})"
    ],
    "description": "Gets a PlanWalk node by E_ or N_ ID."
  },
  "fdm.nodes.plan.walk.list": {
    "prefix": "fdm.nodes.plan.walk.list",
    "body": [
      "tool.fdm.nodes.plan.walk.list()"
    ],
    "description": "Lists all active PlanWalk nodes."
  },
  "fdm.nodes.plan.walk.mutate": {
    "prefix": "fdm.nodes.plan.walk.mutate",
    "body": [
      "tool.fdm.nodes.plan.walk.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for PlanWalk. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- planwalkroot: Start path or NodeID (Required)\\n- planwalkoperation: Action to perform (list, submit) (Required)\\n- planwalksource: Walker source (filesystem, overlay)\\n- planwalkfilters: List of filter maps\\n- planwalkincludedirs: Include directories\\n- planwalktarget: Output destination\\n- planwalkfilehandlerfn: Per-file NS function\\n- planwalkdirhandlerfn: Per-dir NS function\\n- planwalkworkqueue: Target Work Queue\\n- planwalktaskdef: Task definition base\\n- planwalktasktemplate: Task template args"
  },
  "fdm.nodes.plan.walk.upsert": {
    "prefix": "fdm.nodes.plan.walk.upsert",
    "body": [
      "tool.fdm.nodes.plan.walk.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a PlanWalk entity exists with the given human handle."
  },
  "fdm.nodes.project.create": {
    "prefix": "fdm.nodes.project.create",
    "body": [
      "tool.fdm.nodes.project.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new Project. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Project Name (Required)\\n- projectrepos: Associated repos\\n- projectgoals: Project goals\\n- projectoverlays: Active overlays\\n- projectpolicies: Project policies\\n- projectprimaryforum: Primary forum EntityID\\n- projectmetrics: Project metrics\\n- projectteam: Team group EntityID\\n- projectforums: Associated forum EntityIDs\\n- projectworkqid: Associated work queue EntityID"
  },
  "fdm.nodes.project.find": {
    "prefix": "fdm.nodes.project.find",
    "body": [
      "tool.fdm.nodes.project.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds Project nodes by exact field match."
  },
  "fdm.nodes.project.get": {
    "prefix": "fdm.nodes.project.get",
    "body": [
      "tool.fdm.nodes.project.get(${1:id})"
    ],
    "description": "Gets a Project node by E_ or N_ ID."
  },
  "fdm.nodes.project.list": {
    "prefix": "fdm.nodes.project.list",
    "body": [
      "tool.fdm.nodes.project.list()"
    ],
    "description": "Lists all active Project nodes."
  },
  "fdm.nodes.project.mutate": {
    "prefix": "fdm.nodes.project.mutate",
    "body": [
      "tool.fdm.nodes.project.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for Project. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Project Name (Required)\\n- projectrepos: Associated repos\\n- projectgoals: Project goals\\n- projectoverlays: Active overlays\\n- projectpolicies: Project policies\\n- projectprimaryforum: Primary forum EntityID\\n- projectmetrics: Project metrics\\n- projectteam: Team group EntityID\\n- projectforums: Associated forum EntityIDs\\n- projectworkqid: Associated work queue EntityID"
  },
  "fdm.nodes.project.upsert": {
    "prefix": "fdm.nodes.project.upsert",
    "body": [
      "tool.fdm.nodes.project.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a Project entity exists with the given human handle."
  },
  "fdm.nodes.role.assignment.create": {
    "prefix": "fdm.nodes.role.assignment.create",
    "body": [
      "tool.fdm.nodes.role.assignment.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new RoleAssignment. Expects a map of fields.\\nValid keys:\\n- roleassignee: The assignee agent (Required)\\n- rolescopenode: Specific node scope\\n- rolescope: Free-text scope label\\n- rolesource: Assignment source\\n- rolestatus: Status hint\\n- rolecreatedat: Creation timestamp\\n- roleexpiresat: Expiration timestamp\\n- roleweight: Numeric weight as string\\n- roleresponsibilities: Responsibility overrides\\n- rolehints: Implementation hints"
  },
  "fdm.nodes.role.assignment.find": {
    "prefix": "fdm.nodes.role.assignment.find",
    "body": [
      "tool.fdm.nodes.role.assignment.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds RoleAssignment nodes by exact field match."
  },
  "fdm.nodes.role.assignment.get": {
    "prefix": "fdm.nodes.role.assignment.get",
    "body": [
      "tool.fdm.nodes.role.assignment.get(${1:id})"
    ],
    "description": "Gets a RoleAssignment node by E_ or N_ ID."
  },
  "fdm.nodes.role.assignment.list": {
    "prefix": "fdm.nodes.role.assignment.list",
    "body": [
      "tool.fdm.nodes.role.assignment.list()"
    ],
    "description": "Lists all active RoleAssignment nodes."
  },
  "fdm.nodes.role.assignment.mutate": {
    "prefix": "fdm.nodes.role.assignment.mutate",
    "body": [
      "tool.fdm.nodes.role.assignment.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for RoleAssignment. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- roleassignee: The assignee agent (Required)\\n- rolescopenode: Specific node scope\\n- rolescope: Free-text scope label\\n- rolesource: Assignment source\\n- rolestatus: Status hint\\n- rolecreatedat: Creation timestamp\\n- roleexpiresat: Expiration timestamp\\n- roleweight: Numeric weight as string\\n- roleresponsibilities: Responsibility overrides\\n- rolehints: Implementation hints"
  },
  "fdm.nodes.role.assignment.upsert": {
    "prefix": "fdm.nodes.role.assignment.upsert",
    "body": [
      "tool.fdm.nodes.role.assignment.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a RoleAssignment entity exists with the given human handle."
  },
  "fdm.nodes.role.create": {
    "prefix": "fdm.nodes.role.create",
    "body": [
      "tool.fdm.nodes.role.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new Role. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Human-friendly title (Required)\\n- roledescription: Description (Required)\\n- rolescope: Scope hint\\n- roletypicalevents: Typical events\\n- roleresponsibilities: Responsibilities\\n- rolehints: Structured hints"
  },
  "fdm.nodes.role.find": {
    "prefix": "fdm.nodes.role.find",
    "body": [
      "tool.fdm.nodes.role.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds Role nodes by exact field match."
  },
  "fdm.nodes.role.get": {
    "prefix": "fdm.nodes.role.get",
    "body": [
      "tool.fdm.nodes.role.get(${1:id})"
    ],
    "description": "Gets a Role node by E_ or N_ ID."
  },
  "fdm.nodes.role.list": {
    "prefix": "fdm.nodes.role.list",
    "body": [
      "tool.fdm.nodes.role.list()"
    ],
    "description": "Lists all active Role nodes."
  },
  "fdm.nodes.role.mutate": {
    "prefix": "fdm.nodes.role.mutate",
    "body": [
      "tool.fdm.nodes.role.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for Role. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Human-friendly title (Required)\\n- roledescription: Description (Required)\\n- rolescope: Scope hint\\n- roletypicalevents: Typical events\\n- roleresponsibilities: Responsibilities\\n- rolehints: Structured hints"
  },
  "fdm.nodes.role.upsert": {
    "prefix": "fdm.nodes.role.upsert",
    "body": [
      "tool.fdm.nodes.role.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a Role entity exists with the given human handle."
  },
  "fdm.nodes.structure.subsystem.create": {
    "prefix": "fdm.nodes.structure.subsystem.create",
    "body": [
      "tool.fdm.nodes.structure.subsystem.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new StructureSubsystem. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Subsystem Name (Required)\\n- structuredescription: Description of the subsystem's purpose\\n- structurestrategy: Strategy used to define this subsystem (Required)\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID"
  },
  "fdm.nodes.structure.subsystem.find": {
    "prefix": "fdm.nodes.structure.subsystem.find",
    "body": [
      "tool.fdm.nodes.structure.subsystem.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds StructureSubsystem nodes by exact field match."
  },
  "fdm.nodes.structure.subsystem.get": {
    "prefix": "fdm.nodes.structure.subsystem.get",
    "body": [
      "tool.fdm.nodes.structure.subsystem.get(${1:id})"
    ],
    "description": "Gets a StructureSubsystem node by E_ or N_ ID."
  },
  "fdm.nodes.structure.subsystem.list": {
    "prefix": "fdm.nodes.structure.subsystem.list",
    "body": [
      "tool.fdm.nodes.structure.subsystem.list()"
    ],
    "description": "Lists all active StructureSubsystem nodes."
  },
  "fdm.nodes.structure.subsystem.mutate": {
    "prefix": "fdm.nodes.structure.subsystem.mutate",
    "body": [
      "tool.fdm.nodes.structure.subsystem.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for StructureSubsystem. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Subsystem Name (Required)\\n- structuredescription: Description of the subsystem's purpose\\n- structurestrategy: Strategy used to define this subsystem (Required)\\n- analysisrunid: Analysis Run ID\\n- verrepoid: Repository EntityID"
  },
  "fdm.nodes.structure.subsystem.upsert": {
    "prefix": "fdm.nodes.structure.subsystem.upsert",
    "body": [
      "tool.fdm.nodes.structure.subsystem.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a StructureSubsystem entity exists with the given human handle."
  },
  "fdm.nodes.summary.create": {
    "prefix": "fdm.nodes.summary.create",
    "body": [
      "tool.fdm.nodes.summary.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new Summary. Expects a map of fields.\\nValid keys:\\n- summarytext: Summary text (Required)\\n- fsiparent: Parent node snapshot (Required)"
  },
  "fdm.nodes.summary.find": {
    "prefix": "fdm.nodes.summary.find",
    "body": [
      "tool.fdm.nodes.summary.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds Summary nodes by exact field match."
  },
  "fdm.nodes.summary.get": {
    "prefix": "fdm.nodes.summary.get",
    "body": [
      "tool.fdm.nodes.summary.get(${1:id})"
    ],
    "description": "Gets a Summary node by E_ or N_ ID."
  },
  "fdm.nodes.summary.list": {
    "prefix": "fdm.nodes.summary.list",
    "body": [
      "tool.fdm.nodes.summary.list()"
    ],
    "description": "Lists all active Summary nodes."
  },
  "fdm.nodes.summary.mutate": {
    "prefix": "fdm.nodes.summary.mutate",
    "body": [
      "tool.fdm.nodes.summary.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for Summary. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- summarytext: Summary text (Required)\\n- fsiparent: Parent node snapshot (Required)"
  },
  "fdm.nodes.summary.upsert": {
    "prefix": "fdm.nodes.summary.upsert",
    "body": [
      "tool.fdm.nodes.summary.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a Summary entity exists with the given human handle."
  },
  "fdm.nodes.sys.cursor.create": {
    "prefix": "fdm.nodes.sys.cursor.create",
    "body": [
      "tool.fdm.nodes.sys.cursor.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SysCursor. Expects a map of fields.\\nValid keys:\\n- syscursorseq: Last processed sequence (Required)\\n- syscursorts: Timestamp of cursor (Required)"
  },
  "fdm.nodes.sys.cursor.find": {
    "prefix": "fdm.nodes.sys.cursor.find",
    "body": [
      "tool.fdm.nodes.sys.cursor.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SysCursor nodes by exact field match."
  },
  "fdm.nodes.sys.cursor.get": {
    "prefix": "fdm.nodes.sys.cursor.get",
    "body": [
      "tool.fdm.nodes.sys.cursor.get(${1:id})"
    ],
    "description": "Gets a SysCursor node by E_ or N_ ID."
  },
  "fdm.nodes.sys.cursor.list": {
    "prefix": "fdm.nodes.sys.cursor.list",
    "body": [
      "tool.fdm.nodes.sys.cursor.list()"
    ],
    "description": "Lists all active SysCursor nodes."
  },
  "fdm.nodes.sys.cursor.mutate": {
    "prefix": "fdm.nodes.sys.cursor.mutate",
    "body": [
      "tool.fdm.nodes.sys.cursor.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SysCursor. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- syscursorseq: Last processed sequence (Required)\\n- syscursorts: Timestamp of cursor (Required)"
  },
  "fdm.nodes.sys.cursor.upsert": {
    "prefix": "fdm.nodes.sys.cursor.upsert",
    "body": [
      "tool.fdm.nodes.sys.cursor.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SysCursor entity exists with the given human handle."
  },
  "fdm.nodes.sys.finding.create": {
    "prefix": "fdm.nodes.sys.finding.create",
    "body": [
      "tool.fdm.nodes.sys.finding.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SysFinding. Expects a map of fields.\\nValid keys:\\n- systarget: The node where the issue was found (Required)\\n- sysdetector: Name of the detector/rule (Required)\\n- syserror: Error message or description (Required)\\n- sysseverity: Severity level (Required)\\n- sysstatus: Finding status (Required)"
  },
  "fdm.nodes.sys.finding.find": {
    "prefix": "fdm.nodes.sys.finding.find",
    "body": [
      "tool.fdm.nodes.sys.finding.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SysFinding nodes by exact field match."
  },
  "fdm.nodes.sys.finding.get": {
    "prefix": "fdm.nodes.sys.finding.get",
    "body": [
      "tool.fdm.nodes.sys.finding.get(${1:id})"
    ],
    "description": "Gets a SysFinding node by E_ or N_ ID."
  },
  "fdm.nodes.sys.finding.list": {
    "prefix": "fdm.nodes.sys.finding.list",
    "body": [
      "tool.fdm.nodes.sys.finding.list()"
    ],
    "description": "Lists all active SysFinding nodes."
  },
  "fdm.nodes.sys.finding.mutate": {
    "prefix": "fdm.nodes.sys.finding.mutate",
    "body": [
      "tool.fdm.nodes.sys.finding.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SysFinding. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- systarget: The node where the issue was found (Required)\\n- sysdetector: Name of the detector/rule (Required)\\n- syserror: Error message or description (Required)\\n- sysseverity: Severity level (Required)\\n- sysstatus: Finding status (Required)"
  },
  "fdm.nodes.sys.finding.upsert": {
    "prefix": "fdm.nodes.sys.finding.upsert",
    "body": [
      "tool.fdm.nodes.sys.finding.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SysFinding entity exists with the given human handle."
  },
  "fdm.nodes.sys.kms_key.create": {
    "prefix": "fdm.nodes.sys.kms_key.create",
    "body": [
      "tool.fdm.nodes.sys.kms_key.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SysKmsKey. Expects a map of fields.\\nValid keys:\\n- syskmslabel: Human-readable label for the key (Required)\\n- syskmskeyid: The specific Key ID (ULID) (Required)\\n- syskmskind: The KeyKind (Ed25519, AES, etc) (Required)\\n- syskmscreated: Creation timestamp (Unix Nano) (Required)\\n- syskmsmetajson: Additional public metadata (JSON) (Required)\\n- syskmsnonce: Nonce used to seal this record (Required)\\n- syskmsaad: Associated Data used for integrity (Required)\\n- syskmsciphertext: The sealed private key material (Required)"
  },
  "fdm.nodes.sys.kms_key.find": {
    "prefix": "fdm.nodes.sys.kms_key.find",
    "body": [
      "tool.fdm.nodes.sys.kms_key.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SysKmsKey nodes by exact field match."
  },
  "fdm.nodes.sys.kms_key.get": {
    "prefix": "fdm.nodes.sys.kms_key.get",
    "body": [
      "tool.fdm.nodes.sys.kms_key.get(${1:id})"
    ],
    "description": "Gets a SysKmsKey node by E_ or N_ ID."
  },
  "fdm.nodes.sys.kms_key.list": {
    "prefix": "fdm.nodes.sys.kms_key.list",
    "body": [
      "tool.fdm.nodes.sys.kms_key.list()"
    ],
    "description": "Lists all active SysKmsKey nodes."
  },
  "fdm.nodes.sys.kms_key.mutate": {
    "prefix": "fdm.nodes.sys.kms_key.mutate",
    "body": [
      "tool.fdm.nodes.sys.kms_key.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SysKmsKey. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- syskmslabel: Human-readable label for the key (Required)\\n- syskmskeyid: The specific Key ID (ULID) (Required)\\n- syskmskind: The KeyKind (Ed25519, AES, etc) (Required)\\n- syskmscreated: Creation timestamp (Unix Nano) (Required)\\n- syskmsmetajson: Additional public metadata (JSON) (Required)\\n- syskmsnonce: Nonce used to seal this record (Required)\\n- syskmsaad: Associated Data used for integrity (Required)\\n- syskmsciphertext: The sealed private key material (Required)"
  },
  "fdm.nodes.sys.kms_key.upsert": {
    "prefix": "fdm.nodes.sys.kms_key.upsert",
    "body": [
      "tool.fdm.nodes.sys.kms_key.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SysKmsKey entity exists with the given human handle."
  },
  "fdm.nodes.sys.kms_meta.create": {
    "prefix": "fdm.nodes.sys.kms_meta.create",
    "body": [
      "tool.fdm.nodes.sys.kms_meta.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SysKmsMeta. Expects a map of fields.\\nValid keys:\\n- syskmsver: Schema version (Required)\\n- syskmskdfparams: JSON encoded KDF parameters (Required)\\n- syskmssalt: KDF salt (Required)\\n- syskmsdeknonce: Nonce used to seal the DEK (Required)\\n- syskmsdekcipher: The sealed Data Encryption Key (DEK) (Required)"
  },
  "fdm.nodes.sys.kms_meta.find": {
    "prefix": "fdm.nodes.sys.kms_meta.find",
    "body": [
      "tool.fdm.nodes.sys.kms_meta.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SysKmsMeta nodes by exact field match."
  },
  "fdm.nodes.sys.kms_meta.get": {
    "prefix": "fdm.nodes.sys.kms_meta.get",
    "body": [
      "tool.fdm.nodes.sys.kms_meta.get(${1:id})"
    ],
    "description": "Gets a SysKmsMeta node by E_ or N_ ID."
  },
  "fdm.nodes.sys.kms_meta.list": {
    "prefix": "fdm.nodes.sys.kms_meta.list",
    "body": [
      "tool.fdm.nodes.sys.kms_meta.list()"
    ],
    "description": "Lists all active SysKmsMeta nodes."
  },
  "fdm.nodes.sys.kms_meta.mutate": {
    "prefix": "fdm.nodes.sys.kms_meta.mutate",
    "body": [
      "tool.fdm.nodes.sys.kms_meta.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SysKmsMeta. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- syskmsver: Schema version (Required)\\n- syskmskdfparams: JSON encoded KDF parameters (Required)\\n- syskmssalt: KDF salt (Required)\\n- syskmsdeknonce: Nonce used to seal the DEK (Required)\\n- syskmsdekcipher: The sealed Data Encryption Key (DEK) (Required)"
  },
  "fdm.nodes.sys.kms_meta.upsert": {
    "prefix": "fdm.nodes.sys.kms_meta.upsert",
    "body": [
      "tool.fdm.nodes.sys.kms_meta.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SysKmsMeta entity exists with the given human handle."
  },
  "fdm.nodes.sys.lifecycle.create": {
    "prefix": "fdm.nodes.sys.lifecycle.create",
    "body": [
      "tool.fdm.nodes.sys.lifecycle.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SysLifecycle. Expects a map of fields.\\nValid keys:\\n- sysevent: The lifecycle event name (Required)\\n- systimestamp: When the event occurred\\n- sysversion: System version at the time of the event\\n- sysdetails: Additional metadata"
  },
  "fdm.nodes.sys.lifecycle.find": {
    "prefix": "fdm.nodes.sys.lifecycle.find",
    "body": [
      "tool.fdm.nodes.sys.lifecycle.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SysLifecycle nodes by exact field match."
  },
  "fdm.nodes.sys.lifecycle.get": {
    "prefix": "fdm.nodes.sys.lifecycle.get",
    "body": [
      "tool.fdm.nodes.sys.lifecycle.get(${1:id})"
    ],
    "description": "Gets a SysLifecycle node by E_ or N_ ID."
  },
  "fdm.nodes.sys.lifecycle.list": {
    "prefix": "fdm.nodes.sys.lifecycle.list",
    "body": [
      "tool.fdm.nodes.sys.lifecycle.list()"
    ],
    "description": "Lists all active SysLifecycle nodes."
  },
  "fdm.nodes.sys.lifecycle.mutate": {
    "prefix": "fdm.nodes.sys.lifecycle.mutate",
    "body": [
      "tool.fdm.nodes.sys.lifecycle.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SysLifecycle. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- sysevent: The lifecycle event name (Required)\\n- systimestamp: When the event occurred\\n- sysversion: System version at the time of the event\\n- sysdetails: Additional metadata"
  },
  "fdm.nodes.sys.lifecycle.upsert": {
    "prefix": "fdm.nodes.sys.lifecycle.upsert",
    "body": [
      "tool.fdm.nodes.sys.lifecycle.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SysLifecycle entity exists with the given human handle."
  },
  "fdm.nodes.sys.store_item.create": {
    "prefix": "fdm.nodes.sys.store_item.create",
    "body": [
      "tool.fdm.nodes.sys.store_item.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SysStoreItem. Expects a map of fields.\\nValid keys:\\n- sysstorebucket: The logical bucket (e.g., 'system', 'users/bob') (Required)\\n- sysstorekey: The item key (Required)\\n- sysstorevalue: The stored data (Required)\\n- sysstoredeleted: If true, this key is deleted"
  },
  "fdm.nodes.sys.store_item.find": {
    "prefix": "fdm.nodes.sys.store_item.find",
    "body": [
      "tool.fdm.nodes.sys.store_item.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SysStoreItem nodes by exact field match."
  },
  "fdm.nodes.sys.store_item.get": {
    "prefix": "fdm.nodes.sys.store_item.get",
    "body": [
      "tool.fdm.nodes.sys.store_item.get(${1:id})"
    ],
    "description": "Gets a SysStoreItem node by E_ or N_ ID."
  },
  "fdm.nodes.sys.store_item.list": {
    "prefix": "fdm.nodes.sys.store_item.list",
    "body": [
      "tool.fdm.nodes.sys.store_item.list()"
    ],
    "description": "Lists all active SysStoreItem nodes."
  },
  "fdm.nodes.sys.store_item.mutate": {
    "prefix": "fdm.nodes.sys.store_item.mutate",
    "body": [
      "tool.fdm.nodes.sys.store_item.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SysStoreItem. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- sysstorebucket: The logical bucket (e.g., 'system', 'users/bob') (Required)\\n- sysstorekey: The item key (Required)\\n- sysstorevalue: The stored data (Required)\\n- sysstoredeleted: If true, this key is deleted"
  },
  "fdm.nodes.sys.store_item.upsert": {
    "prefix": "fdm.nodes.sys.store_item.upsert",
    "body": [
      "tool.fdm.nodes.sys.store_item.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SysStoreItem entity exists with the given human handle."
  },
  "fdm.nodes.system.bootstrap.create": {
    "prefix": "fdm.nodes.system.bootstrap.create",
    "body": [
      "tool.fdm.nodes.system.bootstrap.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new SystemBootstrap. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Name of this FDM instance (Required)\\n- systemsaiagentid: The EntityID of the System AI"
  },
  "fdm.nodes.system.bootstrap.find": {
    "prefix": "fdm.nodes.system.bootstrap.find",
    "body": [
      "tool.fdm.nodes.system.bootstrap.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds SystemBootstrap nodes by exact field match."
  },
  "fdm.nodes.system.bootstrap.get": {
    "prefix": "fdm.nodes.system.bootstrap.get",
    "body": [
      "tool.fdm.nodes.system.bootstrap.get(${1:id})"
    ],
    "description": "Gets a SystemBootstrap node by E_ or N_ ID."
  },
  "fdm.nodes.system.bootstrap.list": {
    "prefix": "fdm.nodes.system.bootstrap.list",
    "body": [
      "tool.fdm.nodes.system.bootstrap.list()"
    ],
    "description": "Lists all active SystemBootstrap nodes."
  },
  "fdm.nodes.system.bootstrap.mutate": {
    "prefix": "fdm.nodes.system.bootstrap.mutate",
    "body": [
      "tool.fdm.nodes.system.bootstrap.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for SystemBootstrap. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Name of this FDM instance (Required)\\n- systemsaiagentid: The EntityID of the System AI"
  },
  "fdm.nodes.system.bootstrap.upsert": {
    "prefix": "fdm.nodes.system.bootstrap.upsert",
    "body": [
      "tool.fdm.nodes.system.bootstrap.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a SystemBootstrap entity exists with the given human handle."
  },
  "fdm.nodes.task.create": {
    "prefix": "fdm.nodes.task.create",
    "body": [
      "tool.fdm.nodes.task.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new Task. Expects a map of fields.\\nValid keys:\\n- fdmdisplayname: Summary of the task (Required)\\n- taskstate: Lifecycle state (Required)\\n- taskdescription: Detailed instructions\\n- taskkind: Work Profile ID (Required)\\n- taskstatus: Workflow status (Required)\\n- taskqueueid: The Queue this task belongs to (Required)\\n- taskprojectid: Project context\\n- taskcontext: Related nodes\\n- taskpriority: Scheduling priority\\n- taskreviewrequired: If true, requires manual approval\\n- taskavailableat: Epoch time\\n- taskmaxattempts: Retry limit\\n- taskattempts: Attempts\\n- taskactiveorder: Active WorkOrder\\n- taskresultref: Result reference\\n- tasklastsuccessorder: Last success\\n- taskargs: Arguments\\n- taskpolicy: Policy overrides\\n- taskprogress: Progress\\n- taskqueuehint: Routing hint"
  },
  "fdm.nodes.task.find": {
    "prefix": "fdm.nodes.task.find",
    "body": [
      "tool.fdm.nodes.task.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds Task nodes by exact field match."
  },
  "fdm.nodes.task.get": {
    "prefix": "fdm.nodes.task.get",
    "body": [
      "tool.fdm.nodes.task.get(${1:id})"
    ],
    "description": "Gets a Task node by E_ or N_ ID."
  },
  "fdm.nodes.task.list": {
    "prefix": "fdm.nodes.task.list",
    "body": [
      "tool.fdm.nodes.task.list()"
    ],
    "description": "Lists all active Task nodes."
  },
  "fdm.nodes.task.mutate": {
    "prefix": "fdm.nodes.task.mutate",
    "body": [
      "tool.fdm.nodes.task.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for Task. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- fdmdisplayname: Summary of the task (Required)\\n- taskstate: Lifecycle state (Required)\\n- taskdescription: Detailed instructions\\n- taskkind: Work Profile ID (Required)\\n- taskstatus: Workflow status (Required)\\n- taskqueueid: The Queue this task belongs to (Required)\\n- taskprojectid: Project context\\n- taskcontext: Related nodes\\n- taskpriority: Scheduling priority\\n- taskreviewrequired: If true, requires manual approval\\n- taskavailableat: Epoch time\\n- taskmaxattempts: Retry limit\\n- taskattempts: Attempts\\n- taskactiveorder: Active WorkOrder\\n- taskresultref: Result reference\\n- tasklastsuccessorder: Last success\\n- taskargs: Arguments\\n- taskpolicy: Policy overrides\\n- taskprogress: Progress\\n- taskqueuehint: Routing hint"
  },
  "fdm.nodes.task.upsert": {
    "prefix": "fdm.nodes.task.upsert",
    "body": [
      "tool.fdm.nodes.task.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a Task entity exists with the given human handle."
  },
  "fdm.nodes.work.order.create": {
    "prefix": "fdm.nodes.work.order.create",
    "body": [
      "tool.fdm.nodes.work.order.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new WorkOrder. Expects a map of fields.\\nValid keys:\\n- worktaskid: Task ID (Required)\\n- workworkerid: Worker Agent EntityID (Required)\\n- workstatus: Status (Required)\\n- workexpiresat: Expiration\\n- workerror: Error message\\n- workresultdata: Result data"
  },
  "fdm.nodes.work.order.find": {
    "prefix": "fdm.nodes.work.order.find",
    "body": [
      "tool.fdm.nodes.work.order.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds WorkOrder nodes by exact field match."
  },
  "fdm.nodes.work.order.get": {
    "prefix": "fdm.nodes.work.order.get",
    "body": [
      "tool.fdm.nodes.work.order.get(${1:id})"
    ],
    "description": "Gets a WorkOrder node by E_ or N_ ID."
  },
  "fdm.nodes.work.order.list": {
    "prefix": "fdm.nodes.work.order.list",
    "body": [
      "tool.fdm.nodes.work.order.list()"
    ],
    "description": "Lists all active WorkOrder nodes."
  },
  "fdm.nodes.work.order.mutate": {
    "prefix": "fdm.nodes.work.order.mutate",
    "body": [
      "tool.fdm.nodes.work.order.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for WorkOrder. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- worktaskid: Task ID (Required)\\n- workworkerid: Worker Agent EntityID (Required)\\n- workstatus: Status (Required)\\n- workexpiresat: Expiration\\n- workerror: Error message\\n- workresultdata: Result data"
  },
  "fdm.nodes.work.order.upsert": {
    "prefix": "fdm.nodes.work.order.upsert",
    "body": [
      "tool.fdm.nodes.work.order.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a WorkOrder entity exists with the given human handle."
  },
  "fdm.nodes.work.queue.create": {
    "prefix": "fdm.nodes.work.queue.create",
    "body": [
      "tool.fdm.nodes.work.queue.create({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Creates a new WorkQueue. Expects a map of fields.\\nValid keys:\\n- workprojectid: Owner project (Required)\\n- fdmdisplayname: Queue name (Required)\\n- workkind: Type of work (Required)\\n- workstate: Operational state (Required)\\n- workpolicies: Policies (DLP: max_attempts, backoff_strategy)\\n- worksupervisor: Supervisor Agent EntityID\\n- workbudgets: Budgets\\n- workusage: Usage"
  },
  "fdm.nodes.work.queue.find": {
    "prefix": "fdm.nodes.work.queue.find",
    "body": [
      "tool.fdm.nodes.work.queue.find({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Finds WorkQueue nodes by exact field match."
  },
  "fdm.nodes.work.queue.get": {
    "prefix": "fdm.nodes.work.queue.get",
    "body": [
      "tool.fdm.nodes.work.queue.get(${1:id})"
    ],
    "description": "Gets a WorkQueue node by E_ or N_ ID."
  },
  "fdm.nodes.work.queue.list": {
    "prefix": "fdm.nodes.work.queue.list",
    "body": [
      "tool.fdm.nodes.work.queue.list()"
    ],
    "description": "Lists all active WorkQueue nodes."
  },
  "fdm.nodes.work.queue.mutate": {
    "prefix": "fdm.nodes.work.queue.mutate",
    "body": [
      "tool.fdm.nodes.work.queue.mutate(${1:entity}, ${2:updates})"
    ],
    "description": "Partial update for WorkQueue. Uses Optimistic Locking via _version.\\nUpdateable keys:\\n- workprojectid: Owner project (Required)\\n- fdmdisplayname: Queue name (Required)\\n- workkind: Type of work (Required)\\n- workstate: Operational state (Required)\\n- workpolicies: Policies (DLP: max_attempts, backoff_strategy)\\n- worksupervisor: Supervisor Agent EntityID\\n- workbudgets: Budgets\\n- workusage: Usage"
  },
  "fdm.nodes.work.queue.upsert": {
    "prefix": "fdm.nodes.work.queue.upsert",
    "body": [
      "tool.fdm.nodes.work.queue.upsert(${1:handle}, ${2:fields})"
    ],
    "description": "Ensures a WorkQueue entity exists with the given human handle."
  },
  "fdm.persist.del": {
    "prefix": "fdm.persist.del",
    "body": [
      "tool.fdm.persist.del(${1:uri})"
    ],
    "description": "Deletes a value at a specific storage URI."
  },
  "fdm.persist.get": {
    "prefix": "fdm.persist.get",
    "body": [
      "tool.fdm.persist.get(${1:uri})"
    ],
    "description": "Retrieves a value from a storage URI as a string."
  },
  "fdm.persist.list": {
    "prefix": "fdm.persist.list",
    "body": [
      "tool.fdm.persist.list(${1:uri_prefix})"
    ],
    "description": "Lists all keys and values under a given URI prefix."
  },
  "fdm.persist.put": {
    "prefix": "fdm.persist.put",
    "body": [
      "tool.fdm.persist.put(${1:uri}, ${2:value})"
    ],
    "description": "Saves a value (string or bytes) to a storage URI."
  },
  "fdm.persist_admin.add_mount": {
    "prefix": "fdm.persist_admin.add_mount",
    "body": [
      "tool.fdm.persist_admin.add_mount({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Adds a new mount to the storage configuration. Privileged."
  },
  "fdm.persistence.Snapshot": {
    "prefix": "fdm.persistence.Snapshot",
    "body": [
      "tool.fdm.persistence.Snapshot(${1:reason})"
    ],
    "description": "Triggers a global system snapshot (Graph + Vector + Registry)."
  },
  "fdm.walk": {
    "prefix": "fdm.walk",
    "body": [
      "tool.fdm.walk(${1:pattern}, ${2:source})"
    ],
    "description": "Walks a directory tree or overlay using a glob pattern."
  },
  "fdm.workq.ack": {
    "prefix": "fdm.workq.ack",
    "body": [
      "tool.fdm.workq.ack({",
      "    \"order_id\": ${1:order_id (string)},",
      "    \"result\": ${2:result (string)}",
      "})"
    ],
    "description": "Simple completion. Marks the WorkOrder as 'Complete'."
  },
  "fdm.workq.create_queue": {
    "prefix": "fdm.workq.create_queue",
    "body": [
      "tool.fdm.workq.create_queue({",
      "    \"project_id\": ${1:project_id (entityid)},",
      "    \"name\": ${2:name (string)},",
      "    \"kind\": ${3:kind (string)},",
      "    \"state\": ${4:state (string)},",
      "    \"max_fuel\": ${5:max_fuel (int)},",
      "    \"max_tokens\": ${6:max_tokens (int)}",
      "})"
    ],
    "description": "Initializes a new WorkQueue entity."
  },
  "fdm.workq.delete_queue": {
    "prefix": "fdm.workq.delete_queue",
    "body": [
      "tool.fdm.workq.delete_queue({",
      "    \"queue_id\": ${1:queue_id (entityid)}",
      "})"
    ],
    "description": "Permanently removes a work queue."
  },
  "fdm.workq.dequeue": {
    "prefix": "fdm.workq.dequeue",
    "body": [
      "tool.fdm.workq.dequeue({",
      "    \"types\": ${1:types (list)},",
      "    \"projects\": ${2:projects (list)},",
      "    \"lease_sec\": ${3:lease_sec (int)}",
      "})"
    ],
    "description": "Claims the highest-priority pending Task from the queue."
  },
  "fdm.workq.enqueue": {
    "prefix": "fdm.workq.enqueue",
    "body": [
      "tool.fdm.workq.enqueue({",
      "    \"queue_id\": ${1:queue_id (entityid)},",
      "    \"project_id\": ${2:project_id (entityid)},",
      "    \"kind\": ${3:kind (string)},",
      "    \"args\": ${4:args (map)},",
      "    \"priority\": ${5:priority (int)},",
      "    \"policy\": ${6:policy (map)},",
      "    \"context\": ${7:context (list)}",
      "})"
    ],
    "description": "Creates a persistent 'Task' node and adds it to the specified queue."
  },
  "fdm.workq.list_queues": {
    "prefix": "fdm.workq.list_queues",
    "body": [
      "tool.fdm.workq.list_queues({",
      "    \"project_id\": ${1:project_id (entityid)}",
      "})"
    ],
    "description": "Returns a list of all work queues."
  },
  "fdm.workq.nack": {
    "prefix": "fdm.workq.nack",
    "body": [
      "tool.fdm.workq.nack({",
      "    \"order_id\": ${1:order_id (string)},",
      "    \"reason\": ${2:reason (string)},",
      "    \"delay_sec\": ${3:delay_sec (int)}",
      "})"
    ],
    "description": "Reports failure to process a task."
  },
  "fdm.workq.pause_queue": {
    "prefix": "fdm.workq.pause_queue",
    "body": [
      "tool.fdm.workq.pause_queue({",
      "    \"queue_id\": ${1:queue_id (entityid)}",
      "})"
    ],
    "description": "Transitions a queue to the 'Paused' state."
  },
  "fdm.workq.progress": {
    "prefix": "fdm.workq.progress",
    "body": [
      "tool.fdm.workq.progress({",
      "    \"order_id\": ${1:order_id (string)},",
      "    \"fuel_rem\": ${2:fuel_rem (int)},",
      "    \"tokens_rem\": ${3:tokens_rem (int)},",
      "    \"msg\": ${4:msg (string)}",
      "})"
    ],
    "description": "Updates resource usage for a running WorkOrder."
  },
  "fdm.workq.reindex": {
    "prefix": "fdm.workq.reindex",
    "body": [
      "tool.fdm.workq.reindex()"
    ],
    "description": "Forces a re-scan of the graph to restore state."
  },
  "fdm.workq.resume_queue": {
    "prefix": "fdm.workq.resume_queue",
    "body": [
      "tool.fdm.workq.resume_queue({",
      "    \"queue_id\": ${1:queue_id (entityid)}",
      "})"
    ],
    "description": "Transitions a queue to the 'Active' state."
  },
  "fdm.workq.submit_work": {
    "prefix": "fdm.workq.submit_work",
    "body": [
      "tool.fdm.workq.submit_work({",
      "    \"order_id\": ${1:order_id (string)},",
      "    \"payload\": ${2:payload (any)}",
      "})"
    ],
    "description": "Marks a WorkOrder as successfully completed with a result payload."
  },
  "fs.Append": {
    "prefix": "fs.Append",
    "body": [
      "tool.fs.Append(${1:filepath}, ${2:content})"
    ],
    "description": "Appends content to a specific file. Creates the file and parent directories if needed. Returns 'OK' on success."
  },
  "fs.Delete": {
    "prefix": "fs.Delete",
    "body": [
      "tool.fs.Delete(${1:path})"
    ],
    "description": "Deletes a file or an empty directory. Returns 'OK' on success or if path doesn't exist."
  },
  "fs.ExecutePlan": {
    "prefix": "fs.ExecutePlan",
    "body": [
      "tool.fs.ExecutePlan(${1:plan_obj})"
    ],
    "description": "Executes declarative plan."
  },
  "fs.Hash": {
    "prefix": "fs.Hash",
    "body": [
      "tool.fs.Hash(${1:filepath})"
    ],
    "description": "Calculates the SHA256 hash of a specified file. Returns the hex-encoded hash string."
  },
  "fs.LineCount": {
    "prefix": "fs.LineCount",
    "body": [
      "tool.fs.LineCount(${1:filepath})"
    ],
    "description": "Counts lines in a specified file. Returns line count as an integer."
  },
  "fs.List": {
    "prefix": "fs.List",
    "body": [
      "tool.fs.List(${1:path}, ${2:recursive})"
    ],
    "description": "Lists files and subdirectories at a given path. Returns a list of maps, each describing an entry."
  },
  "fs.Mkdir": {
    "prefix": "fs.Mkdir",
    "body": [
      "tool.fs.Mkdir(${1:path})"
    ],
    "description": "Creates a directory (like mkdir -p). Returns a success message."
  },
  "fs.Move": {
    "prefix": "fs.Move",
    "body": [
      "tool.fs.Move(${1:source_path}, ${2:destination_path})"
    ],
    "description": "Moves or renames a file or directory within the sandbox."
  },
  "fs.Read": {
    "prefix": "fs.Read",
    "body": [
      "tool.fs.Read(${1:filepath})"
    ],
    "description": "Reads the entire content of a specific file. Returns the content as a string."
  },
  "fs.SanitizeFilename": {
    "prefix": "fs.SanitizeFilename",
    "body": [
      "tool.fs.SanitizeFilename(${1:name})"
    ],
    "description": "Cleans a string to make it suitable for use as part of a filename."
  },
  "fs.Stat": {
    "prefix": "fs.Stat",
    "body": [
      "tool.fs.Stat(${1:path})"
    ],
    "description": "Gets information about a file or directory. Returns a map of file info."
  },
  "fs.Walk": {
    "prefix": "fs.Walk",
    "body": [
      "tool.fs.Walk(${1:path})"
    ],
    "description": "Recursively walks a directory, returning a list of maps describing files/subdirectories found."
  },
  "fs.Write": {
    "prefix": "fs.Write",
    "body": [
      "tool.fs.Write(${1:filepath}, ${2:content})"
    ],
    "description": "Writes content to a specific file, overwriting it if it exists. Creates parent directories if needed. Returns 'OK' on success."
  },
  "git.Add": {
    "prefix": "git.Add",
    "body": [
      "tool.git.Add(${1:relative_path}, ${2:paths})"
    ],
    "description": "Adds file contents to the index."
  },
  "git.Branch": {
    "prefix": "git.Branch",
    "body": [
      "tool.git.Branch(${1:relative_path}, ${2:name}, ${3:checkout}, ${4:list_remote}, ${5:list_all})"
    ],
    "description": "Manages branches."
  },
  "git.Checkout": {
    "prefix": "git.Checkout",
    "body": [
      "tool.git.Checkout(${1:relative_path}, ${2:branch}, ${3:create})"
    ],
    "description": "Switches branches or restores working tree files."
  },
  "git.Clone": {
    "prefix": "git.Clone",
    "body": [
      "tool.git.Clone(${1:repository_url}, ${2:relative_path})"
    ],
    "description": "Clones a Git repository."
  },
  "git.Commit": {
    "prefix": "git.Commit",
    "body": [
      "tool.git.Commit(${1:relative_path}, ${2:commit_message}, ${3:allow_empty})"
    ],
    "description": "Commits staged changes."
  },
  "git.Diff": {
    "prefix": "git.Diff",
    "body": [
      "tool.git.Diff(${1:relative_path}, ${2:cached}, ${3:commit1}, ${4:commit2}, ${5:path})"
    ],
    "description": "Shows changes between commits, commit and working tree, etc."
  },
  "git.Merge": {
    "prefix": "git.Merge",
    "body": [
      "tool.git.Merge(${1:relative_path}, ${2:branch})"
    ],
    "description": "Joins two or more development histories together."
  },
  "git.Pull": {
    "prefix": "git.Pull",
    "body": [
      "tool.git.Pull(${1:relative_path}, ${2:remote_name}, ${3:branch_name})"
    ],
    "description": "Pulls the latest changes from the remote repository."
  },
  "git.Push": {
    "prefix": "git.Push",
    "body": [
      "tool.git.Push(${1:relative_path}, ${2:remote_name}, ${3:branch_name})"
    ],
    "description": "Pushes committed changes to a remote repository."
  },
  "git.Reset": {
    "prefix": "git.Reset",
    "body": [
      "tool.git.Reset(${1:relative_path}, ${2:mode}, ${3:commit})"
    ],
    "description": "Resets the current HEAD to the specified state."
  },
  "git.Rm": {
    "prefix": "git.Rm",
    "body": [
      "tool.git.Rm(${1:relative_path}, ${2:paths})"
    ],
    "description": "Removes files from the working tree and from the index."
  },
  "git.Status": {
    "prefix": "git.Status",
    "body": [
      "tool.git.Status(${1:repo_path})"
    ],
    "description": "Gets the status of the Git repository."
  },
  "gotools.Build": {
    "prefix": "gotools.Build",
    "body": [
      "tool.gotools.Build(${1:target})"
    ],
    "description": "Runs 'go build' for a specified target in the sandbox. Defaults to './...'."
  },
  "gotools.Check": {
    "prefix": "gotools.Check",
    "body": [
      "tool.gotools.Check(${1:target})"
    ],
    "description": "Checks Go code validity using 'go list -e -json \u003ctarget\u003e' within the sandbox. Returns a map indicating success and error details."
  },
  "gotools.Fmt": {
    "prefix": "gotools.Fmt",
    "body": [
      "tool.gotools.Fmt(${1:content})"
    ],
    "description": "Formats Go source code using 'go/format.Source'. Returns the formatted code or an error map."
  },
  "gotools.GetModuleInfo": {
    "prefix": "gotools.GetModuleInfo",
    "body": [
      "tool.gotools.GetModuleInfo(${1:directory})"
    ],
    "description": "Finds and parses the go.mod file relevant to a directory by searching upwards. Returns a map with module path, go version, root directory, requires, and replaces, or nil if not found."
  },
  "gotools.Imports": {
    "prefix": "gotools.Imports",
    "body": [
      "tool.gotools.Imports(${1:content})"
    ],
    "description": "Formats Go source code and adjusts imports using 'golang.org/x/tools/imports'. Returns the processed code or an error map."
  },
  "gotools.ListPackages": {
    "prefix": "gotools.ListPackages",
    "body": [
      "tool.gotools.ListPackages(${1:target_directory}, ${2:patterns})"
    ],
    "description": "Runs 'go list -json' for specified patterns in a target directory. Returns a list of maps, each describing a package."
  },
  "gotools.ModTidy": {
    "prefix": "gotools.ModTidy",
    "body": [
      "tool.gotools.ModTidy()"
    ],
    "description": "Runs 'go mod tidy' in the sandbox to add missing and remove unused modules. Operates in the sandbox root."
  },
  "gotools.Staticcheck": {
    "prefix": "gotools.Staticcheck",
    "body": [
      "tool.gotools.Staticcheck(${1:target})"
    ],
    "description": "Runs 'staticcheck' on the specified target(s) in the sandbox. Reports bugs, stylistic errors, and performance issues. Defaults to './...'. Assumes 'staticcheck' is in PATH."
  },
  "gotools.Test": {
    "prefix": "gotools.Test",
    "body": [
      "tool.gotools.Test(${1:target})"
    ],
    "description": "Runs 'go test' for a specified target in the sandbox. Defaults to './...'."
  },
  "gotools.Vet": {
    "prefix": "gotools.Vet",
    "body": [
      "tool.gotools.Vet(${1:target})"
    ],
    "description": "Runs 'go vet' on the specified target(s) in the sandbox to report likely mistakes in Go source code. Defaults to './...'."
  },
  "handle.IsValid": {
    "prefix": "handle.IsValid",
    "body": [
      "tool.handle.IsValid(${1:h})"
    ],
    "description": "Checks if a handle is valid (exists in the active registry)."
  },
  "handle.Type": {
    "prefix": "handle.Type",
    "body": [
      "tool.handle.Type(${1:h})"
    ],
    "description": "Returns the kind/type tag of an opaque handle (e.g., 'fsmeta', 'overlaymeta')."
  },
  "io.Input": {
    "prefix": "io.Input",
    "body": [
      "tool.io.Input(${1:message})"
    ],
    "description": "Displays a message and waits for user input from standard input. Returns the input as a string."
  },
  "io.Print": {
    "prefix": "io.Print",
    "body": [
      "tool.io.Print(${1:values})"
    ],
    "description": "Prints values to the standard output. If multiple values are passed in a list, they are printed space-separated."
  },
  "list.Append": {
    "prefix": "list.Append",
    "body": [
      "tool.list.Append(${1:list}, ${2:element})"
    ],
    "description": "Returns a *new* list with the given element added to the end."
  },
  "list.AppendInPlace": {
    "prefix": "list.AppendInPlace",
    "body": [
      "tool.list.AppendInPlace(${1:list}, ${2:element})"
    ],
    "description": "Efficiently returns a list with the element added. Intended for building lists in loops."
  },
  "list.Contains": {
    "prefix": "list.Contains",
    "body": [
      "tool.list.Contains(${1:list}, ${2:element})"
    ],
    "description": "Checks if a list contains a specific element (using deep equality comparison)."
  },
  "list.Get": {
    "prefix": "list.Get",
    "body": [
      "tool.list.Get(${1:list}, ${2:index}, ${3:default})"
    ],
    "description": "Safely gets the element at a specific index (0-based). Returns nil or the optional default value if the index is out of bounds."
  },
  "list.Head": {
    "prefix": "list.Head",
    "body": [
      "tool.list.Head(${1:list})"
    ],
    "description": "Returns the first element of the list, or nil if the list is empty."
  },
  "list.IsEmpty": {
    "prefix": "list.IsEmpty",
    "body": [
      "tool.list.IsEmpty(${1:list})"
    ],
    "description": "Returns true if the list has zero elements, false otherwise."
  },
  "list.Length": {
    "prefix": "list.Length",
    "body": [
      "tool.list.Length(${1:list})"
    ],
    "description": "Returns the number of elements in a list."
  },
  "list.Prepend": {
    "prefix": "list.Prepend",
    "body": [
      "tool.list.Prepend(${1:list}, ${2:element})"
    ],
    "description": "Returns a *new* list with the given element added to the beginning."
  },
  "list.Rest": {
    "prefix": "list.Rest",
    "body": [
      "tool.list.Rest(${1:list})"
    ],
    "description": "Returns a *new* list containing all elements except the first. Returns an empty list if the input list has 0 or 1 element."
  },
  "list.Reverse": {
    "prefix": "list.Reverse",
    "body": [
      "tool.list.Reverse(${1:list})"
    ],
    "description": "Returns a *new* list with the elements in reverse order."
  },
  "list.Slice": {
    "prefix": "list.Slice",
    "body": [
      "tool.list.Slice(${1:list}, ${2:start}, ${3:end})"
    ],
    "description": "Returns a *new* list containing elements from the start index (inclusive) up to the end index (exclusive). Follows Go slice semantics (indices are clamped, invalid range returns empty list)."
  },
  "list.Sort": {
    "prefix": "list.Sort",
    "body": [
      "tool.list.Sort(${1:list})"
    ],
    "description": "Returns a *new* list with elements sorted. Restricted to lists containing only numbers (int/float) or only strings. Throws error for mixed types or non-sortable types (nil, bool, list, map)."
  },
  "list.Tail": {
    "prefix": "list.Tail",
    "body": [
      "tool.list.Tail(${1:list}, ${2:count})"
    ],
    "description": "Returns a *new* list containing the last 'count' elements. Returns an empty list if count \u003c= 0. Returns a copy of the whole list if count \u003e= list length."
  },
  "math.Add": {
    "prefix": "math.Add",
    "body": [
      "tool.math.Add(${1:num1}, ${2:num2})"
    ],
    "description": "Calculates the sum of two numbers (integers or decimals). Strings convertible to numbers are accepted."
  },
  "math.Divide": {
    "prefix": "math.Divide",
    "body": [
      "tool.math.Divide(${1:num1}, ${2:num2})"
    ],
    "description": "Calculates the division of two numbers (num1 / num2). Returns float. Handles division by zero."
  },
  "math.Modulo": {
    "prefix": "math.Modulo",
    "body": [
      "tool.math.Modulo(${1:num1}, ${2:num2})"
    ],
    "description": "Calculates the modulo (remainder) of two integers (num1 % num2). Handles division by zero."
  },
  "math.Multiply": {
    "prefix": "math.Multiply",
    "body": [
      "tool.math.Multiply(${1:num1}, ${2:num2})"
    ],
    "description": "Calculates the product of two numbers. Strings convertible to numbers are accepted."
  },
  "math.Subtract": {
    "prefix": "math.Subtract",
    "body": [
      "tool.math.Subtract(${1:num1}, ${2:num2})"
    ],
    "description": "Calculates the difference between two numbers (num1 - num2). Strings convertible to numbers are accepted."
  },
  "meta.getToolSpecificationsJson": {
    "prefix": "meta.getToolSpecificationsJson",
    "body": [
      "tool.meta.getToolSpecificationsJson()"
    ],
    "description": "Provides a JSON string containing an array of all currently available tool specifications."
  },
  "meta.listFunctions": {
    "prefix": "meta.listFunctions",
    "body": [
      "tool.meta.listFunctions(${1:filter})"
    ],
    "description": "Lists the names of all functions visible to the interpreter, optionally filtered by name."
  },
  "meta.listGlobalConstants": {
    "prefix": "meta.listGlobalConstants",
    "body": [
      "tool.meta.listGlobalConstants(${1:filter})"
    ],
    "description": "Lists all global constants visible to the interpreter, optionally filtered by name."
  },
  "meta.listToolNames": {
    "prefix": "meta.listToolNames",
    "body": [
      "tool.meta.listToolNames(${1:filter})"
    ],
    "description": "Provides a simple, newline-separated list of all available tool signatures, optionally filtered by name."
  },
  "meta.listTools": {
    "prefix": "meta.listTools",
    "body": [
      "tool.meta.listTools(${1:filter})"
    ],
    "description": "Lists the full specifications of all registered tools, optionally filtered by name."
  },
  "meta.toolsHelp": {
    "prefix": "meta.toolsHelp",
    "body": [
      "tool.meta.toolsHelp(${1:filter})"
    ],
    "description": "Provides formatted Markdown help text for tools, optionally filtered by name."
  },
  "metadata.Detect": {
    "prefix": "metadata.Detect",
    "body": [
      "tool.metadata.Detect(${1:content})"
    ],
    "description": "Detects the serialization format ('md' or 'ns') of a string content by checking for a '::serialization:' key."
  },
  "metadata.NormalizeKey": {
    "prefix": "metadata.NormalizeKey",
    "body": [
      "tool.metadata.NormalizeKey(${1:key})"
    ],
    "description": "Normalizes a metadata key by converting it to lowercase and removing '.', '_', and '-' characters."
  },
  "metadata.Parse": {
    "prefix": "metadata.Parse",
    "body": [
      "tool.metadata.Parse(${1:content})"
    ],
    "description": "Auto-detects serialization and parses content into a metadata map and a content body string."
  },
  "ns.def_global_const": {
    "prefix": "ns.def_global_const",
    "body": [
      "tool.ns.def_global_const(${1:name}, ${2:value})"
    ],
    "description": "Defines a global, immutable constant. Privileged operation."
  },
  "ns.persistDefinitions": {
    "prefix": "ns.persistDefinitions",
    "body": [
      "tool.ns.persistDefinitions()"
    ],
    "description": "Iterates over the current interpreter's definitions (functions and handlers) and persists them to the graph."
  },
  "ns_event.Compose": {
    "prefix": "ns_event.Compose",
    "body": [
      "tool.ns_event.Compose(${1:kind}, ${2:payload}, ${3:id}, ${4:agent_id})"
    ],
    "description": "Creates a valid ns standard event from its constituent parts."
  },
  "ns_event.GetAllPayloads": {
    "prefix": "ns_event.GetAllPayloads",
    "body": [
      "tool.ns_event.GetAllPayloads({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts all coalesced payloads from a raw ns standard event into a list of maps."
  },
  "ns_event.GetEventShape": {
    "prefix": "ns_event.GetEventShape",
    "body": [
      "tool.ns_event.GetEventShape()"
    ],
    "description": "Returns the canonical Shape-Lite definition for a standard ns_event object."
  },
  "ns_event.GetID": {
    "prefix": "ns_event.GetID",
    "body": [
      "tool.ns_event.GetID({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the event ID from the first envelope in an ns standard event."
  },
  "ns_event.GetKind": {
    "prefix": "ns_event.GetKind",
    "body": [
      "tool.ns_event.GetKind({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the event Kind from the first envelope in an ns standard event."
  },
  "ns_event.GetPayload": {
    "prefix": "ns_event.GetPayload",
    "body": [
      "tool.ns_event.GetPayload({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the core payload from a raw ns standard event, unwrapping the outer envelope."
  },
  "ns_event.GetTimestamp": {
    "prefix": "ns_event.GetTimestamp",
    "body": [
      "tool.ns_event.GetTimestamp({",
      "    ${1:key}: ${2:value}",
      "})"
    ],
    "description": "Extracts the event Timestamp (TS) from the first envelope in an ns standard event."
  },
  "os.Getenv": {
    "prefix": "os.Getenv",
    "body": [
      "tool.os.Getenv(${1:varName})"
    ],
    "description": "Gets the value of an environment variable. Requires 'env:read' capability."
  },
  "os.Hostname": {
    "prefix": "os.Hostname",
    "body": [
      "tool.os.Hostname()"
    ],
    "description": "Gets the hostname of the machine."
  },
  "os.Now": {
    "prefix": "os.Now",
    "body": [
      "tool.os.Now()"
    ],
    "description": "Gets the current system time as a Unix timestamp."
  },
  "os.Sleep": {
    "prefix": "os.Sleep",
    "body": [
      "tool.os.Sleep(${1:duration_seconds})"
    ],
    "description": "Pauses execution for a specified duration. Requires 'os:exec:sleep' capability and is subject to policy time limits."
  },
  "script.ListFunctions": {
    "prefix": "script.ListFunctions",
    "body": [
      "tool.script.ListFunctions()"
    ],
    "description": "Returns a map of all currently loaded function (procedure) names to their signatures."
  },
  "script.LoadScript": {
    "prefix": "script.LoadScript",
    "body": [
      "tool.script.LoadScript(${1:script_content})"
    ],
    "description": "Parses a string of NeuroScript code and loads its functions and event handlers into the current interpreter's scope. Does not execute any code."
  },
  "shape.IsValidPath": {
    "prefix": "shape.IsValidPath",
    "body": [
      "tool.shape.IsValidPath(${1:path_string})"
    ],
    "description": "Checks if a string is a syntactically valid Path-Lite expression."
  },
  "shape.Select": {
    "prefix": "shape.Select",
    "body": [
      "tool.shape.Select(${1:value}, ${2:path}, ${3:options})"
    ],
    "description": "Selects a single value from a map or list using a Path-Lite expression."
  },
  "shape.Validate": {
    "prefix": "shape.Validate",
    "body": [
      "tool.shape.Validate(${1:value}, ${2:shape}, ${3:options})"
    ],
    "description": "Validates a map against a Shape-Lite definition."
  },
  "shell.Execute": {
    "prefix": "shell.Execute",
    "body": [
      "tool.shell.Execute(${1:command}, ${2:args_list}, ${3:directory})"
    ],
    "description": "Executes an arbitrary shell command. WARNING: Use with extreme caution due to security risks. Command path validation is basic. Consider using specific tools (e.g., GoBuild, GitAdd) instead."
  },
  "str.BytesFromBase64": {
    "prefix": "str.BytesFromBase64",
    "body": [
      "tool.str.BytesFromBase64(${1:base64_string})"
    ],
    "description": "Decodes a Base64 string (representing bytes) into a string, assuming UTF-8 encoding."
  },
  "str.BytesToBase64": {
    "prefix": "str.BytesToBase64",
    "body": [
      "tool.str.BytesToBase64(${1:string_data})"
    ],
    "description": "Converts a string into a Base64 encoded string representing its UTF-8 bytes."
  },
  "str.Color": {
    "prefix": "str.Color",
    "body": [
      "tool.str.Color(${1:input_string})"
    ],
    "description": "Replaces supported color tags with ANSI escape sequences.\nSupported Tags:\n  Resets: [reset], [default], [bg-default]\n  Styles: [bold], [dim], [italic], [underline], [blink], [reverse], [hidden], [strike]\n  Colors: [black], [red], [green], [yellow], [blue], [magenta], [cyan], [white]\n  Bright: [bright-black] (or [gray]), [bright-red], [bright-green], etc.\n  Backgrounds: [bg-red], [bg-bright-red], etc."
  },
  "str.Compress": {
    "prefix": "str.Compress",
    "body": [
      "tool.str.Compress(${1:input_string})"
    ],
    "description": "Compresses a string using Gzip and returns the result as a Base64-encoded string."
  },
  "str.Concat": {
    "prefix": "str.Concat",
    "body": [
      "tool.str.Concat(${1:strings_list})"
    ],
    "description": "Concatenates a list of strings without a separator."
  },
  "str.Contains": {
    "prefix": "str.Contains",
    "body": [
      "tool.str.Contains(${1:input_string}, ${2:substring})"
    ],
    "description": "Checks if a string contains a substring."
  },
  "str.Decompress": {
    "prefix": "str.Decompress",
    "body": [
      "tool.str.Decompress(${1:base64_encoded_string})"
    ],
    "description": "Decodes a Base64 string and then decompresses the Gzip data to the original string."
  },
  "str.FindAllRegex": {
    "prefix": "str.FindAllRegex",
    "body": [
      "tool.str.FindAllRegex(${1:pattern}, ${2:input_string})"
    ],
    "description": "Finds all non-overlapping occurrences of a regex pattern in a string. Requires 'str:use:regex' capability."
  },
  "str.FromBase64": {
    "prefix": "str.FromBase64",
    "body": [
      "tool.str.FromBase64(${1:encoded_string})"
    ],
    "description": "Decodes a Base64-encoded string."
  },
  "str.FromHex": {
    "prefix": "str.FromHex",
    "body": [
      "tool.str.FromHex(${1:encoded_string})"
    ],
    "description": "Decodes a string from its hexadecimal representation."
  },
  "str.HasPrefix": {
    "prefix": "str.HasPrefix",
    "body": [
      "tool.str.HasPrefix(${1:input_string}, ${2:prefix})"
    ],
    "description": "Checks if a string starts with a prefix."
  },
  "str.HasSuffix": {
    "prefix": "str.HasSuffix",
    "body": [
      "tool.str.HasSuffix(${1:input_string}, ${2:suffix})"
    ],
    "description": "Checks if a string ends with a suffix."
  },
  "str.Inspect": {
    "prefix": "str.Inspect",
    "body": [
      "tool.str.Inspect(${1:input_variable}, ${2:max_length}, ${3:max_depth})"
    ],
    "description": "Returns a human-readable, truncated string representation of any variable. Useful for debugging complex data like maps and lists."
  },
  "str.Join": {
    "prefix": "str.Join",
    "body": [
      "tool.str.Join(${1:string_list}, ${2:separator})"
    ],
    "description": "Joins elements of a list of strings with a separator."
  },
  "str.Length": {
    "prefix": "str.Length",
    "body": [
      "tool.str.Length(${1:input_string})"
    ],
    "description": "Returns the number of UTF-8 characters (runes) in a string."
  },
  "str.LineCount": {
    "prefix": "str.LineCount",
    "body": [
      "tool.str.LineCount(${1:content_string})"
    ],
    "description": "Counts the number of lines in the given string content."
  },
  "str.MatchRegex": {
    "prefix": "str.MatchRegex",
    "body": [
      "tool.str.MatchRegex(${1:pattern}, ${2:input_string})"
    ],
    "description": "Checks if a string matches a regular expression. Requires 'str:use:regex' capability."
  },
  "str.ParseFromJsonBase64": {
    "prefix": "str.ParseFromJsonBase64",
    "body": [
      "tool.str.ParseFromJsonBase64(${1:base64_string})"
    ],
    "description": "Parses JSON data from a Base64 encoded string (representing bytes) into a map or list."
  },
  "str.ParseJsonString": {
    "prefix": "str.ParseJsonString",
    "body": [
      "tool.str.ParseJsonString(${1:json_string})"
    ],
    "description": "Parses JSON data from a plain string into a map or list."
  },
  "str.Replace": {
    "prefix": "str.Replace",
    "body": [
      "tool.str.Replace(${1:input_string}, ${2:old_substring}, ${3:new_substring}, ${4:count})"
    ],
    "description": "Replaces occurrences of a substring with another, up to a specified count."
  },
  "str.ReplaceRegex": {
    "prefix": "str.ReplaceRegex",
    "body": [
      "tool.str.ReplaceRegex(${1:pattern}, ${2:input_string}, ${3:replacement})"
    ],
    "description": "Replaces all occurrences of a regex pattern in a string with a replacement string. Requires 'str:use:regex' capability."
  },
  "str.Split": {
    "prefix": "str.Split",
    "body": [
      "tool.str.Split(${1:input_string}, ${2:delimiter})"
    ],
    "description": "Splits a string by a delimiter."
  },
  "str.SplitWords": {
    "prefix": "str.SplitWords",
    "body": [
      "tool.str.SplitWords(${1:input_string})"
    ],
    "description": "Splits a string into words based on whitespace."
  },
  "str.StripAnsi": {
    "prefix": "str.StripAnsi",
    "body": [
      "tool.str.StripAnsi(${1:input_string})"
    ],
    "description": "Removes all ANSI escape sequences from a string."
  },
  "str.Substring": {
    "prefix": "str.Substring",
    "body": [
      "tool.str.Substring(${1:input_string}, ${2:start_index}, ${3:length})"
    ],
    "description": "Returns a portion of the string (rune-based indexing), from start_index for a given length."
  },
  "str.ToBase64": {
    "prefix": "str.ToBase64",
    "body": [
      "tool.str.ToBase64(${1:input_string})"
    ],
    "description": "Encodes a string using standard Base64 encoding."
  },
  "str.ToHex": {
    "prefix": "str.ToHex",
    "body": [
      "tool.str.ToHex(${1:input_string})"
    ],
    "description": "Encodes a string into a hexadecimal representation."
  },
  "str.ToJsonString": {
    "prefix": "str.ToJsonString",
    "body": [
      "tool.str.ToJsonString(${1:value}, ${2:pretty_print}, ${3:prefix}, ${4:indent})"
    ],
    "description": "Converts any value (map, list, string, number, etc.) into a JSON formatted string."
  },
  "str.ToLower": {
    "prefix": "str.ToLower",
    "body": [
      "tool.str.ToLower(${1:input_string})"
    ],
    "description": "Converts a string to lowercase."
  },
  "str.ToUpper": {
    "prefix": "str.ToUpper",
    "body": [
      "tool.str.ToUpper(${1:input_string})"
    ],
    "description": "Converts a string to uppercase."
  },
  "str.TrimPrefix": {
    "prefix": "str.TrimPrefix",
    "body": [
      "tool.str.TrimPrefix(${1:input_string}, ${2:prefix})"
    ],
    "description": "Removes the prefix string from the input string if it exists."
  },
  "str.TrimSpace": {
    "prefix": "str.TrimSpace",
    "body": [
      "tool.str.TrimSpace(${1:input_string})"
    ],
    "description": "Removes leading and trailing whitespace from a string."
  },
  "str.TrimSuffix": {
    "prefix": "str.TrimSuffix",
    "body": [
      "tool.str.TrimSuffix(${1:input_string}, ${2:suffix})"
    ],
    "description": "Removes the suffix string from the input string if it exists."
  },
  "syntax.analyzeNSSyntax": {
    "prefix": "syntax.analyzeNSSyntax",
    "body": [
      "tool.syntax.analyzeNSSyntax(${1:nsScriptContent})"
    ],
    "description": "Analyzes a NeuroScript string for syntax errors. Returns a list of maps, where each map details an error. Returns an empty list if no errors are found."
  },
  "system.set_bootstrap_config": {
    "prefix": "system.set_bootstrap_config",
    "body": [
      "tool.system.set_bootstrap_config(${1:fdm_name}, ${2:sai_agent_id})"
    ],
    "description": "Sets the system's core bootstrap configuration. This is a privileged operation."
  },
  "time.Now": {
    "prefix": "time.Now",
    "body": [
      "tool.time.Now()"
    ],
    "description": "Returns the current system time as a 'timedate' value."
  },
  "time.Sleep": {
    "prefix": "time.Sleep",
    "body": [
      "tool.time.Sleep(${1:duration_seconds})"
    ],
    "description": "Pauses the script execution for a specified duration."
  },
  "tree.AddChildNode": {
    "prefix": "tree.AddChildNode",
    "body": [
      "tool.tree.AddChildNode(${1:tree_handle}, ${2:parent_node_id}, ${3:new_node_id_suggestion}, ${4:node_type}, ${5:value}, ${6:key_for_object_parent})"
    ],
    "description": "Adds a new child node to an existing parent node."
  },
  "tree.FindNodes": {
    "prefix": "tree.FindNodes",
    "body": [
      "tool.tree.FindNodes(${1:tree_handle}, ${2:start_node_id}, ${3:query_map}, ${4:max_depth}, ${5:max_results})"
    ],
    "description": "Finds nodes within a tree that match specific criteria."
  },
  "tree.GetChildren": {
    "prefix": "tree.GetChildren",
    "body": [
      "tool.tree.GetChildren(${1:tree_handle}, ${2:node_id})"
    ],
    "description": "Gets a list of node IDs of the children of a given 'array' type node."
  },
  "tree.GetNode": {
    "prefix": "tree.GetNode",
    "body": [
      "tool.tree.GetNode(${1:tree_handle}, ${2:node_id})"
    ],
    "description": "Retrieves detailed information about a specific node within a tree, returned as a map."
  },
  "tree.GetNodeByPath": {
    "prefix": "tree.GetNodeByPath",
    "body": [
      "tool.tree.GetNodeByPath(${1:tree_handle}, ${2:path})"
    ],
    "description": "Retrieves a node from a tree using a dot-separated path expression."
  },
  "tree.GetNodeMetadata": {
    "prefix": "tree.GetNodeMetadata",
    "body": [
      "tool.tree.GetNodeMetadata(${1:tree_handle}, ${2:node_id})"
    ],
    "description": "Retrieves the metadata attributes of a specific node as a map."
  },
  "tree.GetParent": {
    "prefix": "tree.GetParent",
    "body": [
      "tool.tree.GetParent(${1:tree_handle}, ${2:node_id})"
    ],
    "description": "Gets the parent of a given node as a map."
  },
  "tree.GetRoot": {
    "prefix": "tree.GetRoot",
    "body": [
      "tool.tree.GetRoot(${1:tree_handle})"
    ],
    "description": "Retrieves the root node of the tree as a map."
  },
  "tree.LoadJSON": {
    "prefix": "tree.LoadJSON",
    "body": [
      "tool.tree.LoadJSON(${1:json_string})"
    ],
    "description": "Loads a JSON string into a new tree structure and returns a tree handle."
  },
  "tree.RemoveNode": {
    "prefix": "tree.RemoveNode",
    "body": [
      "tool.tree.RemoveNode(${1:tree_handle}, ${2:node_id})"
    ],
    "description": "Removes a node and all its descendants from the tree."
  },
  "tree.RemoveNodeMetadata": {
    "prefix": "tree.RemoveNodeMetadata",
    "body": [
      "tool.tree.RemoveNodeMetadata(${1:tree_handle}, ${2:node_id}, ${3:metadata_key})"
    ],
    "description": "Removes a metadata attribute from a node."
  },
  "tree.RemoveObjectAttribute": {
    "prefix": "tree.RemoveObjectAttribute",
    "body": [
      "tool.tree.RemoveObjectAttribute(${1:tree_handle}, ${2:object_node_id}, ${3:attribute_key})"
    ],
    "description": "Removes an attribute from an 'object' type node."
  },
  "tree.RenderText": {
    "prefix": "tree.RenderText",
    "body": [
      "tool.tree.RenderText(${1:tree_handle})"
    ],
    "description": "Renders a visual text representation of the entire tree structure."
  },
  "tree.SetNodeMetadata": {
    "prefix": "tree.SetNodeMetadata",
    "body": [
      "tool.tree.SetNodeMetadata(${1:tree_handle}, ${2:node_id}, ${3:metadata_key}, ${4:metadata_value})"
    ],
    "description": "Sets a metadata attribute as a key-value string pair on any node."
  },
  "tree.SetObjectAttribute": {
    "prefix": "tree.SetObjectAttribute",
    "body": [
      "tool.tree.SetObjectAttribute(${1:tree_handle}, ${2:object_node_id}, ${3:attribute_key}, ${4:child_node_id})"
    ],
    "description": "Sets or updates an attribute on an 'object' type node."
  },
  "tree.SetValue": {
    "prefix": "tree.SetValue",
    "body": [
      "tool.tree.SetValue(${1:tree_handle}, ${2:node_id}, ${3:value})"
    ],
    "description": "Sets the value of an existing leaf or simple-type node."
  },
  "tree.ToJSON": {
    "prefix": "tree.ToJSON",
    "body": [
      "tool.tree.ToJSON(${1:tree_handle})"
    ],
    "description": "Converts a tree structure back into a pretty-printed JSON string."
  }
}
Thinking Process:

Goal: Implement the ability to execute a NeuroScript procedure (CALL ProcedureName(...)) but apply the tool restrictions (allowlist/denylist) that would normally apply to an LLM agent calling TOOL.FunctionName(...).
User Request Analysis:
User wants to run a script (potentially generated by an LLM).
This script should be executed with limited tool access, specifically using the same restrictions defined for the LLM agent mode (allowlist/denylist).
This acts as a safety mechanism for running potentially untrusted scripts.
Current State:
The interpreter (pkg/core/interpreter.go) executes CALL TOOL.* directly using the registered tools.
The agent mode (pkg/neurogo/app_agent.go) uses a SecurityLayer (pkg/core/security.go) to validate TOOL.* calls originating from the LLM before execution. This layer checks denylists, allowlists, and performs argument validation.
Proposed Solution - Conceptual:
Introduce a new execution mode or flag within the interpreter itself that signals "restricted execution."
When the interpreter encounters a CALL TOOL.* step and this restricted mode is active, it should route the call through a validation layer before executing the tool function.
This validation layer should use the same logic/configuration (allowlist/denylist) as the agent's SecurityLayer.
Implementation Options:
Option A: Modify Interpreter.executeCall:
Add a flag to the Interpreter struct, e.g., restrictedToolMode bool.
Add fields for the allowlist/denylist (similar to SecurityLayer). These would need to be loaded based on configuration passed to the interpreter.
In executeCall, when strings.HasPrefix(target, "TOOL.") is true and restrictedToolMode is true:
Perform allowlist/denylist checks before getting the toolImpl.
Crucially, how to handle argument validation? executeCall gets evaluatedArgs as []interface{}, while SecurityLayer.ValidateToolCall expects map[string]interface{} (like the LLM FunctionCall). This mismatch is problematic. We'd need to reconstruct the arg map from the toolImpl.Spec and the ordered evaluatedArgs before passing to a validation function similar to SecurityLayer.validateArgumentsAgainstSpec. This adds complexity.
If validation passes, execute toolImpl.Func.
If restrictedToolMode is false, execute normally.
Option B: Introduce a "Restricted Caller Context":
Modify the ToolFunc signature slightly or pass context differently. Maybe ToolFunc func(interpreter *Interpreter, args []interface{}, callCtx ToolCallContext) (interface{}, error).
ToolCallContext could include info like IsRestricted bool.
Inside ToolFunc implementations (e.g., toolReadFile, toolExecuteCommand), check callCtx.IsRestricted. If true, apply stricter internal checks (e.g., always deny toolExecuteCommand, enforce stricter path validation).
This distributes the checks into each tool, which might be less maintainable and harder to configure centrally via allow/deny lists. Argument validation still needs handling before the call.
Option C: Introduce a New High-Level "Run Restricted" Function:
Create a new function like Interpreter.RunProcedureRestricted(procName string, allowlist []string, denylist map[string]bool, sandboxRoot string, args ...string).
This function would create/configure a temporary SecurityLayer (or similar validation logic) specifically for this execution.
It would then call the regular RunProcedure.
The core challenge remains: how does the inner executeCall know it needs to apply restrictions? It needs context passed down.
Option D: New Interpreter Execution Mode:
Similar to Option A, add a mode flag (restrictedToolMode) and configuration (allow/deny lists, sandbox root) to the Interpreter.
When restrictedToolMode is set:
In executeCall for TOOL.* calls:
Look up the ToolSpec.
Check allow/deny lists.
Argument Validation: Convert the positional evaluatedArgs []interface{} into a map[string]interface{} using the ToolSpec.Args names. This is the key step.
Call a validation function (like SecurityLayer.ValidateToolCall, potentially refactored to be reusable or copied) using the constructed arg map, allow/deny lists, and sandbox root. This validator performs type checks, sandbox checks, etc.
If validation fails, return an error to the script.
If validation passes, execute the toolImpl.Func with the original (but validated types) convertedArgs []interface{}. Note: the validation function might return validated/coerced values, but the tool func still expects []interface{}. Ensure consistency.
Refinement - Option D: This seems the most robust. It keeps the validation logic centralized (reusing or adapting the SecurityLayer's logic) and modifies the core executeCall based on an interpreter mode. The main work is mapping positional args to named args for validation and then ensuring the validated args are passed correctly.
Detailed Plan (Option D):

Modify Interpreter Struct (pkg/core/interpreter.go):
Add fields:
isRestrictedMode bool
restrictedAllowlist map[string]bool
restrictedDenylist map[string]bool
restrictedSandboxRoot string
Modify NewInterpreter (or add a new setup function): Allow setting the restriction mode and related configuration when the interpreter is created or configured.
Modify Interpreter.executeCall (pkg/core/interpreter_simple_steps.go):
Inside the if strings.HasPrefix(target, "TOOL.") block:
Add a check: if i.isRestrictedMode { ... }.
Inside the if i.isRestrictedMode block:
Look up toolImpl and toolSpec as currently done. Handle tool not found.
Check Denylist: if i.restrictedDenylist[toolName] { return nil, fmt.Errorf("tool '%s' denied in restricted mode", toolName) }.
Check Allowlist: if !i.restrictedAllowlist[toolName] { return nil, fmt.Errorf("tool '%s' not allowed in restricted mode", toolName) }.
Check High-Risk (e.g., ExecuteCommand): Add specific checks if needed (redundant if denylisted). if toolName == "TOOL.ExecuteCommand" { return nil, ... }.
Prepare Args for Validation: Create rawArgsMap := make(map[string]interface{}). Iterate through toolSpec.Args and evaluatedArgs. If idx < len(evaluatedArgs), map toolSpec.Args[idx].Name to evaluatedArgs[idx].
Validate Arguments: Call a validation function. This could be a refactored version of SecurityLayer.validateArgumentsAgainstSpec that takes the interpreter's restriction config. Let's call it validateRestrictedArgs(toolSpec, rawArgsMap, i.restrictedSandboxRoot). This function performs type checks, sandbox checks (using SecureFilePath with i.restrictedSandboxRoot), etc. It should return the validated map (or potentially just an error).
Handle Validation Error: If validateRestrictedArgs returns an error, propagate it wrapped in context (e.g., fmt.Errorf("restricted tool call validation failed for '%s': %w", toolName, validationErr)).
Proceed to Execution (if validation passed):
The arguments passed to toolImpl.Func should still be the original evaluatedArgs []interface{} slice, because ValidateAndConvertArgs is not called here in the same way as the LLM agent path. The validateRestrictedArgs step primarily serves as a check rather than a conversion pass in this context (though it must perform type checks). We rely on the initial evaluateExpression having produced compatible types.
Call callResultValue, callErr = toolImpl.Func(i, evaluatedArgs).
Store i.lastCallResult = callResultValue if callErr == nil.
Handle callErr.
Outside the if i.isRestrictedMode block (i.e., else): Execute the tool directly as it's currently done (find tool, call ValidateAndConvertArgs, call Func).
Refactor Validation Logic (from pkg/core/security_validation.go):
Create a new function validateRestrictedArgs (or similar) that takes ToolSpec, map[string]interface{}, and sandboxRoot.
This function should reuse the core logic from validateArgumentsAgainstSpec (type checking, sandbox checking using SecureFilePath) but doesn't need to return a modified map if the goal is just validation. It just needs to return an error if any check fails. It primarily ensures arguments conform to the spec and stay within the sandbox.
Update neurogo CLI (pkg/neurogo/app.go, config.go, app_script.go):
Add a new flag (e.g., -restricted) to config.go and ParseFlags.
When running in script mode (app_script.go), if the -restricted flag is set:
Load the allowlist/denylist files specified by the agent flags (-allowlist, -denylist).
Load the sandbox root (-sandbox).
Configure the created Interpreter instance with isRestrictedMode = true and the loaded lists/root.
Testing: Add tests for Interpreter.RunProcedure where isRestrictedMode is true. Test cases should include:
Calling an allowed tool (e.g., StringLength).
Calling a denied tool (e.g., ExecuteCommand if denylisted).
Calling a non-allowlisted tool.
Calling a file tool (ReadFile) with a path inside the sandbox.
Calling a file tool (ReadFile) with a path outside the sandbox (should fail validation).
Calling a tool with incorrect argument types (should fail validation).
Self-Check:

Does the plan address the user's request? Yes.
Does it leverage existing components (Interpreter, SecurityLayer logic)? Yes.
Does it handle the argument type mismatch (slice vs map)? Yes, by reconstructing the map for validation.
Is it reasonably secure? Yes, by applying allow/deny lists and sandbox checks.
Does it require Go code changes? Yes, in Interpreter, execution logic, validation logic, and CLI handling.
Does it require NeuroScript changes? No.
Confidence Score: 4/5 (Complexity in correctly mapping/validating args and integrating the mode requires careful implementation).

Action: Generate the Go code modifications based on Option D. Provide updated interpreter.go, interpreter_simple_steps.go, a new security_restricted_validation.go (or similar for the refactored validation), config.go, and app_script.go.